<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>100张Minecraft高清壁纸</title>
    <url>/2023/0436ca148.html</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/100.png"
                       
                 ></p>
<span id="more"></span>

<h3 id="001"><a href="#001" class="headerlink" title="001"></a>001</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/001.png"
                       
                 ></p>
<h3 id="002"><a href="#002" class="headerlink" title="002"></a>002</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/002.png"
                       
                 ></p>
<h3 id="003"><a href="#003" class="headerlink" title="003"></a>003</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/003.png"
                       
                 ></p>
<h3 id="004"><a href="#004" class="headerlink" title="004"></a>004</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/004.png"
                       
                 ></p>
<h3 id="005"><a href="#005" class="headerlink" title="005"></a>005</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/005.png"
                       
                 ></p>
<h3 id="006"><a href="#006" class="headerlink" title="006"></a>006</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/006.png"
                       
                 ></p>
<h3 id="007"><a href="#007" class="headerlink" title="007"></a>007</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/007.png"
                       
                 ></p>
<h3 id="008"><a href="#008" class="headerlink" title="008"></a>008</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/008.png"
                       
                 ></p>
<h3 id="009"><a href="#009" class="headerlink" title="009"></a>009</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/009.png"
                       
                 ></p>
<h3 id="010"><a href="#010" class="headerlink" title="010"></a>010</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/010.png"
                       
                 ></p>
<h3 id="011"><a href="#011" class="headerlink" title="011"></a>011</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/011.png"
                       
                 ></p>
<h3 id="012"><a href="#012" class="headerlink" title="012"></a>012</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/012.png"
                       
                 ></p>
<h3 id="013"><a href="#013" class="headerlink" title="013"></a>013</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/013.png"
                       
                 ></p>
<h3 id="014"><a href="#014" class="headerlink" title="014"></a>014</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/014.png"
                       
                 ></p>
<h3 id="015"><a href="#015" class="headerlink" title="015"></a>015</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/015.png"
                       
                 ></p>
<h3 id="016"><a href="#016" class="headerlink" title="016"></a>016</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/016.png"
                       
                 ></p>
<h3 id="017"><a href="#017" class="headerlink" title="017"></a>017</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/017.png"
                       
                 ></p>
<h3 id="018"><a href="#018" class="headerlink" title="018"></a>018</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/018.png"
                       
                 ></p>
<h3 id="019"><a href="#019" class="headerlink" title="019"></a>019</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/019.png"
                       
                 ></p>
<h3 id="020"><a href="#020" class="headerlink" title="020"></a>020</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/020.png"
                       
                 ></p>
<h3 id="021"><a href="#021" class="headerlink" title="021"></a>021</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/021.png"
                       
                 ></p>
<h3 id="022"><a href="#022" class="headerlink" title="022"></a>022</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/022.png"
                       
                 ></p>
<h3 id="023"><a href="#023" class="headerlink" title="023"></a>023</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/023.png"
                       
                 ></p>
<h3 id="024"><a href="#024" class="headerlink" title="024"></a>024</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/024.png"
                       
                 ></p>
<h3 id="025"><a href="#025" class="headerlink" title="025"></a>025</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/025.png"
                       
                 ></p>
<h3 id="026"><a href="#026" class="headerlink" title="026"></a>026</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/026.png"
                       
                 ></p>
<h3 id="027"><a href="#027" class="headerlink" title="027"></a>027</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/027.png"
                       
                 ></p>
<h3 id="028"><a href="#028" class="headerlink" title="028"></a>028</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/028.png"
                       
                 ></p>
<h3 id="029"><a href="#029" class="headerlink" title="029"></a>029</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/029.png"
                       
                 ></p>
<h3 id="030"><a href="#030" class="headerlink" title="030"></a>030</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/030.png"
                       
                 ></p>
<h3 id="031"><a href="#031" class="headerlink" title="031"></a>031</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/031.png"
                       
                 ></p>
<h3 id="032"><a href="#032" class="headerlink" title="032"></a>032</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/032.png"
                       
                 ></p>
<h3 id="033"><a href="#033" class="headerlink" title="033"></a>033</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/033.png"
                       
                 ></p>
<h3 id="034"><a href="#034" class="headerlink" title="034"></a>034</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/034.png"
                       
                 ></p>
<h3 id="035"><a href="#035" class="headerlink" title="035"></a>035</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/035.png"
                       
                 ></p>
<h3 id="036"><a href="#036" class="headerlink" title="036"></a>036</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/036.png"
                       
                 ></p>
<h3 id="037"><a href="#037" class="headerlink" title="037"></a>037</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/037.png"
                       
                 ></p>
<h3 id="038"><a href="#038" class="headerlink" title="038"></a>038</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/038.png"
                       
                 ></p>
<h3 id="039"><a href="#039" class="headerlink" title="039"></a>039</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/039.png"
                       
                 ></p>
<h3 id="040"><a href="#040" class="headerlink" title="040"></a>040</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/040.png"
                       
                 ></p>
<h3 id="041"><a href="#041" class="headerlink" title="041"></a>041</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/041.png"
                       
                 ></p>
<h3 id="042"><a href="#042" class="headerlink" title="042"></a>042</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/042.png"
                       
                 ></p>
<h3 id="043"><a href="#043" class="headerlink" title="043"></a>043</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/043.png"
                       
                 ></p>
<h3 id="044"><a href="#044" class="headerlink" title="044"></a>044</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/044.png"
                       
                 ></p>
<h3 id="045"><a href="#045" class="headerlink" title="045"></a>045</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/045.png"
                       
                 ></p>
<h3 id="046"><a href="#046" class="headerlink" title="046"></a>046</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/046.png"
                       
                 ></p>
<h3 id="047"><a href="#047" class="headerlink" title="047"></a>047</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/047.png"
                       
                 ></p>
<h3 id="048"><a href="#048" class="headerlink" title="048"></a>048</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/048.png"
                       
                 ></p>
<h3 id="049"><a href="#049" class="headerlink" title="049"></a>049</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/049.png"
                       
                 ></p>
<h3 id="050"><a href="#050" class="headerlink" title="050"></a>050</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/050.png"
                       
                 ></p>
<h3 id="051"><a href="#051" class="headerlink" title="051"></a>051</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/051.png"
                       
                 ></p>
<h3 id="052"><a href="#052" class="headerlink" title="052"></a>052</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/052.png"
                       
                 ></p>
<h3 id="053"><a href="#053" class="headerlink" title="053"></a>053</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/053.png"
                       
                 ></p>
<h3 id="054"><a href="#054" class="headerlink" title="054"></a>054</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/054.png"
                       
                 ></p>
<h3 id="055"><a href="#055" class="headerlink" title="055"></a>055</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/055.png"
                       
                 ></p>
<h3 id="056"><a href="#056" class="headerlink" title="056"></a>056</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/056.png"
                       
                 ></p>
<h3 id="057"><a href="#057" class="headerlink" title="057"></a>057</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/057.png"
                       
                 ></p>
<h3 id="058"><a href="#058" class="headerlink" title="058"></a>058</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/058.png"
                       
                 ></p>
<h3 id="059"><a href="#059" class="headerlink" title="059"></a>059</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/059.png"
                       
                 ></p>
<h3 id="060"><a href="#060" class="headerlink" title="060"></a>060</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/060.png"
                       
                 ></p>
<h3 id="061"><a href="#061" class="headerlink" title="061"></a>061</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/061.png"
                       
                 ></p>
<h3 id="062"><a href="#062" class="headerlink" title="062"></a>062</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/062.png"
                       
                 ></p>
<h3 id="063"><a href="#063" class="headerlink" title="063"></a>063</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/063.png"
                       
                 ></p>
<h3 id="064"><a href="#064" class="headerlink" title="064"></a>064</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/064.png"
                       
                 ></p>
<h3 id="065"><a href="#065" class="headerlink" title="065"></a>065</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/065.png"
                       
                 ></p>
<h3 id="066"><a href="#066" class="headerlink" title="066"></a>066</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/066.png"
                       
                 ></p>
<h3 id="067"><a href="#067" class="headerlink" title="067"></a>067</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/067.png"
                       
                 ></p>
<h3 id="068"><a href="#068" class="headerlink" title="068"></a>068</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/068.png"
                       
                 ></p>
<h3 id="069"><a href="#069" class="headerlink" title="069"></a>069</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/069.png"
                       
                 ></p>
<h3 id="070"><a href="#070" class="headerlink" title="070"></a>070</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/070.png"
                       
                 ></p>
<h3 id="071"><a href="#071" class="headerlink" title="071"></a>071</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/071.png"
                       
                 ></p>
<h3 id="072"><a href="#072" class="headerlink" title="072"></a>072</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/072.png"
                       
                 ></p>
<h3 id="073"><a href="#073" class="headerlink" title="073"></a>073</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/073.png"
                       
                 ></p>
<h3 id="074"><a href="#074" class="headerlink" title="074"></a>074</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/074.png"
                       
                 ></p>
<h3 id="075"><a href="#075" class="headerlink" title="075"></a>075</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/075.png"
                       
                 ></p>
<h3 id="076"><a href="#076" class="headerlink" title="076"></a>076</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/076.png"
                       
                 ></p>
<h3 id="077"><a href="#077" class="headerlink" title="077"></a>077</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/077.png"
                       
                 ></p>
<h3 id="078"><a href="#078" class="headerlink" title="078"></a>078</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/078.png"
                       
                 ></p>
<h3 id="079"><a href="#079" class="headerlink" title="079"></a>079</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/079.png"
                       
                 ></p>
<h3 id="080"><a href="#080" class="headerlink" title="080"></a>080</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/080.png"
                       
                 ></p>
<h3 id="081"><a href="#081" class="headerlink" title="081"></a>081</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/081.png"
                       
                 ></p>
<h3 id="082"><a href="#082" class="headerlink" title="082"></a>082</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/082.png"
                       
                 ></p>
<h3 id="083"><a href="#083" class="headerlink" title="083"></a>083</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/083.png"
                       
                 ></p>
<h3 id="084"><a href="#084" class="headerlink" title="084"></a>084</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/084.png"
                       
                 ></p>
<h3 id="085"><a href="#085" class="headerlink" title="085"></a>085</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/085.png"
                       
                 ></p>
<h3 id="086"><a href="#086" class="headerlink" title="086"></a>086</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/086.png"
                       
                 ></p>
<h3 id="087"><a href="#087" class="headerlink" title="087"></a>087</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/087.png"
                       
                 ></p>
<h3 id="088"><a href="#088" class="headerlink" title="088"></a>088</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/088.png"
                       
                 ></p>
<h3 id="089"><a href="#089" class="headerlink" title="089"></a>089</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/089.png"
                       
                 ></p>
<h3 id="090"><a href="#090" class="headerlink" title="090"></a>090</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/090.png"
                       
                 ></p>
<h3 id="091"><a href="#091" class="headerlink" title="091"></a>091</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/091.png"
                       
                 ></p>
<h3 id="092"><a href="#092" class="headerlink" title="092"></a>092</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/092.png"
                       
                 ></p>
<h3 id="093"><a href="#093" class="headerlink" title="093"></a>093</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/093.png"
                       
                 ></p>
<h3 id="094"><a href="#094" class="headerlink" title="094"></a>094</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/094.png"
                       
                 ></p>
<h3 id="095"><a href="#095" class="headerlink" title="095"></a>095</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/095.png"
                       
                 ></p>
<h3 id="096"><a href="#096" class="headerlink" title="096"></a>096</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/096.png"
                       
                 ></p>
<h3 id="097"><a href="#097" class="headerlink" title="097"></a>097</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/097.png"
                       
                 ></p>
<h3 id="098"><a href="#098" class="headerlink" title="098"></a>098</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/098.png"
                       
                 ></p>
<h3 id="099"><a href="#099" class="headerlink" title="099"></a>099</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0436ca148/099.png"
                       
                 ></p>
]]></content>
      <tags>
        <tag>壁纸</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>Accessbility可访问性指导文档</title>
    <url>/2022/1261176.html</url>
    <content><![CDATA[<blockquote>
<p>如果你只想知道代码中如何尽快添加accessible辅助功能,请移步第四章</p>
</blockquote>
<h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><p>Accessbility:<br>可访问性。计算机软件的可访问性使应用程序可适用于具有不同能力(这是指听障，视障之类)的人。重要的是要考虑到不同人的需求，例如，在视力、听力、灵活性或认知问题的情况下。用户界面使用特别选择的颜色和高对比度的字体，从而支持屏幕阅读器和盲文显示器等辅助工具。</p>
<p>a11y:<br>类似于i18n,是ACCESSIBILITY的缩写。</p>
<h1 id="第一章-关于标记的几点约束"><a href="#第一章-关于标记的几点约束" class="headerlink" title="第一章 关于标记的几点约束"></a>第一章 关于标记的几点约束</h1><p>1、统信当前的AT自动化只覆盖到图形控件层面，继承自QWidget的类如果需要被自动化脚本识别，都需要添加Accessibility的Name属性<br>2、可访问控件的标记名称,应该是唯一不变的，避免脚本无法识别</p>
<h1 id="第二章-接口Factory函数实现"><a href="#第二章-接口Factory函数实现" class="headerlink" title="第二章 接口Factory函数实现"></a>第二章 接口Factory函数实现</h1><h2 id="2-1-安装AccessibleFactory函数"><a href="#2-1-安装AccessibleFactory函数" class="headerlink" title="2.1 安装AccessibleFactory函数"></a>2.1 安装AccessibleFactory函数</h2><p>当实现窗口小部件的可访问性接口时，通常会继承QAccessibleWidget，这是窗口小部件的便捷类。 另一个可用的便利类是QAccessibleObject，它实现了QObjects接口的一部分(当前的AT脚本只覆盖图形控件，暂时不用考虑QAccessibleObject)。<br>在main函数中安装工厂函数，当通过atspi访问小部件时，将会自动通过此函数指针获取对应控件的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QAccessible::<span class="built_in">installFactory</span>(accessibleFactory);</span><br></pre></td></tr></table></figure>

<p><code>accessibleFactory</code>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAccessible&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAccessibleWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaEnum&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> QString <span class="title">getAccessibleName</span><span class="params">(QWidget *w, QAccessible::Role r, <span class="type">const</span> QString &amp;fallback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEPARATOR <span class="string">&quot;_&quot;</span></span></span><br><span class="line">    <span class="type">const</span> QString lowerFallback = fallback.<span class="built_in">toLower</span>();</span><br><span class="line">    <span class="comment">// 避免重复生成</span></span><br><span class="line">    <span class="type">static</span> QMap&lt;QObject *, QString &gt; objnameMap;</span><br><span class="line">    <span class="keyword">if</span> (!objnameMap[w].<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> objnameMap[w];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> QMap&lt; QAccessible::Role, QList&lt; QString &gt; &gt; accessibleMap;</span><br><span class="line">    QString oldAccessName = w-&gt;<span class="built_in">accessibleName</span>().<span class="built_in">toLower</span>();</span><br><span class="line">    oldAccessName.<span class="built_in">replace</span>(SEPARATOR, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照类型添加固定前缀</span></span><br><span class="line">    QMetaEnum metaEnum = QMetaEnum::<span class="built_in">fromType</span>&lt;QAccessible::Role&gt;();</span><br><span class="line">    QByteArray prefix = metaEnum.<span class="built_in">valueToKeys</span>(r);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">    <span class="keyword">case</span> QAccessible::Button:       prefix = <span class="string">&quot;Btn&quot;</span>;         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QAccessible::StaticText:   prefix = <span class="string">&quot;Label&quot;</span>;       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再加上标识</span></span><br><span class="line">    QString accessibleName = QString::<span class="built_in">fromLatin1</span>(prefix) + SEPARATOR;</span><br><span class="line">    QString objectName = w-&gt;<span class="built_in">objectName</span>().<span class="built_in">toLower</span>();</span><br><span class="line">    accessibleName += oldAccessName.<span class="built_in">isEmpty</span>() ? (objectName.<span class="built_in">isEmpty</span>() ?lowerFallback : objectName) : oldAccessName;</span><br><span class="line">    <span class="comment">// 检查名称是否唯一</span></span><br><span class="line">    <span class="keyword">if</span> (accessibleMap[r].<span class="built_in">contains</span>(accessibleName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!objnameMap.<span class="built_in">key</span>(accessibleName)) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(objnameMap.<span class="built_in">key</span>(accessibleName));</span><br><span class="line">            objnameMap.<span class="built_in">insert</span>(w, accessibleName);</span><br><span class="line">            <span class="keyword">return</span> accessibleName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取编号，然后+1</span></span><br><span class="line">        <span class="type">int</span> pos = accessibleName.<span class="built_in">indexOf</span>(SEPARATOR);</span><br><span class="line">        <span class="type">int</span> id = accessibleName.<span class="built_in">mid</span>(pos + <span class="number">1</span>).<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">        QString newAccessibleName;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 一直找到一个不重复的名字</span></span><br><span class="line">            newAccessibleName = accessibleName + SEPARATOR + QString::<span class="built_in">number</span>(++id);</span><br><span class="line">        &#125; <span class="keyword">while</span> (accessibleMap[r].<span class="built_in">contains</span>(newAccessibleName));</span><br><span class="line"></span><br><span class="line">        accessibleMap[r].<span class="built_in">append</span>(newAccessibleName);</span><br><span class="line">        objnameMap.<span class="built_in">insert</span>(w, newAccessibleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象销毁后移除占用名称</span></span><br><span class="line">        QObject::<span class="built_in">connect</span>(w, &amp;QWidget::destroyed, [ = ] (QObject *obj) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(obj);</span><br><span class="line">            accessibleMap[r].<span class="built_in">removeOne</span>(newAccessibleName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newAccessibleName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accessibleMap[r].<span class="built_in">append</span>(accessibleName);</span><br><span class="line">        objnameMap.<span class="built_in">insert</span>(w, accessibleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象销毁后移除占用名称</span></span><br><span class="line">        QObject::<span class="built_in">connect</span>(w, &amp;QWidget::destroyed, [ = ] (QObject *obj) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(obj);</span><br><span class="line">            accessibleMap[r].<span class="built_in">removeOne</span>(accessibleName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> accessibleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accessible</span> : <span class="keyword">public</span> QAccessibleWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Accessible</span>(QWidget *parent, QAccessible::Role r, <span class="type">const</span> QString &amp;accessibleName)</span><br><span class="line">        : <span class="built_in">QAccessibleWidget</span>(parent, r)</span><br><span class="line">        , <span class="built_in">data</span>(<span class="built_in">qobject_cast</span>&lt;QWidget *&gt;(parent))</span><br><span class="line">        , <span class="built_in">accessibleName</span>(accessibleName)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于使用dogtail的AT自动化测试工作，实际上只需要使用我们提供的text方法获取控件唯一ID,，然后再通过QAccessibleWidget的rect方法找到其坐标，模拟点击即可</span></span><br><span class="line">    <span class="comment">// rect没必要重新实现，text方法通过getAccessibleName确定返回唯一值</span></span><br><span class="line">    <span class="function">QString <span class="title">text</span><span class="params">(QAccessible::Text t)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> QAccessible::Name:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getAccessibleName</span>(data, <span class="keyword">this</span>-&gt;<span class="built_in">role</span>(), accessibleName);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *data;</span><br><span class="line">    QString accessibleName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QAccessibleInterface *<span class="title">accessibleFactory</span><span class="params">(<span class="type">const</span> QString &amp;classname, QObject *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(classname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;<span class="built_in">isWidgetType</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Accessible</span>(<span class="built_in">qobject_cast</span>&lt;QWidget *&gt;(object), QAccessible::Role::Form), object-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>附：<br>Accessible传入的parent必须继承自QWidget，QAccessible::Role代表了标记控件的类型，根据其实际功能，大致有按钮、纯文本等不同的类型，详见Qt帮助文档中对QAccessible::Role的介绍。</p>
<h2 id="2-2-使用sniff命令查看是否成功标记对应控件"><a href="#2-2-使用sniff命令查看是否成功标记对应控件" class="headerlink" title="2.2 使用sniff命令查看是否成功标记对应控件"></a>2.2 使用sniff命令查看是否成功标记对应控件</h2><p>安装python-dopgtail组件</p>
<p><code>sudo apt install python-dogtail</code></p>
<p>在终端输入sniff命令</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/1261176/1.png"
                       
                 ></p>
<p>在打开的AT_SPI Browser中,可以查看电脑上所有应用控件的标记情况<br>下图红框部分就是text()函数给出的字符了<br><img    
                       lazyload
                       alt="image"
                       data-src="2.png"
                         style="zoom:50%;" 
                 ><br>在自动化测试过程中，标记到的控件，其属性Name需要确定一个唯一值且保持恒定不变，也就是代码中的text函数中的QAccessible::Name枚举对应的值</p>
<p>对于一些控件，有时候想直接调用应用提供的一些方法，可以通过重载QAccessibleActionInterface::actionNames()和QAccessibleActionInterface::doAction方法实现。</p>
<h1 id="第三章-插件模式"><a href="#第三章-插件模式" class="headerlink" title="第三章 插件模式"></a>第三章 插件模式</h1><p>继承QAccessiblePlugin，实现对应插件，和第二章区别不大。感兴趣可以看<a class="link"   href="https://doc.qt.io/qt-6/qaccessibleplugin.html" >官方文档<i class="fas fa-external-link-alt"></i></a>。</p>
<h1 id="第四章-实战演练"><a href="#第四章-实战演练" class="headerlink" title="第四章 实战演练"></a>第四章 实战演练</h1><h2 id="4-1-添加快捷宏定义"><a href="#4-1-添加快捷宏定义" class="headerlink" title="4.1 添加快捷宏定义"></a>4.1 添加快捷宏定义</h2><p>在项目中添加以下文件accessible.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SPDX-FileCopyrightText: 2022 UnionTech Software Technology Co., Ltd.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: LGPL-3.0-or-later</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAccessible&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAccessibleWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaEnum&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> QString <span class="title">getAccessibleName</span><span class="params">(QWidget *w, QAccessible::Role r, <span class="type">const</span> QString &amp;fallback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEPARATOR <span class="string">&quot;_&quot;</span></span></span><br><span class="line">    <span class="type">const</span> QString lowerFallback = fallback.<span class="built_in">toLower</span>();</span><br><span class="line">    <span class="comment">// 避免重复生成</span></span><br><span class="line">    <span class="type">static</span> QMap&lt;QObject *, QString &gt; objnameMap;</span><br><span class="line">    <span class="keyword">if</span> (!objnameMap[w].<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> objnameMap[w];</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> QMap&lt; QAccessible::Role, QList&lt; QString &gt; &gt; accessibleMap;</span><br><span class="line">    QString oldAccessName = w-&gt;<span class="built_in">accessibleName</span>().<span class="built_in">toLower</span>();</span><br><span class="line">    oldAccessName.<span class="built_in">replace</span>(SEPARATOR, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照类型添加固定前缀</span></span><br><span class="line">    QMetaEnum metaEnum = QMetaEnum::<span class="built_in">fromType</span>&lt;QAccessible::Role&gt;();</span><br><span class="line">    QByteArray prefix = metaEnum.<span class="built_in">valueToKeys</span>(r);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">    <span class="keyword">case</span> QAccessible::Button:       prefix = <span class="string">&quot;Btn&quot;</span>;         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QAccessible::StaticText:   prefix = <span class="string">&quot;Label&quot;</span>;       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再加上标识</span></span><br><span class="line">    QString accessibleName = QString::<span class="built_in">fromLatin1</span>(prefix) + SEPARATOR;</span><br><span class="line">    QString objectName = w-&gt;<span class="built_in">objectName</span>().<span class="built_in">toLower</span>();</span><br><span class="line">    accessibleName += oldAccessName.<span class="built_in">isEmpty</span>() ? (objectName.<span class="built_in">isEmpty</span>() ?lowerFallback : objectName) : oldAccessName;</span><br><span class="line">    <span class="comment">// 检查名称是否唯一</span></span><br><span class="line">    <span class="keyword">if</span> (accessibleMap[r].<span class="built_in">contains</span>(accessibleName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!objnameMap.<span class="built_in">key</span>(accessibleName)) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(objnameMap.<span class="built_in">key</span>(accessibleName));</span><br><span class="line">            objnameMap.<span class="built_in">insert</span>(w, accessibleName);</span><br><span class="line">            <span class="keyword">return</span> accessibleName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取编号，然后+1</span></span><br><span class="line">        <span class="type">int</span> pos = accessibleName.<span class="built_in">indexOf</span>(SEPARATOR);</span><br><span class="line">        <span class="type">int</span> id = accessibleName.<span class="built_in">mid</span>(pos + <span class="number">1</span>).<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">        QString newAccessibleName;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 一直找到一个不重复的名字</span></span><br><span class="line">            newAccessibleName = accessibleName + SEPARATOR + QString::<span class="built_in">number</span>(++id);</span><br><span class="line">        &#125; <span class="keyword">while</span> (accessibleMap[r].<span class="built_in">contains</span>(newAccessibleName));</span><br><span class="line"></span><br><span class="line">        accessibleMap[r].<span class="built_in">append</span>(newAccessibleName);</span><br><span class="line">        objnameMap.<span class="built_in">insert</span>(w, newAccessibleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象销毁后移除占用名称</span></span><br><span class="line">        QObject::<span class="built_in">connect</span>(w, &amp;QWidget::destroyed, [ = ] (QObject *obj) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(obj);</span><br><span class="line">            accessibleMap[r].<span class="built_in">removeOne</span>(newAccessibleName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newAccessibleName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accessibleMap[r].<span class="built_in">append</span>(accessibleName);</span><br><span class="line">        objnameMap.<span class="built_in">insert</span>(w, accessibleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象销毁后移除占用名称</span></span><br><span class="line">        QObject::<span class="built_in">connect</span>(w, &amp;QWidget::destroyed, [ = ] (QObject *obj) &#123;</span><br><span class="line">            objnameMap.<span class="built_in">remove</span>(obj);</span><br><span class="line">            accessibleMap[r].<span class="built_in">removeOne</span>(accessibleName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> accessibleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accessible</span> : <span class="keyword">public</span> QAccessibleWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Accessible</span>(QWidget *parent, QAccessible::Role r, <span class="type">const</span> QString &amp;accessibleName)</span><br><span class="line">        : <span class="built_in">QAccessibleWidget</span>(parent, r)</span><br><span class="line">        , <span class="built_in">data</span>(<span class="built_in">qobject_cast</span>&lt;QWidget *&gt;(parent))</span><br><span class="line">        , <span class="built_in">accessibleName</span>(accessibleName)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于使用dogtail的AT自动化测试工作，实际上只需要使用我们提供的text方法获取控件唯一ID,，然后再通过QAccessibleWidget的rect方法找到其坐标，模拟点击即可</span></span><br><span class="line">    <span class="comment">// rect没必要重新实现，text方法通过getAccessibleName确定返回唯一值</span></span><br><span class="line">    <span class="function">QString <span class="title">text</span><span class="params">(QAccessible::Text t)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> QAccessible::Name:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getAccessibleName</span>(data, <span class="keyword">this</span>-&gt;<span class="built_in">role</span>(), accessibleName);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *data;</span><br><span class="line">    QString accessibleName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QAccessibleInterface *<span class="title">accessibleFactory</span><span class="params">(<span class="type">const</span> QString &amp;classname, QObject *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(classname);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> QMap&lt;QString, QAccessible::Role&gt; s_roleMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;MainWindow&quot;</span>,                      QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;MainPanelControl&quot;</span>,              QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;Dock::TipsWidget&quot;</span>,              QAccessible::Role::StaticText&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;DockPopupWindow&quot;</span>,               QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;LauncherItem&quot;</span>,                  QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;AppItem&quot;</span>,                       QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;PreviewContainer&quot;</span>,              QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;PluginsItem&quot;</span>,                   QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;TrayPluginItem&quot;</span>,                QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;PlaceholderItem&quot;</span>,               QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;AppDragWidget&quot;</span>,                 QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;AppSnapshot&quot;</span>,                   QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;FloatingPreview&quot;</span>,               QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;XEmbedTrayWidget&quot;</span>,              QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;IndicatorTrayWidget&quot;</span>,           QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;SNITrayWidget&quot;</span>,                 QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;AbstractTrayWidget&quot;</span>,            QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;SystemTrayItem&quot;</span>,                QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;FashionTrayItem&quot;</span>,               QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;FashionTrayWidgetWrapper&quot;</span>,      QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;FashionTrayControlWidget&quot;</span>,      QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;AttentionContainer&quot;</span>,            QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;HoldContainer&quot;</span>,                 QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;NormalContainer&quot;</span>,               QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;SpliterAnimated&quot;</span>,               QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;DatetimeWidget&quot;</span>,                QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;OnboardItem&quot;</span>,                   QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;TrashWidget&quot;</span>,                   QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;PopupControlWidget&quot;</span>,            QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;ShutdownWidget&quot;</span>,                QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;MultitaskingWidget&quot;</span>,            QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;ShowDesktopWidget&quot;</span>,             QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;OverlayWarningWidget&quot;</span>,          QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;QWidget&quot;</span>,                       QAccessible::Role::Form&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;QLabel&quot;</span>,                        QAccessible::Role::StaticText&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;Dtk::Widget::DIconButton&quot;</span>,      QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;Dtk::Widget::DSwitchButton&quot;</span>,    QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;DesktopWidget&quot;</span>,                 QAccessible::Role::Button&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;HorizontalSeperator&quot;</span>,           QAccessible::Role::Form&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> QMap&lt;QString, QString&gt; s_classNameMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Dock::TipsWidget&quot;</span>, <span class="string">&quot;tips&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;DatetimeWidget&quot;</span>,<span class="string">&quot;plugin-datetime&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;OnboardItem&quot;</span>,<span class="string">&quot;plugin-onboard&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;TrashWidget&quot;</span>,<span class="string">&quot;plugin-trash&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;ShutdownWidget&quot;</span>,<span class="string">&quot;plugin-shutdown&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;MultitaskingWidget&quot;</span>,<span class="string">&quot;plugin-multitasking&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;ShowDesktopWidget&quot;</span>,<span class="string">&quot;plugin-showdesktop&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;OverlayWarningWidget&quot;</span>,<span class="string">&quot;plugin-overlaywarningwidget&quot;</span>&#125;</span><br><span class="line">        , &#123;<span class="string">&quot;SoundItem&quot;</span>, <span class="string">&quot;plugin-sounditem&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;<span class="built_in">isWidgetType</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Accessible</span>(<span class="built_in">qobject_cast</span>&lt;QWidget *&gt;(object)</span><br><span class="line">                                       , s_roleMap.<span class="built_in">value</span>(classname, QAccessible::Role::Form)</span><br><span class="line">                                       , s_classNameMap.<span class="built_in">value</span>(object-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>(), object-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="4-2-启用自定义工厂函数"><a href="#4-2-启用自定义工厂函数" class="headerlink" title="4.2 启用自定义工厂函数"></a>4.2 启用自定义工厂函数</h2><p>然后在QApplication构建之后,添加如下代码即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accessible.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动化标记由此开始</span></span><br><span class="line">    QAccessible::<span class="built_in">installFactory</span>(accessibleFactory);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1 id="第五章-通过python实现AT自动化测试"><a href="#第五章-通过python实现AT自动化测试" class="headerlink" title="第五章 通过python实现AT自动化测试"></a>第五章 通过python实现AT自动化测试</h1><h2 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h2><p>ps:请确保您有一定的python基础.<br>安装dogtail模块<br><code>pip3 install dogtail</code></p>
<h2 id="5-2-获取应用的’可接入’名称"><a href="#5-2-获取应用的’可接入’名称" class="headerlink" title="5.2 获取应用的’可接入’名称"></a>5.2 获取应用的’可接入’名称</h2><p>通过sniff命令打开AT_SPI Browser程序，找到你要测试的进程，这里以dde-dock进程为例：<br><img    
                       lazyload
                       alt="image"
                       data-src="3.png"
                         style="zoom:50%;" 
                 ><br>选中dde-dock选项，在页面底部的Basic标签中，可以看到其Name为dde-dock,这也就是我们后续写AT测试脚本会用到的应用名。</p>
<h2 id="5-3-脚本实战"><a href="#5-3-脚本实战" class="headerlink" title="5.3 脚本实战"></a>5.3 脚本实战</h2><p>使用dogtail需要导入root<br><code>from dogtail.tree import root</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="comment"># This is a sample Python script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Press Shift+F10 to execute it or replace it with your code.</span></span><br><span class="line"><span class="comment"># Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dogtail.tree <span class="keyword">import</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;show or hide launcher by dde-dock&#x27;</span>)</span><br><span class="line">    root.application(<span class="string">&#x27;dde-dock&#x27;</span>).child(<span class="string">&#x27;Btn_launcheritem&#x27;</span>).click(button=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;open dde-control-center&#x27;</span>)</span><br><span class="line">    root.application(<span class="string">&#x27;dde-launcher&#x27;</span>).child(<span class="string">&#x27;Form_settingsbtn&#x27;</span>).click(button=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;jump to update&#x27;</span>)</span><br><span class="line">    dde_control_center=root.application(<span class="string">&#x27;dde-control-center&#x27;</span>)</span><br><span class="line">    dde_control_center.child(<span class="string">&#x27;Editable_searchmodulelineedit&#x27;</span>).click(button=<span class="number">1</span>)</span><br><span class="line">    dde_control_center.child(<span class="string">&#x27;Editable_searchmodulelineedit&#x27;</span>).typeText(<span class="string">&quot;电源&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># See PyCharm help at https://www.jetbrains.com/help/pycharm/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个简单的脚本,点击任务栏的启动器,打开启动器，然后点击启动器界面上的设置按钮，打开控制中心，在控制中心的搜索栏中输入”电源”两个字。</p>
<p>大致分三步：<br>1、获取应用对象：通过root的application方法获取到指定应用，获取失败则抛出异常(简化考虑，并未处理此种情况)<br>2、查找控件：通过child方法，传入控件的accessibleName即可标记到对应控件<br>3、执行操作：通过click方法，传入对应的点击类型(1、2、3分别代表鼠标的左、中、右键)。模拟鼠标点击的情况</p>
<p>注：使用Python专用IDE:PyCharm，可以很好的完成代码提示、编码格式、源码跳转、包管理等功能。网络上有免费的社区版本。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>分享交流之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://doc.qt.io/qt-6/qaccessible.html" >QAccessible Class<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://doc.qt.io/qt-6/qaccessibleinterface.html" >QAccessibleInterface Class<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://doc.qt.io/qt-6/accessible-qwidget.html" >Accessibility for QWidget Applications<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility" >What is accessibility<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>转载 --- C++ Template 进阶指南</title>
    <url>/2023/07743c2152.html</url>
    <content><![CDATA[<p><a class="link"   href="https://github.com/wuye9036/CppTemplateTutorial" >https://github.com/wuye9036/CppTemplateTutorial<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程规范-101条规则准则与最佳实践</title>
    <url>/2023/06b2749a02.html</url>
    <content><![CDATA[<h1 id="C-编程规范-101条规则准则与最佳实践"><a href="#C-编程规范-101条规则准则与最佳实践" class="headerlink" title="C++编程规范-101条规则准则与最佳实践"></a>C++编程规范-101条规则准则与最佳实践</h1><table>
<thead>
<tr>
<th>章</th>
<th>节</th>
</tr>
</thead>
<tbody><tr>
<td><strong>组织和策略问题</strong></td>
<td>0.不要拘泥于小节</td>
</tr>
<tr>
<td></td>
<td>1.在高警告级别干净利落地进行编译</td>
</tr>
<tr>
<td></td>
<td>2.使用自动构建系统</td>
</tr>
<tr>
<td></td>
<td>3. 使用版本控制系统</td>
</tr>
<tr>
<td></td>
<td>4. 在代码审查上投入</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>设计风格</strong></td>
<td>5. 一个实体应该只有一个紧凑的职责</td>
</tr>
<tr>
<td></td>
<td>6. 正确、简单和清晰第一</td>
</tr>
<tr>
<td></td>
<td>7. 编程中应知道何时和如何考虑可伸缩性</td>
</tr>
<tr>
<td></td>
<td>8. 不要进行不成熟的优化</td>
</tr>
<tr>
<td></td>
<td>9. 不要进行不成熟的劣化</td>
</tr>
<tr>
<td></td>
<td>10. 尽量减少全局和共享数据</td>
</tr>
<tr>
<td></td>
<td>11. 隐藏信息</td>
</tr>
<tr>
<td></td>
<td>12. 懂得何时和如何进行并发性编程</td>
</tr>
<tr>
<td></td>
<td>13. 确保资源为对象所拥有。使用显式的RAII和智能指针</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>编程风格</strong></td>
<td>14. 宁要编译时和连接时错误，也不要运行时错误</td>
</tr>
<tr>
<td></td>
<td>15. 积极使用const</td>
</tr>
<tr>
<td></td>
<td>16. 避免使用宏</td>
</tr>
<tr>
<td></td>
<td>17. 避免使用”魔数”</td>
</tr>
<tr>
<td></td>
<td>18. 尽可能局部地声明变量</td>
</tr>
<tr>
<td></td>
<td>19. 总是初始化变量</td>
</tr>
<tr>
<td></td>
<td>20. 避免函数过长，避免嵌套过深</td>
</tr>
<tr>
<td></td>
<td>21. 避免跨编译单元的初始化依赖</td>
</tr>
<tr>
<td></td>
<td>22. 尽量减少定义性依赖。避免循环依赖</td>
</tr>
<tr>
<td></td>
<td>23. 头文件应该自给自足</td>
</tr>
<tr>
<td></td>
<td>24. 总是编写内部#include保护符，绝不要编写外部#include保护符</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>函数与操作符</strong></td>
<td>25. 正确地选择通过值，(只能)指针或者引用传递参数</td>
</tr>
<tr>
<td></td>
<td>26. 保护重载操作符的自然语义</td>
</tr>
<tr>
<td></td>
<td>27. 优先使用算术操作符和赋值操作符的标准形式</td>
</tr>
<tr>
<td></td>
<td>28. 优先使用++和–的标准形式。优先调用前缀形式</td>
</tr>
<tr>
<td></td>
<td>29. 考虑重载以避免隐含类型转换</td>
</tr>
<tr>
<td></td>
<td>30. 避免重载&amp;&amp;，||或，(逗号)</td>
</tr>
<tr>
<td></td>
<td>31. 不要编写依赖于函数参数求值顺序的代码</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>类的设计和继承</strong></td>
<td>32. 弄清所要编写的是哪种类</td>
</tr>
<tr>
<td></td>
<td>33. 用小类代替巨类</td>
</tr>
<tr>
<td></td>
<td>34. 用组合代替继承</td>
</tr>
<tr>
<td></td>
<td>35. 避免从并非必要设计成基类的类中继承</td>
</tr>
<tr>
<td></td>
<td>36. 优先提供抽象接口</td>
</tr>
<tr>
<td></td>
<td>37. 公用继承即可替换性。继承，不是为了重用，而是为了被重用</td>
</tr>
<tr>
<td></td>
<td>38. 实施安全的改写</td>
</tr>
<tr>
<td></td>
<td>39. 考虑将虚拟函数声明成非公用的，将公用函数声明为非虚拟的</td>
</tr>
<tr>
<td></td>
<td>40. 要避免提供隐式转换</td>
</tr>
<tr>
<td></td>
<td>41. 将数据成员设为私有的，无行为的聚集(C语言形式的struct)除外</td>
</tr>
<tr>
<td></td>
<td>42. 不要公开内部数据</td>
</tr>
<tr>
<td></td>
<td>43. 明智地使用Pimpl</td>
</tr>
<tr>
<td></td>
<td>44. 优先编写非成员非友元函数</td>
</tr>
<tr>
<td></td>
<td>45. 总是一起提供new和delete</td>
</tr>
<tr>
<td></td>
<td>46. 如果提供类专门的new，应该提供所有的标准形式(普通，就地和不抛出)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>构造、析构和复制</strong></td>
<td>47. 以同样的顺序定义和初始化成员变量</td>
</tr>
<tr>
<td></td>
<td>48. 在构造函数中使用初始化代替赋值</td>
</tr>
<tr>
<td></td>
<td>49. 避免在构造函数和析构函数中调用虚拟函数</td>
</tr>
<tr>
<td></td>
<td>50. 将基类析构函数设为公共且虚拟的，或者保护且非虚拟的</td>
</tr>
<tr>
<td></td>
<td>51. 析构函数、释放和交换绝对不能失败</td>
</tr>
<tr>
<td></td>
<td>52. 一致地进行赋值和销毁</td>
</tr>
<tr>
<td></td>
<td>53. 显式地弃用或者禁止复制</td>
</tr>
<tr>
<td></td>
<td>54. 避免切片。在基类中考虑用克隆代替复制</td>
</tr>
<tr>
<td></td>
<td>55. 使用赋值的标准形式</td>
</tr>
<tr>
<td></td>
<td>56. 只要可行，就提供不会失败的swap(而且要正确地提供)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>命名空间与模块</strong></td>
<td>57. 将类型及其非成员函数接口置于同一名字空间中</td>
</tr>
<tr>
<td></td>
<td>58. 应该将类型和函数分别置于不同的名字空间中，除非有意想让它们一起工作</td>
</tr>
<tr>
<td></td>
<td>59. 不要在头文件中或者#include之前编写名字空间using</td>
</tr>
<tr>
<td></td>
<td>60. 要避免在不同的模块中分配和释放内存</td>
</tr>
<tr>
<td></td>
<td>61. 不要在头文件定义具有链接的实体</td>
</tr>
<tr>
<td></td>
<td>62. 不要允许异常跨越边界传播</td>
</tr>
<tr>
<td></td>
<td>63. 在模块的接口中使用具有良好可移植性的类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模板和泛型</strong></td>
<td>64. 理智地结合静态多态性和动态多态性</td>
</tr>
<tr>
<td></td>
<td>65. 有意地进行显式自定义</td>
</tr>
<tr>
<td></td>
<td>66. 不要特化函数模板</td>
</tr>
<tr>
<td></td>
<td>67. 不要无意地编写不通用的代码</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>错误处理与异常</strong></td>
<td>68. 广泛地使用断言记录内部假设和不变式</td>
</tr>
<tr>
<td></td>
<td>69. 建立合理的错误处理策略，并严格遵守</td>
</tr>
<tr>
<td></td>
<td>70. 区别错误和非错误</td>
</tr>
<tr>
<td></td>
<td>71. 设计和编写错误安全代码</td>
</tr>
<tr>
<td></td>
<td>72. 优先使用异常报告错误</td>
</tr>
<tr>
<td></td>
<td>73. 通过值抛出，通过引用捕获</td>
</tr>
<tr>
<td></td>
<td>74. 正确地报告、处理和转换错误</td>
</tr>
<tr>
<td></td>
<td>75. 避免使用异常规范</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>容器</strong></td>
<td>76. 默认时使用vector。否则，选择其他合适的容器</td>
</tr>
<tr>
<td></td>
<td>77. 同vector和string代替数组</td>
</tr>
<tr>
<td></td>
<td>78. 使用vector(和string::c_str())与非C++ API交换数据</td>
</tr>
<tr>
<td></td>
<td>79. 在容器中只存储值和智能指针</td>
</tr>
<tr>
<td></td>
<td>80. 用push_back代替其他扩展序列的方式</td>
</tr>
<tr>
<td></td>
<td>81. 多用范围操作，少用单元素操作</td>
</tr>
<tr>
<td></td>
<td>82. 使用公认的惯用法真正地压缩容量，真正地删除元素</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>算法</strong></td>
<td>83. 使用带检查的STL实现</td>
</tr>
<tr>
<td></td>
<td>84. 用算法调用代替手工编写的循环</td>
</tr>
<tr>
<td></td>
<td>85. 使用正确的STL查找算法</td>
</tr>
<tr>
<td></td>
<td>86. 使用正确的STL排序算法</td>
</tr>
<tr>
<td></td>
<td>87. 使谓词称为纯函数</td>
</tr>
<tr>
<td></td>
<td>88. 算法和比较器的参数应多用函数对象少用函数</td>
</tr>
<tr>
<td></td>
<td>89. 正确编写函数对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td>90. 避免使用类型分支，多使用多态</td>
</tr>
<tr>
<td></td>
<td>91. 依赖类型，而非其表示方式</td>
</tr>
<tr>
<td></td>
<td>92. 避免使用reinterpret_cast</td>
</tr>
<tr>
<td></td>
<td>93. 避免对指针使用static_cast</td>
</tr>
<tr>
<td></td>
<td>94. 避免强制转换const</td>
</tr>
<tr>
<td></td>
<td>95. 不要使用C风格的强制转换</td>
</tr>
<tr>
<td></td>
<td>96. 不要对非POD进行memcpy操作和memcmp操作</td>
</tr>
<tr>
<td></td>
<td>97. 不要使用联合重新解释表示方式</td>
</tr>
<tr>
<td></td>
<td>98. 不要使用可变长参数(…)</td>
</tr>
<tr>
<td></td>
<td>99. 不要使用失效对象。不要使用不安全函数</td>
</tr>
<tr>
<td></td>
<td>100. 不要多态地处理数组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Desktop Application Autostart Specification(桌面应用程序自动启动规范)</title>
    <url>/2023/0489b0afa0.html</url>
    <content><![CDATA[<p>原文链接： <a class="link"   href="https://specifications.freedesktop.org/autostart-spec/autostart-spec-0.5.html" >https://specifications.freedesktop.org/autostart-spec/autostart-spec-0.5.html<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>该文档(草稿)定义了一种在桌面环境启动期间和安装可移动介质后自动启动应用程序的方法。</p>
<p>本规范中的一些文件位置是根据 <a class="link"   href="http://standards.freedesktop.org/basedir-spec/" >“桌面基本目录规范”<i class="fas fa-external-link-alt"></i></a>指定的。</p>
<span id="more"></span>

<h1 id="启动期间自动启动应用程序"><a href="#启动期间自动启动应用程序" class="headerlink" title="启动期间自动启动应用程序"></a>启动期间自动启动应用程序</h1><p>通过将应用程序的 .desktop 文件放置在自动启动目录之一中，应用程序将在用户登录后在用户桌面环境启动期间自动启动。</p>
<h2 id="自动启动目录"><a href="#自动启动目录" class="headerlink" title="自动启动目录"></a>自动启动目录</h2><p>自动启动目录是 $XDG_CONFIG_DIRS&#x2F;autostart，根据 <a class="link"   href="http://standards.freedesktop.org/basedir-spec/" >“桌面基本目录规范”<i class="fas fa-external-link-alt"></i></a>中的 <a class="link"   href="http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html#referencing" >“引用此规范”<i class="fas fa-external-link-alt"></i></a>部分定义。</p>
<p>如果相同的文件名位于多个自动启动目录下，则应仅使用最重要(优先级最高)目录下的文件。</p>
<p>示例：如果未设置 $XDG_CONFIG_HOME，则用户主目录中的自动启动目录为 ~&#x2F;.config&#x2F;autostart&#x2F;</p>
<p>示例：如果未设置 $XDG_CONFIG_DIRS，则系统范围的自动启动目录为 &#x2F;etc&#x2F;xdg&#x2F;autostart&#x2F;</p>
<p>示例：如果未设置 $XDG_CONFIG_HOME 和 $XDG_CONFIG_DIRS，并且存在 &#x2F;etc&#x2F;xdg&#x2F;autostart&#x2F;foo.desktop 和 ~&#x2F;.config&#x2F;autostart&#x2F;foo.desktop 这两个文件，则只有文件 ~&#x2F;.config&#x2F;autostart&#x2F;foo。 desktop 将被使用，因为 ~&#x2F;.config&#x2F;autostart&#x2F; 比 &#x2F;etc&#x2F;xdg&#x2F;autostart&#x2F; 目录优先级更高</p>
<h2 id="应用程序-desktop-文件"><a href="#应用程序-desktop-文件" class="headerlink" title="应用程序 .desktop 文件"></a>应用程序 .desktop 文件</h2><p>应用程序 .desktop 文件必须具有<a class="link"   href="http://standards.freedesktop.org/desktop-entry-spec/" >“桌面条目规范”<i class="fas fa-external-link-alt"></i></a> 中定义的格式。所有键都应按定义解释，但有以下例外情况，以考虑到自动启动目录中的 .desktop 文件未显示在菜单中。</p>
<h2 id="Hidden-Key"><a href="#Hidden-Key" class="headerlink" title="Hidden Key"></a>Hidden Key</h2><p>当 .desktop 文件的 Hidden 键设置为 true 时，<strong>必须忽略</strong> .desktop 文件。当多个目录中存在多个同名的 .desktop 文件时，则必须仅考虑最重要的(优先级最高的) .desktop 文件中的Hidden值：如果将其设置为 true，则<strong>必须忽略</strong>其他目录中所有同名的 .desktop 文件。</p>
<h2 id="OnlyShowIn-and-NotShowIn-Keys"><a href="#OnlyShowIn-and-NotShowIn-Keys" class="headerlink" title="OnlyShowIn and NotShowIn Keys"></a>OnlyShowIn and NotShowIn Keys</h2><p>OnlyShowIn 条目可能包含一个字符串列表，用于标识<strong>必须自动启动</strong>此应用程序的桌面环境，所有其他桌面环境<strong>不得自动启动</strong>此应用程序。</p>
<p>NotShowIn 条目可能包含一个字符串列表，用于标识<strong>不得自动启动</strong>此应用程序的桌面环境，所有其他桌面环境<strong>必须自动启动</strong>此应用程序。</p>
<p>这些键中只有一个（OnlyShowIn 或 NotShowIn）可能出现在单个 .desktop 文件中。</p>
<h2 id="TryExec-Key"><a href="#TryExec-Key" class="headerlink" title="TryExec Key"></a>TryExec Key</h2><p>如果 TryExec 的值与已安装的可执行程序不匹配，则<strong>不得自动启动</strong>具有非空 TryExec 字段的 .desktop 文件。TryExec 字段的值可以是绝对路径或不带任何路径组件的可执行文件的名称。如果指定的可执行文件的名称没有任何路径组件，则搜索 $PATH 环境以查找匹配的可执行程序。</p>
<h2 id="实施说明"><a href="#实施说明" class="headerlink" title="实施说明"></a>实施说明</h2><p>如果应用程序通过在系统范围的自动启动目录中安装 .desktop 文件来自动启动，则个人用户可以通过在其个人自动启动目录中（优先级更高）放置一个同名的 .desktop 文件来禁用该应用程序的自动启动，该目录中 . desktop 文件需要包含 Hidden&#x3D;true。</p>
<h1 id="安装后自动启动应用程序"><a href="#安装后自动启动应用程序" class="headerlink" title="安装后自动启动应用程序"></a>安装后自动启动应用程序</h1><p>当桌面环境安装新介质时，该介质可能包含一份建议启动应用程序的自动启动文件或建议打开位于介质上的特定文件的自动打开文件。</p>
<h2 id="自动启动文件"><a href="#自动启动文件" class="headerlink" title="自动启动文件"></a>自动启动文件</h2><p>安装新媒体时，应按优先顺序检查媒体的根目录中是否有以下自动启动文件：.autorun、autorun、autorun.sh 仅应考虑存在的第一个文件。</p>
<p>桌面环境可以根据用户、系统管理员或供应商设置的策略完全忽略自动启动文件。</p>
<p>桌面环境必须在自动启动应用程序之前提示用户进行确认。</p>
<p>当检测到自动启动文件并且用户已确认其执行时，必须将当前工作目录 (CWD) 设置为介质的根目录来执行自动启动文件。</p>
<h2 id="自动打开文件"><a href="#自动打开文件" class="headerlink" title="自动打开文件"></a>自动打开文件</h2><p>当安装了新媒体并且 </p>
<p>a) 媒体不包含自动启动文件</p>
<p>或 </p>
<p>b) 忽略自动启动文件的策略生效时，</p>
<p>应按优先顺序检查媒体的根目录中是否有以下自动打开文件：.autoopen , autoopen。只应考虑存在的第一个文件。</p>
<p>桌面环境可以根据用户、系统管理员或供应商设置的策略完全忽略 Autoopen 文件。</p>
<p>Autoopen 文件<strong>必须</strong>包含指向介质上包含的不可执行文件的单个相对路径。如果文件包含换行符或回车符，则<strong>必须</strong>忽略换行符或回车符本身以及后面的所有字符。</p>
<p>相对路径<strong>不得包含</strong>引用父目录 (..&#x2F;) 的路径组件</p>
<p>相对路径<strong>不得指向</strong>可执行文件。</p>
<p>桌面环境<strong>必须验证</strong>相对路径指向实际位于媒体上的文件，考虑到任何符号或其他链接，并且必须忽略指向媒体本身之外的文件位置的任何相对路径。</p>
<p>如果相对路径指向可执行文件，则桌面环境<strong>不得执行</strong>该文件。</p>
<p>桌面环境<strong>必须</strong>在打开文件之前<strong>提示</strong>用户进行确认。</p>
<p>当检测到 Autoopen 文件并且用户确认应该打开 Autoopen 文件中指示的文件时，<strong>必须</strong>在用户通常首选的应用程序中(默认应用程序)打开 Autoopen 文件中指示的文件，<strong>除非</strong>用户另有指示。</p>
]]></content>
      <categories>
        <category>Freedesktop</category>
      </categories>
      <tags>
        <tag>AutoStart</tag>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>Desktop Entry Specification(桌面入口规范)</title>
    <url>/2023/0555944369.html</url>
    <content><![CDATA[<p>原文链接：<a class="link"   href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html" >https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>注：部分内容并未翻译，实则是感觉没（不）必（想）要（写），感兴趣的童鞋可以访问原文链接。</p>
</blockquote>
<h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><p>implementations:实现者，本文中的实现方一般指桌面环境的发行商，此规范的实现者</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>KDE和GNOME桌面环境都采用了类似的 <em>desktop entries</em> 格式或描述特定程序如何启动的配置文件。为了更好地造福社区，桌面环境各方都应达成统一标准，以便两个桌面环境之间以及任何实现规范的其他环境之间的互操作，都能变得更加简单。(鹰酱教我们的标准化)</p>
<h1 id="基础格式"><a href="#基础格式" class="headerlink" title="基础格式"></a>基础格式</h1><p><em>Desktop entry</em> 文件应具有 <em>.desktop</em> 扩展名， <em>Directory</em> 类型的文件应具有 <em>.directory</em> 扩展名。根据扩展名确定文件类型使得确定文件类型非常容易和快速。当没有文件扩展名时，桌面系统应该 <em>fallback</em> 到通过 <em><strong>magic detection</strong></em> (指各家桌面环境独特的检测方式) 识别。</p>
<p>对于应用程序，桌面文件名称的一部分（*.desktop* 之前）应遵循 <em><strong>reverse DNS</strong></em> （域名反向原则，其实就是把域名反过来写）约定，例如 <em>org.example.FooViewer.desktop</em>。</p>
<p><em>Desktop entry</em> 文件以 <em>UTF-8</em> 编码。文件被解释为一系列由换行符分隔的行。且内容是<strong>大小写敏感</strong>的。</p>
<p>为了保持兼容，规范的实现方<strong>不得</strong>从文件中<strong>删除任何字段</strong>，即使实现方不支持这些字段。这些字段必须提供一个维护列表，如果文件被“重写”，它们将被重新包含在内。这确保即使另一个系统访问和更改文件，任何特定于桌面的扩展也将被保留。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以 <em>#</em> 开头的行和空行被视为注释，将被忽略，但在 <em>Desktop entry</em> 文件的读写过程中应保留它们。</p>
<p>注释行不会被规范实现方所解释，可以包含任何字符（ <em>LF</em> 除外）。但是，鼓励使用 <em>UTF-8</em> (但不建议包含非 <em>ASCII</em> 字符)进行注释。</p>
<h1 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h1><p>名为 <em>groupname</em>  的组标题的格式如下：<br><code>[groupname]</code></p>
<p>组名可以包含除  [<em>and</em>] 和控制字符之外的所有 <em>ASCII</em> 字符</p>
<p>多个组可能不具有相同的名称(实际上我认为是一定不会相同，但是规范写的是 <em>may not have the same name</em>, emmm…)</p>
<p><em>Group Header</em> 之后的所有 <em>{key,value}</em> 键值对都属于该组，直到遇见一个新的 <em>Group Header</em></p>
<p><em>Desktop entry</em> 文件的基本格式要求有一个名为 <code>[Desktop Entry]</code> 的组头。 文件中可能存在其他组，但这是明确需要支持的最重要的组。 该组还应该用作自动          <em>MIME</em> 类型检测的 <em>“magic key”</em>。 在 <em>Desktop entry</em> 文件中，该组之前不应有任何内容，但可能有一个或多个注释。</p>
<h1 id="Entries"><a href="#Entries" class="headerlink" title="Entries"></a>Entries</h1><p>文件中的 <em>entry</em> 是 形如 <em>{key,value}</em> 的键值对 ，格式如下：<br><code>Key=Value</code><br>应忽略等号前后的空格, “&#x3D;” 符号是实际的分隔符</p>
<p> <em>Key</em> 只能使用字符 <em>A-Za-z0-9</em></p>
<p>由于大小写很重要， <em>Name</em> 和 <em>NAME</em> 作为 <em>Key</em>并不等同</p>
<p>同一 <em>Group</em> 中的多个 <em>Key</em> 可能具有不同的名称( <em>emmm…</em> , 我觉得应该去掉可能两个字)。不同 <em>Group</em> 中的 <em>Key</em> 可能具有相同的名称</p>
<h1 id="支持的值类型"><a href="#支持的值类型" class="headerlink" title="支持的值类型"></a>支持的值类型</h1><p>公认的 <em>Value</em> 的类型有：<em>string, localestring, boolean, numeric</em>.</p>
<blockquote>
<p><em>string</em>: 字符串类型的值可以包含除控制字符之外的所有 <em>ASCII</em> 字符。<br><em>localestring</em>: localestring 类型的值是用户可显示的，并以 <em>UTF-8</em> 编码。<br><em>boolean</em>: 布尔类型的值必须是字符串 <em>true</em> 或 <em>false</em><br><em>numeric</em>: 数字类型的值必须是 <em>C</em> 语言环境中 <em>scanf</em> 的 *%f *说明符所识别的有效浮点数。</p>
</blockquote>
<p><em>string</em> 和 <em>localestring</em> 类型的值支持转义序列 <em>\s、\n、\t、\r</em> 和 <em>\</em>，分别表示 <em>ASCII</em> 空格、换行符、制表符、回车符和反斜杠。</p>
<p>一些键可以有多个值。 在这种情况下，键的值被指定为复数：例如，*string(s)*。 多个值应该用分号分隔，键的值可以选择以分号结尾。 尾随的空字符串必须始终以分号结尾。 这些值中的分号需要使用 <em>\</em>; 进行转义。</p>
<h1 id="公认的桌面入口Key"><a href="#公认的桌面入口Key" class="headerlink" title="公认的桌面入口Key"></a>公认的桌面入口Key</h1><p><em>Key</em> 有可选和必需两种可能。如果一个 <em>Key</em> 是可选的，它可能存在于文件中也可能不存在。然而，如果不是，标准的实现者不应该视为异常情况，它必须提供一些合理的默认值(即可选的 <em>Key</em> 不存在时，由规范实现者提供合理的默认值)。</p>
<p>有些 <em>Key</em> 只有在另一个特定 <em>Key</em> 也存在并设置为特定值时才在上下文中有意义。如果特定 <em>Key</em> 不存在或未设置为特定值，则不应使用这些 <em>Key</em> 。例如，<em>Terminal</em> 只有在 <em>Type</em> 的值为 <em>Application</em> 时才能使用。</p>
<p>如果一个必须存在的 <em>Key</em> 仅在另一个 <em>Key</em> 设置为特定值的上下文中有效，则仅当另一个 <em>Key</em> 设置为特定值时它才必须存在。例如，当且仅当 <em>Type</em> 的值为 <em>Link</em> 时，<em>URL</em> 必须存在。</p>
<p>一些示例的 <em>Key</em> ：<code>Name[C]、Comment[it]</code></p>
<h2 id="标准的-Keys"><a href="#标准的-Keys" class="headerlink" title="标准的 Keys"></a>标准的 Keys</h2><table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Value Type</th>
<th>Required?</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>本规范定义了 3 种类型的桌面条目：应用程序（类型 1）、链接（类型 2）和目录（类型 3）。为了允许在未来添加新类型，实现应该忽略具有未知类型的桌面条目。</td>
<td>string</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>Version</td>
<td>桌面条目符合的桌面条目规范的版本。确认此版本规范的条目应使用 1.0。请注意，版本字段不一定需要存在。</td>
<td>string</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>Name</td>
<td>应用程序的特定名称，例如 “<em>Mozilla</em>” 。</td>
<td>localestring</td>
<td>YES</td>
<td>1-3</td>
</tr>
<tr>
<td>GenericName</td>
<td>应用程序的通用名称，例如 “<em>Web Browser</em>” 。</td>
<td>localestring</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>NoDisplay</td>
<td><em>NoDisplay</em> 表示“此应用程序存在，但不在菜单中显示它”。这可能对例如将此应用程序与 MIME 类型相关联，以便它可以从文件管理器（或其他应用程序）启动，而无需为其提供菜单项（有很多类似的场景，例如 <em>netscape -remote</em> 或 <em>kfmclient openURL</em> 类型的操作）。</td>
<td>boolean</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>Comment</td>
<td>条目的工具提示，例如“查看 <em>Internet</em> 上的站点”。该值不应与 <em>Name</em> 和 <em>GenericName</em> 的值重复。</td>
<td>localestring</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>Icon</td>
<td>在文件管理器、菜单等中显示的图标。如果名称是绝对路径，将使用给定的文件。如果名称不是绝对路径，则将使用图标主题规范中描述的算法来定位图标。</td>
<td>localestring</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>Hidden</td>
<td>隐藏应该被称为删除。 这意味着用户删除了（在他的级别）存在的东西（在上层，例如在系统目录中）。 就该用户而言，它等同于根本不存在的 <em>.desktop</em> 文件。 这也可以用于“卸载”现有文件（例如由于重命名） - 通过让 <em>make install</em> 安装一个 <em>Hidden&#x3D;true</em> 的文件。</td>
<td>boolean</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>OnlyShowIn<code>, </code>NotShowIn</td>
<td>标识应显示&#x2F;不显示给定桌面条目的环境的字符串列表。 这些键中只有一个，即 <em>OnlyShowIn</em> 或 <em>NotShowIn</em>，可能会出现在一个组中（有关可能的值，请参阅<a class="link"   href="http://www.freedesktop.org/Standards/menu-spec" >Desktop Menu Specification<i class="fas fa-external-link-alt"></i></a>）。</td>
<td>string(s)</td>
<td>NO</td>
<td>1-3</td>
</tr>
<tr>
<td>DBusActivatable</td>
<td>一个布尔值，指定此应用程序是否支持 <em>D-Bus</em> 激活。 如果缺少此键，则默认值为  <em>false</em>。 如果该值为真，则实现应忽略 <em>Exec</em> 键并发送 <em>D-Bus</em> 消息以启动应用程序。 有关其工作原理的更多信息，请参见 <a class="link"   href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html#dbus" >D-Bus Activation<i class="fas fa-external-link-alt"></i></a>。 应用程序仍应在其桌面文件中包含 <em>Exec&#x3D;</em> 行，从而与不支持 <em>DBusActivatable</em> 字段的桌面环境兼容。</td>
<td>boolean</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>TryExec</td>
<td>磁盘上用于确定程序是否实际安装的可执行文件的路径。 如果路径不是绝对路径，则在 <em>$PATH</em> 环境变量中查找该文件。 如果该文件不存在或不可执行，则可以忽略该条目（例如，在菜单中隐藏）。</td>
<td>string</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Exec</td>
<td>要执行的程序，可能带有参数。 有关此键如何工作的详细信息，请参阅 <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html#exec-variables"><code>Exec</code> key</a>。 如果 <em>DBusActivatable</em> 未设置为 <em>true</em>，则需要 <em>Exec</em> 的键。 即使 <em>DBusActivatable</em> 为真，也应该指定 <em>Exec</em> ，从而与不支持 <em>DBusActivatable</em> 字段的桌面环境兼容。。</td>
<td>string</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Path</td>
<td>如果条目是应用程序类型，则为运行程序的工作目录。</td>
<td>string</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Terminal</td>
<td>程序是否在终端窗口中运行。</td>
<td>boolean</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Actions</td>
<td>应用程序操作的标识符。 这可用于告诉应用程序执行不同于默认行为的特定操作。 <a class="link"   href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html#extra-actions" >Application actions<i class="fas fa-external-link-alt"></i></a> 部分描述了操作的工作原理。</td>
<td>string(s)</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>MimeType</td>
<td>此应用程序支持的 <em>MIME</em> 类型。</td>
<td>string(s)</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Categories</td>
<td>条目应显示在菜单中的类别（有关可能的值，请参阅<a class="link"   href="http://www.freedesktop.org/Standards/menu-spec" >Desktop Menu Specification<i class="fas fa-external-link-alt"></i></a>）。</td>
<td>string(s)</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>Keywords</td>
<td>除了其他元数据之外，还可以使用的字符串列表来描述此条目。这可能很有用，例如方便便于条目搜索功能。这些值不用于显示，不应与 <em>Name</em> 或 <em>GenericName</em> 的值重复。</td>
<td>localestring(s)</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>StartupNotify</td>
<td>如果为真，则已知应用程序在使用 <em>DESKTOP_STARTUP_ID</em> 环境变量集启动时将发送“删除”消息。 如果为 <em>false</em>，则已知该应用程序根本无法使用启动通知（不显示任何窗口，即使在使用 <em>StartupWMClass</em> 时也会中断等）。 如果不存在，则合理的处理取决于实现（假设为 <em>false</em>，使用 <em>StartupWMClass</em> 等）。 （有关详细信息，请参阅启动通知协议规范）。</td>
<td>boolean</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>StartupWMClass</td>
<td>如果指定，则已知应用程序将至少映射一个具有给定字符串的窗口作为其 <em>WM</em> 类或 <em>WM</em> 名称提示（有关更多详细信息，请参阅<a class="link"   href="http://www.freedesktop.org/Standards/startup-notification-spec" >Startup Notification Protocol Specification<i class="fas fa-external-link-alt"></i></a>）。</td>
<td>string</td>
<td>NO</td>
<td>1</td>
</tr>
<tr>
<td>URL</td>
<td>如果条目是链接类型，则为要访问的 <em>URL</em>。</td>
<td>string</td>
<td>YES</td>
<td>2</td>
</tr>
</tbody></table>
<h1 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h1><p><em>Exec Key</em> 的值中必须包含命令行。命令行由一个可执行程序组成，后跟一个或多个参数（可选地）。可执行程序可以用其指定完整路径，也可以只用可执行文件的名称指定。如果未提供完整路径，则在桌面环境使用的 <em>$PATH</em> 环境变量中查找可执行文件。可执行程序的名称或路径不能包含等号 “&#x3D;”。参数由空格分隔。</p>
<p>参数可以完整引用。如果参数包含保留字符，则必须引用该参数。引用参数的规则也适用于提供的可执行程序名称或路径。</p>
<p>引用必须通过将参数括在双引号和转义双引号字符、反引号字符 (“`“)、美元符号 (“$”) 和反斜杠字符 (“\“) 之间来完成，方法是在其前面加上一个额外的反斜杠字符。规范实现者必须在扩展字段代码之前和将参数传递给可执行程序之前撤消引用。保留字符有空格（” “）、制表符、换行符、双引号、单引号（*’*）、反斜杠（”\“）、大于号（”&gt;”）、小于号（”&lt;” )、波浪号 (“~”)、竖线 (“|”)、和号 (“&amp;”)、分号 (“;”)、美元符号 (“$”)、星号 (“*”)、问号 (“ ？”）、井号（“#”）、括号（“（”）和（”）”）和反引号（“&#96;”）。</p>
<p>请注意，字符串类型值的一般转义规则规定反斜杠字符也可以转义为 (“\“)，并且此转义规则在引号规则之前应用。因此，要在桌面条目文件的引用参数中明确表示文字反斜杠字符，需要使用四个连续的反斜杠字符（“\\”）。同样，桌面条目文件中引用参数中的文字美元符号明确表示为 (“\$”)。</p>
<p>定义了许多特殊字段代码，当在命令行中遇到这些代码时，文件管理器或程序启动器将对其进行扩展。字段代码由百分比字符 (“%”) 和后跟字母字符组成。文字百分比字符必须转义为%%. 应从命令行中删除并忽略不推荐使用的字段代码。字段代码仅展开一次，用于替换字段代码的字符串不应检查字段代码本身。</p>
<p>包含未在本规范中列出的域代码的命令行是无效的，不得处理，特别是实现可能不会引入对本规范中未列出的域代码的支持。扩展（如果有）应通过新密钥引入。</p>
<p>除非本规范明确指示，否则实现必须注意不要将字段代码扩展为多个参数。这意味着名称字段、文件名和其他可以包含空格的替换必须在扩展后作为单个参数传递给可执行程序。</p>
<p>尽管 <em>Exec</em> 键被定义为具有字符串类型的值，该值仅限于 <em>ASCII</em> 字符，但字段代码扩展可能会在参数中引入非 <em>ASCII</em> 字符。实现必须注意传递给可执行程序的参数中的所有字符都根据适用的区域设置进行了正确编码。</p>
<p>公认的字段代码如下所示：</p>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>%f</td>
<td>单个文件名，即使选择了多个文件。读取桌面条目的系统应该认识到程序可能不能处理多个文件参数，如果程序不能处理额外的文件参数，它应该可能为每个选定的文件生成并执行程序的多个副本。对于不理解 URL 语法的程序，如果文件不在本地文件系统上（即在 HTTP 或 FTP 位置上），文件将被规范实现方复制到本地文件系统并将<code>%f</code>扩展为指向临时文件。</td>
</tr>
<tr>
<td>%F</td>
<td>文件列表。用于可以一次打开多个本地文件的应用程序。每个文件都作为单独的参数传递给可执行程序。</td>
</tr>
<tr>
<td>%u</td>
<td>单个网址。本地文件可以作为 file: URL 或文件路径传递。</td>
</tr>
<tr>
<td>%U</td>
<td>URL 列表。每个 URL 都作为单独的参数传递给可执行程序。本地文件可以作为 file: URL 或文件路径传递。</td>
</tr>
<tr>
<td>%d</td>
<td>已弃用。</td>
</tr>
<tr>
<td>%D</td>
<td>已弃用。</td>
</tr>
<tr>
<td>%n</td>
<td>已弃用。</td>
</tr>
<tr>
<td>%N</td>
<td>已弃用。</td>
</tr>
<tr>
<td>%i</td>
<td><code>Icon</code>桌面条目的键扩展为两个参数，第一个是 键<code>--icon</code>的值，然后是键的值 <code>Icon</code>。<code>Icon</code>如果键为空或缺失， 则不应扩展为任何参数。</td>
</tr>
<tr>
<td>%c</td>
<td><code>Name</code>桌面条目中 相应键中列出的应用程序的翻译名称。</td>
</tr>
<tr>
<td>%k</td>
<td>桌面文件的位置作为 URI（例如，如果从 vfolder 系统获取）或本地文件名，如果不知道位置则为空。</td>
</tr>
<tr>
<td>%v</td>
<td>已弃用。</td>
</tr>
<tr>
<td>%m</td>
<td>已弃用。</td>
</tr>
</tbody></table>
<p>命令行最多可以包含一个 <em>%f</em>、*%u<em>、</em>%F* 或 <em>%U</em> 字段代码。如果应用程序不应打开任何文件，则必须从命令行中删除并忽略 <em>%f</em>、*%u<em>、</em>%F* 和 <em>%U</em> 字段代码。</p>
<p>字段代码不得在引用参数中使用，引用参数中字段代码扩展的结果是未定义的。 <em>%F</em> 和 <em>%U</em> 字段代码只能用作它们自己的参数。</p>
<h1 id="通过-D-Bus-启动"><a href="#通过-D-Bus-启动" class="headerlink" title="通过 D-Bus 启动"></a>通过 D-Bus 启动</h1><p>支持由 <em>D-Bus</em> 启动的应用程序必须实现以下接口（以 <em>D-Bus</em> 自省 <em>XML</em> 格式给出）：<br><code>  &lt;interface name=&#39;org.freedesktop.Application&#39;&gt;     &lt;method name=&#39;Activate&#39;&gt;       &lt;arg type=&#39;a&#123;sv&#125;&#39; name=&#39;platform_data&#39; direction=&#39;in&#39;/&gt;     &lt;/method&gt;     &lt;method name=&#39;Open&#39;&gt;       &lt;arg type=&#39;as&#39; name=&#39;uris&#39; direction=&#39;in&#39;/&gt;       &lt;arg type=&#39;a&#123;sv&#125;&#39; name=&#39;platform_data&#39; direction=&#39;in&#39;/&gt;     &lt;/method&gt;     &lt;method name=&#39;ActivateAction&#39;&gt;       &lt;arg type=&#39;s&#39; name=&#39;action_name&#39; direction=&#39;in&#39;/&gt;       &lt;arg type=&#39;av&#39; name=&#39;parameter&#39; direction=&#39;in&#39;/&gt;       &lt;arg type=&#39;a&#123;sv&#125;&#39; name=&#39;platform_data&#39; direction=&#39;in&#39;/&gt;     &lt;/method&gt;   &lt;/interface&gt;</code></p>
<p>应用程序必须按照介绍部分中的命名建议命名其桌面文件（例如，文件名必须类似于<code>org.example.FooViewer.desktop</code>）。应用程序必须具有可激活的 <em>D-Bus</em> 服务，其众所周知的名称等于桌面文件名删除<code>.desktop</code>部分（对于我们的示例， <code>org.example.FooViewer</code>）。上述接口必须在如下确定的对象路径中实现：以应用程序众所周知的 <em>D-Bus</em> 名称开头，将所有点更改为斜杠并在斜杠前添加前缀。对于我们的示例，这是<code>/org/example/FooViewer</code>.</p>
<p><code>Activate</code>当应用程序启动时没有要打开的文件时调用 该方法。</p>
<p><code>Open</code>当使用文件启动应用程序时调用该方法。字符串数组是一个 <em>URI</em> 数组，采用 <em>UTF-8</em> 格式。</p>
<p><a class="link"   href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html#extra-actions" >当桌面操作<i class="fas fa-external-link-alt"></i></a><code>ActivateAction</code>被激活时调用 该方法。参数是动作的名称。 <code>action-name</code></p>
<p>所有方法都采用一个<code>platform-data</code>参数，该参数的使用方式与环境变量的使用方式类似。目前，规范只定义了一个字段： <code>desktop-startup-id</code>. 这应该是一个字符串，其值与存储在环境变量中的值相同<code>DESKTOP_STARTUP_ID</code>，如<a class="link"   href="http://www.freedesktop.org/Standards/startup-notification-spec" >启动通知协议规范<i class="fas fa-external-link-alt"></i></a>所指定。</p>
<h1 id="注册-MIME-类型"><a href="#注册-MIME-类型" class="headerlink" title="注册 MIME 类型"></a>注册 MIME 类型</h1><p><em>MimeType Key</em> 用于告知用户应用程序可以处理哪些 <em>MIME</em> 类型.一些应用的 <em>MimeType</em> 内容可能会非常长。应用程序应该能够使用 <em>Exec</em> 键中列出的命令合理地打开这些类型的文件。</p>
<p>此字段中的 <em>MIME</em> 类型不应有优先级，桌面文件中不应有任何形式的优先级。应用程序的优先级在 <em>.desktop</em> 文件之外处理。</p>
<h1 id="应用的其他动作"><a href="#应用的其他动作" class="headerlink" title="应用的其他动作"></a>应用的其他动作</h1><p>应用程序类型的桌面条目可以包括一个或多个操作。动作表示调用应用程序的另一种方式。应用程序启动器应该在应用程序的上下文中向用户公开它们（例如，作为子菜单）。这用于构建所谓的 <em>“Quicklists”</em> 或 <em>“Jumplists”</em> 。</p>
<h2 id="动作标识符"><a href="#动作标识符" class="headerlink" title="动作标识符"></a>动作标识符</h2><p>每个动作都由一个字符串标识，遵循与键名相同的格式（see the section called<a class="link"   href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html#entries" > “Entries”<i class="fas fa-external-link-alt"></i></a>）。每个标识符都与一个必须存在于 <em>.desktop</em> 文件中的操作组相关联。操作组是一个名为 <em>Desktop Action %s</em> 的组，其中 <em>%s</em> 是操作标识符。</p>
<p>为 <em>Actions</em> 键中未提及的操作标识符设置操作组是无效的。规范实现者必须忽略这样的 <em>Action</em> 组。</p>
<h2 id="Action-的-Key"><a href="#Action-的-Key" class="headerlink" title="Action 的 Key"></a>Action 的 Key</h2><p>每个操作组都支持以下键。如果 一个 <em>REQUIRED</em> 的键不存在于 <em>Action Group</em> 中，则规范实现者应忽略此操作。</p>
<p><em>Action</em> 的特定 <em>Key</em></p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Value Type</th>
<th>REQUIRED</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>用于显示给用户查看的一个标签。由于该操作始终显示在特定应用程序的上下文中（即，作为启动器的子菜单），因此这只需要在一个应用程序中是明确的即可，不应包含应用程序名称。</td>
<td>localestring</td>
<td>YES</td>
</tr>
<tr>
<td>Icon</td>
<td>与 <em>Action</em> 一起显示的图标。如果名称是绝对路径，将使用给定的文件。如果名称不是绝对路径，则将使用图标主题规范中描述的算法来定位图标。实现可能会选择忽略它。</td>
<td>localestring</td>
<td>NO</td>
</tr>
<tr>
<td>Exec</td>
<td>此操作要执行的程序命令，可能带有参数。有关此键如何工作的详细信息，请参阅 <em>Exec</em> 章节。如果 <em>desktop entry group</em> 组中的 <em>DBusActivatable</em> 未设置为 <em>true</em>，则需要 <em>Exec</em> 键。即使 <em>DBusActivatable</em> 为真，也应该指定 <em>Exec</em> 的内容，从而与未对 <em>DBusActivatable</em> 字段进行实现的桌面环境兼容。</td>
<td>string</td>
<td>NO</td>
</tr>
</tbody></table>
<h1 id="实现提示"><a href="#实现提示" class="headerlink" title="实现提示"></a>实现提示</h1><p>应用程序操作应得到<strong>规范实现者</strong>的支持。但是，如果不支持它们，实施者可以简单地忽略操作键和相关的 <em>Desktop Action</em> 操作组，并继续使用 <em>Desktop Entry</em> 组：描述和调用应用程序的主要方式是通过名称、图标和执行键来自 <em>Desktop Entry</em> 组。</p>
<h1 id="格式扩展"><a href="#格式扩展" class="headerlink" title="格式扩展"></a>格式扩展</h1><p>如果要增加新的字段，修改现有标准，需要进行小组讨论。 这是引入更改的首选方法。 如果某一方希望添加一个字段供个人使用，他们应该在键前加上字符串 <em>X-PRODUCT</em> (对应 <em>UOS</em> 操作系统系统，应该是 <em>X-DDE</em> )，例如 <em>X-NewDesktop-Foo</em>，遵循其他 <em>IETF</em> 和 <em>RFC</em> 标准设定的先例。</p>
<p>或者，字段可以放在它们自己的组中，然后它们可以有任意的键名。如果是这种情况，该组应该遵循上面概述的方案，即 <code>[X-PRODUCT GROUPNAME]</code>或类似的东西。这些步骤将避免不同但相似的环境之间的命名空间冲突。</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="A-Desktop-Entry-File"><a href="#A-Desktop-Entry-File" class="headerlink" title="A.Desktop Entry File"></a>A.Desktop Entry File</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Version</span>=<span class="number">1.0</span></span><br><span class="line"><span class="attr">Type</span>=Application</span><br><span class="line"><span class="attr">Name</span>=Foo Viewer</span><br><span class="line"><span class="attr">Comment</span>=The best viewer for Foo objects available!</span><br><span class="line"><span class="attr">TryExec</span>=fooview</span><br><span class="line"><span class="attr">Exec</span>=fooview %F</span><br><span class="line"><span class="attr">Icon</span>=fooview</span><br><span class="line"><span class="attr">MimeType</span>=image/x-foo<span class="comment">;</span></span><br><span class="line"><span class="attr">Actions</span>=Gallery<span class="comment">;Create;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Desktop Action Gallery]</span></span><br><span class="line"><span class="attr">Exec</span>=fooview --gallery</span><br><span class="line"><span class="attr">Name</span>=Browse Gallery</span><br><span class="line"></span><br><span class="line"><span class="section">[Desktop Action Create]</span></span><br><span class="line"><span class="attr">Exec</span>=fooview --create-new</span><br><span class="line"><span class="attr">Name</span>=Create a new Foo!</span><br><span class="line"><span class="attr">Icon</span>=fooview-new</span><br></pre></td></tr></table></figure>



<h2 id="B-目前保留在-KDE-中使用的字段"><a href="#B-目前保留在-KDE-中使用的字段" class="headerlink" title="B.目前保留在 KDE 中使用的字段"></a>B.目前保留在 KDE 中使用的字段</h2><p>由于历史原因，<em>KDE</em> 使用了一些 <em>KDE</em> 特定的扩展，这些扩展目前没有 <em>X-KDE-</em> 前缀。</p>
<ul>
<li>KDE specific keys: <code>ServiceTypes</code>, <code>DocPath</code>, <code>InitialPreference</code></li>
<li>KDE specific types: <code>ServiceType</code>, <code>Service</code> and <code>FSDevice</code></li>
</ul>
<p><em>KDE</em> 在标准化之前也使用 <em>Keywords</em> 键，使用逗号而不是分号作为分隔符。在标准化时，该字段已经以 <em>X-KDE</em> 前缀为前缀，但 <em>Trinity</em> 分支仍然使用无前缀的变体。</p>
<p>KDE 将以下附加键用于 <em>FSDevice</em> 类型的 <em>desktop entries</em></p>
<h3 id="FSDevice-特定的-Keys"><a href="#FSDevice-特定的-Keys" class="headerlink" title="FSDevice 特定的 Keys"></a>FSDevice 特定的 Keys</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Value Type</th>
</tr>
</thead>
<tbody><tr>
<td>Dev</td>
<td>要挂载的设备。</td>
<td>string</td>
</tr>
<tr>
<td>FSType</td>
<td>尝试挂载的文件系统类型。</td>
<td>string</td>
</tr>
<tr>
<td>MountPoint</td>
<td>相关设备的挂载点。</td>
<td>string</td>
</tr>
<tr>
<td>ReadOnly</td>
<td>指定设备是否只读。</td>
<td>boolean</td>
</tr>
<tr>
<td>UnmountIcon</td>
<td>未安装设备时显示的图标。已安装的设备显示来自 <em>Icon</em> 键的图标。</td>
<td>localestring</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Freedesktop</category>
      </categories>
      <tags>
        <tag>标准</tag>
        <tag>XDG</tag>
      </tags>
  </entry>
  <entry>
    <title>Fedora 中 ostree 更新 grub 引导的流程</title>
    <url>/2024/0699dea904.html</url>
    <content><![CDATA[<h2 id="grub-d-下的脚本"><a href="#grub-d-下的脚本" class="headerlink" title="grub.d 下的脚本"></a>grub.d 下的脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fedora:/etc/grub.d<span class="comment"># ls -al</span></span><br><span class="line">总计 108</span><br><span class="line">drwx------. 1 root root   392  6月11日 13:16 .</span><br><span class="line">drwxr-xr-x. 1 root root  4048  6月11日 13:22 ..</span><br><span class="line">-rwxr-xr-x. 1 root root  9346  6月11日 13:16 00_header</span><br><span class="line">-rwxr-xr-x. 1 root root   236  6月11日 13:16 01_users</span><br><span class="line">-rwxr-xr-x. 1 root root   835  6月11日 13:16 08_fallback_counting</span><br><span class="line">-rwxr-xr-x. 1 root root 19332  6月11日 13:16 10_linux</span><br><span class="line">-rwxr-xr-x. 1 root root   833  6月11日 13:16 10_reset_boot_success</span><br><span class="line">-rwxr-xr-x. 1 root root   892  6月11日 13:16 12_menu_auto_hide</span><br><span class="line">-rwxr-xr-x. 1 root root   410  6月11日 13:16 14_menu_show_once</span><br><span class="line">lrwxrwxrwx. 1 root root    38  6月11日 13:16 15_ostree -&gt; /usr/libexec/libostree/grub2-15_ostree</span><br><span class="line">-rwxr-xr-x. 1 root root 13613  6月11日 13:16 20_linux_xen</span><br><span class="line">-rwxr-xr-x. 1 root root  2562  6月11日 13:16 20_ppc_terminfo</span><br><span class="line">-rwxr-xr-x. 1 root root 10869  6月11日 13:16 30_os-prober</span><br><span class="line">-rwxr-xr-x. 1 root root  1122  6月11日 13:16 30_uefi-firmware</span><br><span class="line">-rwxr-xr-x. 1 root root   725  6月11日 13:16 35_fwupd</span><br><span class="line">-rwxr-xr-x. 1 root root   218  6月11日 13:16 40_custom</span><br><span class="line">-rwxr-xr-x. 1 root root   219  6月11日 13:16 41_custom</span><br><span class="line">-rw-r--r--. 1 root root   483  6月11日 13:16 README</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ostree-修改-grub-引导项"><a href="#ostree-修改-grub-引导项" class="headerlink" title="ostree 修改 grub 引导项"></a>ostree 修改 grub 引导项</h2><p>核心逻辑见最后一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (C) 2014 Colin Walters &lt;walters@verbum.org&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"># it under the terms of the GNU Lesser General Public License as published</span></span><br><span class="line"><span class="comment"># by the Free Software Foundation; either version 2 of the licence or (at</span></span><br><span class="line"><span class="comment"># your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment"># Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You should have received a copy of the GNU Lesser General</span></span><br><span class="line"><span class="comment"># Public License along with this library. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gracefully exit if ostree is not installed, or there&#x27;s</span></span><br><span class="line"><span class="comment"># no system repository initialized.</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">which</span> ostree &gt;/dev/null 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -d /ostree/repo; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gracefully exit if we can not find the grub2 &#x27;default&#x27; configuration as it is</span></span><br><span class="line"><span class="comment"># the case on new installations with bootupd where it is not needed.</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/default/grub; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gracefully exit if the grub2 configuration has BLS enabled,</span></span><br><span class="line"><span class="comment"># and the installed version has support for the blscfg module.</span></span><br><span class="line"><span class="comment"># Since there is no need to create menu entries for that case.</span></span><br><span class="line"><span class="comment"># See: https://src.fedoraproject.org/rpms/grub2/c/7c2bab5e98d</span></span><br><span class="line">. /etc/default/grub</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /boot/grub2/.grub2-blscfg-supported &amp;&amp; \</span><br><span class="line">   <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$&#123;GRUB_ENABLE_BLSCFG&#125;</span>&quot;</span> = <span class="string">&quot;true&quot;</span>; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure we&#x27;re in the right environment</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$&#123;GRUB_DEVICE&#125;</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;This script must be run as a child of grub2-mkconfig&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pick up stuff from grub&#x27;s helper that we want to inject into our</span></span><br><span class="line"><span class="comment"># generated bootloader configuration.  Yes, this is pretty awful, but</span></span><br><span class="line"><span class="comment"># it&#x27;s a lot better than reimplementing the config-generating bits of</span></span><br><span class="line"><span class="comment"># OSTree in shell script.</span></span><br><span class="line"></span><br><span class="line">. /usr/share/grub/grub-mkconfig_lib</span><br><span class="line"></span><br><span class="line">DEVICE=<span class="variable">$&#123;GRUB_DEVICE_BOOT:-<span class="variable">$&#123;GRUB_DEVICE&#125;</span>&#125;</span></span><br><span class="line"></span><br><span class="line">GRUB2_BOOT_DEVICE_ID=<span class="string">&quot;<span class="subst">$(grub_get_device_id $&#123;DEVICE&#125;)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> GRUB2_BOOT_DEVICE_ID</span><br><span class="line">GRUB2_PREPARE_ROOT_CACHE=<span class="string">&quot;<span class="subst">$(prepare_grub_to_access_device $&#123;DEVICE&#125;)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> GRUB2_PREPARE_ROOT_CACHE</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ostree admin instutil grub2-generate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>阅读 <a class="link"   href="https://github.com/ostreedev/ostree" >ostree 源码<i class="fas fa-external-link-alt"></i></a>，函数调用顺序如下：<br>ot_admin_instutil_builtin_grub2_generate<br>ostree_generate_grub2_config<br>impl_ostree_generate_grub2_config<br>_ostree_bootloader_grub2_generate_config   &#x2F;&#x2F; 向target_fd(实际是向标准输出)中写入引导数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This implementation is quite complex; see this issue for</span></span><br><span class="line"><span class="comment"> * a starting point:</span></span><br><span class="line"><span class="comment"> * https://github.com/ostreedev/ostree/issues/717</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gboolean</span><br><span class="line">_ostree_bootloader_grub2_generate_config (OstreeSysroot                 *sysroot,</span><br><span class="line">                                          <span class="type">int</span>                            bootversion,</span><br><span class="line">                                          <span class="type">int</span>                            target_fd,</span><br><span class="line">                                          GCancellable                  *cancellable,</span><br><span class="line">                                          GError                       **error)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* So... yeah.  Just going to hardcode these. */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> hardcoded_video[] = <span class="string">&quot;load_video\n&quot;</span></span><br><span class="line">        <span class="string">&quot;set gfxpayload=keep\n&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> hardcoded_insmods[] = <span class="string">&quot;insmod gzio\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *grub2_boot_device_id =</span><br><span class="line">        g_getenv (<span class="string">&quot;GRUB2_BOOT_DEVICE_ID&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *grub2_prepare_root_cache =</span><br><span class="line">        g_getenv (<span class="string">&quot;GRUB2_PREPARE_ROOT_CACHE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We must have been called via the wrapper script */</span></span><br><span class="line">    g_assert (grub2_boot_device_id != <span class="literal">NULL</span>);</span><br><span class="line">    g_assert (grub2_prepare_root_cache != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Passed from the parent */</span></span><br><span class="line">    gboolean is_efi = g_getenv (<span class="string">&quot;_OSTREE_GRUB2_IS_EFI&quot;</span>) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_autoptr(GOutputStream) out_stream = g_unix_output_stream_new (target_fd, FALSE);</span><br><span class="line"></span><br><span class="line">    g_autoptr(GPtrArray) loader_configs = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!_ostree_sysroot_read_boot_loader_configs (sysroot, bootversion,</span><br><span class="line">                                                 &amp;loader_configs,</span><br><span class="line">                                                 cancellable, error))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    g_autoptr(GString) output = g_string_new (<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (guint i = <span class="number">0</span>; i &lt; loader_configs-&gt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OstreeBootconfigParser *config = loader_configs-&gt;pdata[i];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *title;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *options;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *kernel;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *initrd;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *devicetree;</span><br><span class="line">        <span class="type">char</span> *quoted_title = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *uuid = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *quoted_uuid = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        title = ostree_bootconfig_parser_get (config, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!title)</span><br><span class="line">            title = <span class="string">&quot;(Untitled)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        kernel = ostree_bootconfig_parser_get (config, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">        quoted_title = g_shell_quote (title);</span><br><span class="line">        uuid = g_strdup_printf (<span class="string">&quot;ostree-%u-%s&quot;</span>, (guint)i, grub2_boot_device_id);</span><br><span class="line">        quoted_uuid = g_shell_quote (uuid);</span><br><span class="line">        g_string_append_printf (output, <span class="string">&quot;menuentry %s --class gnu-linux --class gnu --class os --unrestricted %s &#123;\n&quot;</span>, quoted_title, quoted_uuid);</span><br><span class="line">        g_free (uuid);</span><br><span class="line">        g_free (quoted_title);</span><br><span class="line">        g_free (quoted_uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hardcoded sections */</span></span><br><span class="line">        g_string_append (output, hardcoded_video);</span><br><span class="line">        g_string_append (output, hardcoded_insmods);</span><br><span class="line">        g_string_append (output, grub2_prepare_root_cache);</span><br><span class="line">        g_string_append_c (output, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!kernel)</span><br><span class="line">            <span class="keyword">return</span> glnx_throw (error, <span class="string">&quot;No \&quot;linux\&quot; key in bootloader config&quot;</span>);</span><br><span class="line">        g_string_append (output, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (is_efi)</span><br><span class="line">            g_string_append (output, GRUB2_EFI_SUFFIX);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            g_string_append (output, GRUB2_SUFFIX);</span><br><span class="line">        g_string_append_c (output, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        g_string_append (output, kernel);</span><br><span class="line"></span><br><span class="line">        options = ostree_bootconfig_parser_get (config, <span class="string">&quot;options&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (options)</span><br><span class="line">        &#123;</span><br><span class="line">            g_string_append_c (output, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            g_string_append (output, options);</span><br><span class="line">        &#125;</span><br><span class="line">        g_string_append_c (output, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        initrd = ostree_bootconfig_parser_get (config, <span class="string">&quot;initrd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (initrd)</span><br><span class="line">        &#123;</span><br><span class="line">            g_string_append (output, <span class="string">&quot;initrd&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (is_efi)</span><br><span class="line">                g_string_append (output, GRUB2_EFI_SUFFIX);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                g_string_append (output, GRUB2_SUFFIX);</span><br><span class="line">            g_string_append_c (output, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            g_string_append (output, initrd);</span><br><span class="line">            g_string_append_c (output, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devicetree = ostree_bootconfig_parser_get (config, <span class="string">&quot;devicetree&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (devicetree)</span><br><span class="line">        &#123;</span><br><span class="line">            g_string_append (output, <span class="string">&quot;devicetree&quot;</span>);</span><br><span class="line">            g_string_append_c (output, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            g_string_append (output, devicetree);</span><br><span class="line">            g_string_append_c (output, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_string_append (output, <span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gsize bytes_written;</span><br><span class="line">    <span class="keyword">if</span> (!g_output_stream_write_all (out_stream, output-&gt;str, output-&gt;len,</span><br><span class="line">                                  &amp;bytes_written, cancellable, error))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看所属软件包"><a href="#查看所属软件包" class="headerlink" title="查看所属软件包"></a>查看所属软件包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fedora:/etc/grub.d<span class="comment"># rpm -qf /usr/libexec/libostree/grub2-15_ostree</span></span><br><span class="line">ostree-grub2-2024.5-1.fc40.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="查询软件包提供者"><a href="#查询软件包提供者" class="headerlink" title="查询软件包提供者"></a>查询软件包提供者</h2><p>源码也是由 ostree 提供</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fedora:/etc/grub.d<span class="comment"># rpm -qi ostree-grub2</span></span><br><span class="line">Name        : ostree-grub2</span><br><span class="line">Version     : 2024.5</span><br><span class="line">Release     : 1.fc40</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: 2024年04月15日 星期一 02时09分59秒</span><br><span class="line">Group       : Unspecified</span><br><span class="line">Size        : 2266</span><br><span class="line">License     : LGPL-2.0-or-later</span><br><span class="line">Signature   : RSA/SHA256, 2024年03月15日 星期五 07时19分33秒, Key ID 0727707ea15b79cc</span><br><span class="line">Source RPM  : ostree-2024.5-1.fc40.src.rpm</span><br><span class="line">Build Date  : 2024年03月15日 星期五 06时09分26秒</span><br><span class="line">Build Host  : buildhw-x86-08.iad2.fedoraproject.org</span><br><span class="line">Packager    : Fedora Project</span><br><span class="line">Vendor      : Fedora Project</span><br><span class="line">URL         : https://ostree.readthedocs.io/en/latest/</span><br><span class="line">Bug URL     : https://bugz.fedoraproject.org/ostree</span><br><span class="line">Summary     : GRUB2 integration <span class="keyword">for</span> OSTree</span><br><span class="line">Description :</span><br><span class="line">GRUB2 integration <span class="keyword">for</span> OSTree</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ostree-grub2 安装时提供了 &#x2F;usr&#x2F;libexec&#x2F;libostree&#x2F;grub2-15_ostree , 并链接至 &#x2F;etc&#x2F;grub.d&#x2F;15_ostree，在重启前，执行 grub-mkconfig 操作，更新 grub 引导数据。</p>
]]></content>
      <categories>
        <category>Fedora</category>
      </categories>
      <tags>
        <tag>ostree</tag>
        <tag>grub</tag>
        <tag>fedora</tag>
      </tags>
  </entry>
  <entry>
    <title>GammaRay代码导图</title>
    <url>/2023/104b4fafed.html</url>
    <content><![CDATA[<p>源码之下，了无秘密，见下图：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/1.jpg"
                       
                 ></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Greenboot服务介绍</title>
    <url>/2024/06697cec4e.html</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Fedora 中提供了 <a class="link"   href="https://github.com/fedora-iot/greenboot/tree/main" >greenboot<i class="fas fa-external-link-alt"></i></a> 服务，这是一款基于 rpm-ostree 的系统上 systemd 的通用运行状况检查框架。</p>
<span id="more"></span>

<p>Greenboot 由两部分组成：</p>
<ul>
<li>greenboot ：检查提供的脚本，如果这些检查未通过则重新启动，如果重新启动未能解决问题则回滚到之前的部署。</li>
<li>greenboot-default-health-checks ，由 Greenboot 维护者提供的一系列可选和策划的健康检查。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>为了在 Fedora Silverblue、Fedora IoT 或 Fedora CoreOS 上获得完整的 Greenboot ，请使用如下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm-ostree install greenboot greenboot-default-health-checks</span><br><span class="line">systemctl reboot</span><br></pre></td></tr></table></figure>

<h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><ul>
<li>MOTD：指&#x2F;run&#x2F;motd.d&#x2F;boot-status，存放 greenboot 运行阶段的一些日志信息。</li>
</ul>
<h2 id="脚本目录"><a href="#脚本目录" class="headerlink" title="脚本目录"></a>脚本目录</h2><p>目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc</span><br><span class="line">└── greenboot</span><br><span class="line">    ├── check</span><br><span class="line">    │   ├── required.d</span><br><span class="line">    │   └── wanted.d</span><br><span class="line">    ├── green.d</span><br><span class="line">    └── red.d</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;etc&#x2F;greenboot&#x2F;check&#x2F;required.d：此目录中的运行状态检查脚本不得失败。如果此文件夹中的任何脚本退出时出现错误代码，则启动将被声明为失败。错误消息将出现在 MOTD 和 journalctl -u greenboot-healthcheck.service 中。</li>
<li>&#x2F;etc&#x2F;greenboot&#x2F;check&#x2F;wanted.d：此目录中的运行状态检查脚本可能失败，。此文件夹中的脚本可以退出并显示错误代码，并且启动不会被声明为失败。错误消息将出现在 MOTD 和 journalctl -u greenboot-healthcheck.service -b 中。</li>
<li>&#x2F;etc&#x2F;greenboot&#x2F;green.d：此目录中的交叉脚本将在启动成功（绿色）后运行。</li>
<li>&#x2F;etc&#x2F;greenboot&#x2F;red.d：此目录中的交叉脚本将在启动失败（红色）后运行。</li>
</ul>
<p>除非您的发行版中默认启用 greenboot，否则请通过运行 <code>systemctl enable greenboot-task-runner greenboot-healthcheck greenboot-status greenboot-loading-message greenboot-grub2-set-counter greenboot-grub2-set-success greenboot-rpm-ostree-grub2-check-fallback redboot-auto-reboot redboot-task-runner</code> 来启用它。它将在下次启动过程中自动启动并运行检查。</p>
<p>之后当您 ssh 进入计算机时，将显示启动状态消息：<br><code>Boot Status is GREEN - Health Check SUCCESS</code><br><code>Boot Status is RED - Health Check FAILURE!</code></p>
<h2 id="greenboot-default-health-checks"><a href="#greenboot-default-health-checks" class="headerlink" title="greenboot-default-health-checks"></a>greenboot-default-health-checks</h2><p>这些运行状况检查可在 rpm-ostree 系统中的只读目录 &#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;check 中找到。</p>
<ul>
<li>检查存储库 URL 是否仍可通过 DNS 解析：此脚本位于 &#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;check&#x2F;required.d&#x2F;01_repository_dns_check.sh 下，并确保对存储库 URL 的 DNS 查询仍然可用。</li>
<li>检查更新平台是否仍然可访问：此脚本位于 &#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;check&#x2F;wanted.d&#x2F;01_update_platform_check.sh 下，并尝试连接并从 &#x2F;etc&#x2F;ostree&#x2F;remotes.d 中定义的更新平台获取 2XX 或 3XX HTTP 代码。</li>
<li>检查当前启动是否由硬件看门狗触发：此脚本位于 &#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;check&#x2F;required.d&#x2F;02_watchdog.sh 下，用于检查当前启动是否由看门狗触发。如果是，但在一定的宽限期（默认为 24 小时，可通过 &#x2F;etc&#x2F;greenboot&#x2F;greenboot.conf 中的 GREENBOOT_WATCHDOG_GRACE_PERIOD&#x3D;number_of_hours 配置）后重新启动，Greenboot 不会将当前启动标记为红色，并且不会回滚到之前的部署。如果在宽限期内发生，此时当前启动将被标记为红色，但 Greenboot 不会回滚到之前的部署。默认情况下启用，但可以通过将 &#x2F;etc&#x2F;greenboot&#x2F;greenboot.conf 中的 GREENBOOT_WATCHDOG_CHECK_ENABLED 修改为 false 来禁用它。</li>
</ul>
<h2 id="使用-systemd-服务进行健康检查"><a href="#使用-systemd-服务进行健康检查" class="headerlink" title="使用 systemd 服务进行健康检查"></a>使用 systemd 服务进行健康检查</h2><p>总体启动成功是根据 boot-complete.target 来衡量的。</p>
<h3 id="Required-Checks"><a href="#Required-Checks" class="headerlink" title="Required Checks"></a>Required Checks</h3><p>创建一个不能失败的一次性健康检查服务单元，例如 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;required-check.service 。确保它在失败时调用 redboot.target ( OnFailure&#x3D;redboot.target )。运行 <code>systemctl enable required-check </code>来启用它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Custom Required Health Check</span><br><span class="line">Before=boot-complete.target</span><br><span class="line">OnFailure=redboot.target</span><br><span class="line">OnFailureJobMode=fail</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/libexec/mytestsuite/required-check</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">RequiredBy=boot-complete.target</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="Wanted-Checks"><a href="#Wanted-Checks" class="headerlink" title="Wanted Checks"></a>Wanted Checks</h3><p>创建一个可能会失败的一次性健康检查服务单元，例如 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;wanted-check.service 。运行 <code>systemctl enable wanted-check</code> 来启用它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Custom Wanted Health Check</span><br><span class="line">Before=boot-complete.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/libexec/mytestsuite/wanted-check</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=boot-complete.target</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前，可以通过环境变量自定义以下参数。这些环境变量也可以在配置文件 &#x2F;etc&#x2F;greenboot&#x2F;greenboot.conf 中描述：</p>
<ul>
<li>GREENBOOT_MAX_BOOT_ATTEMPTS：在声明部署有问题并回滚到上一个部署之前尝试启动的最大次数,默认为3。</li>
<li>GREENBOOT_WATCHDOG_CHECK_ENABLED：启用&#x2F;禁用检查当前启动是否已由硬件看门狗健康检查触发。有关健康检查的更多信息包含在子包 greenboot-default-health-checks 部分中。</li>
<li>GREENBOOT_WATCHDOG_GRACE_PERIOD：升级后我们认为新部署导致重新启动的小时数。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>greenboot-rpm-ostree-grub2-check-fallback.service 在 greenboot-healthcheck.service 之前运行，并检查 GRUB2 环境变量 boot_counter 是否为 -1。<ul>
<li>如果为 -1，则意味着系统处于回退部署中，并将执行 <code>rpm-ostree rollback </code>返回到之前的工作部署。</li>
<li>如果 boot_counter 不为-1，则此步骤不执行任何操作。</li>
</ul>
</li>
<li>greenboot-healthcheck.service 在 systemd 的 boot-complete.target 之前运行。它启动 &#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot check ，它运行 required.d 和 wanted.d 脚本。<ul>
<li>如果 required.d 文件夹中的任何脚本失败，则调用 redboot.target 。<ul>
<li>它触发 redboot-task-runner.service ，从而启动 &#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot red 。这将运行 red.d 文件夹中的脚本。</li>
<li>经过上述操作后：<ul>
<li>greenboot-status.service 运行，创建 MOTD 指定哪些脚本失败。</li>
<li>redboot-auto-reboot.service 已运行。它执行一系列检查以确定是否需要手动干预。如果没有，它将重新启动系统。</li>
</ul>
</li>
</ul>
</li>
<li>如果 required.d 文件夹中的所有脚本都成功：<ul>
<li>已达到 boot-complete.target </li>
<li>greenboot-grub2-set-success.service 已运行。它取消设置 boot_counter GRUB 环境变量并将 boot_success GRUB 环境变量设置为 1。</li>
<li>greenboot-task-runner.service 启动<code> /usr/libexec/greenboot/greenboot green</code> ，它运行 green.d 文件夹中的脚本，这些脚本将在成功更新后运行。</li>
<li>greenboot-status.service 运行，创建 MOTD 并显示成功消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Services-一览"><a href="#Services-一览" class="headerlink" title="Services 一览"></a>Services 一览</h2><table>
<thead>
<tr>
<th><strong>服务</strong></th>
<th><strong>作用</strong></th>
<th><strong>其他</strong></th>
</tr>
</thead>
<tbody><tr>
<td>greenboot-grub2-set-counter.service</td>
<td>greenboot-grub2-set-counter：<br>grub2-editenv - set boot_counter&#x3D;”$max_boot_attempts” <br>grub2-editenv - set boot_success&#x3D;0<br>通过命令参数或配置文件中获取最大重启次数，未指定则默认为3次</td>
<td>配置文件：<br>&#x2F;etc&#x2F;greenboot&#x2F;greenboot.conf<br>配置项：<br>GREENBOOT_MAX_BOOT_ATTEMPTS<br>配置文件中允许通过DISABLED_HEALTHCHECKS禁用某些检查项</td>
</tr>
<tr>
<td>greenboot-grub2-set-success.service</td>
<td>grub2-editenv - set boot_success&#x3D;1<br>grub2-editenv - unset boot_counter<br></td>
<td>After&#x3D;boot-complete.target<br>在系统启动完成后运行</td>
</tr>
<tr>
<td>greenboot-healthcheck.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot check<br>执行&#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;check和&#x2F;etc&#x2F;greenboot&#x2F;check目录中required.d和wanted.d的检查脚本，如果required.d中的脚本运行失败，将导致greenboot进程退出值为1(异常退出)。</td>
<td>wanted.d中脚本失败无影响OnFailure&#x3D;redboot.target<br>失败后到达redboot.target，从而启动redboot-task-runner.service</td>
</tr>
<tr>
<td>greenboot-loading-message.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot-loading-message<br>只是向&#x2F;run&#x2F;motd.d&#x2F;boot-status中输出一些信息</td>
<td>-</td>
</tr>
<tr>
<td>greenboot-rpm-ostree-grub2-check-fallback.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot-rpm-ostree-grub2-check-fallback</td>
<td>rpm-ostree rollback<br>修改grub引导，第一项变为上一版本</td>
</tr>
<tr>
<td>greenboot-status.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot-status<br>综合其他的日志信息，统一导入到&#x2F;run&#x2F;motd.d&#x2F;boot-status</td>
<td>服务包括：<br>greenboot-healthcheck.service<br>greenboot-task-runner.service<br>redboot-task-runner.service <br>redboot-auto-reboot.service<br>greenboot-rpm-ostree-grub2-check-fallback.service</td>
</tr>
<tr>
<td>greenboot-task-runner.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot green<br>执行&#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;green.d和&#x2F;etc&#x2F;greenboot&#x2F;green.d中的脚本</td>
<td>After&#x3D;boot-complete.target在系统启动完成后运行</td>
</tr>
<tr>
<td>redboot-auto-reboot.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;redboot-auto-reboot<br>检查是否需要重启</td>
<td>根据grub2-editenv list中的信息以及&#x2F;boot&#x2F;loader&#x2F;entries&#x2F;中文件数量决定当前是否重启</td>
</tr>
<tr>
<td>redboot-task-runner.service</td>
<td>&#x2F;usr&#x2F;libexec&#x2F;greenboot&#x2F;greenboot red<br>执行&#x2F;usr&#x2F;lib&#x2F;greenboot&#x2F;red.d和&#x2F;etc&#x2F;greenboot&#x2F;red.d中的脚本</td>
<td>RequiredBy&#x3D;redboot.target<br>此服务在系统启动失败后运行</td>
</tr>
<tr>
<td>redboot.target</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="grub2-editenv"><a href="#grub2-editenv" class="headerlink" title="grub2-editenv"></a>grub2-editenv</h2><p>在设置 GRUB 环境的时候，用到了 grub2-editenv 命令，由 grub2-tools-minimal 提供。<br>查阅其 <a class="link"   href="https://git.savannah.gnu.org/git/grub.git" >源码<i class="fas fa-external-link-alt"></i></a> 可以得知，这里只是把 set 的内容写入 &#x2F;boot&#x2F;grub2&#x2F;grubenv 文件中进行保存。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>grub</tag>
        <tag>fedora</tag>
        <tag>greenboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Icon Theme Specification(图标主题规范)</title>
    <url>/2023/058916a55.html</url>
    <content><![CDATA[<p>原文链接：<a class="link"   href="https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html" >https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>图标主题是一种使应用程序的图标具有统一外观和感觉的机制。当用户选择一个特定的图标主题时，系统会使用该主题中的图标来渲染所有应用程序的图标。图标主题最初用于桌面文件规范中的图标字段，但在其他场景下也可以发挥作用，例如 mimetype 图标。</p>
<p>从程序员的角度来看，图标主题只是一种映射机制。给定一组目录和主题名称，它将从图标名称和标称图标大小映射到图标文件名。这样，应用程序可以使用相应的图标文件来显示其图标，而无需直接指定文件路径或图标文件名。</p>
<span id="more"></span>



<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图标主题：图标主题是一组命令的图标文件，它可以根据图标名和给定大小映射到具体的文件。主题也支持从其他主题继承，从而很好的扩展当前主题的功能。<br>图标文件：图标文件是可以加载并用作图标的图像。支持的图像文件格式为 PNG、XPM 和 SVG。PNG 是比较推荐的位图格式，SVG 用于矢量化图标。由于向后兼容的原因，支持 XPM 格式，不建议新主题使用 XPM 文件。(对 SVG 的支持是可选的。)<br>基础目录：在一组称为基本目录的目录中搜索图标和主题。主题存储在基本目录的子目录中。<br>图标比例：在非常高密度（高 dpi）的屏幕上，通常会缩放 UI 以避免 UI 太小以至于难以看到。为了支持这个图标可以有一个目标比例，描述他们被设计的比例因子。例如，目录大小为 48 但比例为 2x 的图标将是 96x96 像素，但设计为具有与比例为 1x 的 48x48 图标相同的细节级别。这可用于高密度显示器，其中 48x48 图标会太小（或放大后很难看），而普通的 96x96 图标会有很多细节很难看清。</p>
<h1 id="目录布局"><a href="#目录布局" class="headerlink" title="目录布局"></a>目录布局</h1><p>在一组目录中查找图标和主题。默认情况下，应用程序应<strong>顺序查找</strong>以下目录 </p>
<blockquote>
<p>$HOME&#x2F;.icons（为了向后兼容）、<br>$XDG_DATA_DIRS&#x2F;icons<br>&#x2F;usr&#x2F;share&#x2F;pixmaps</p>
</blockquote>
<p>应用程序可以进一步将它们自己的图标目录添加到此列表中，用户可以扩展或更改列表（以应用程序&#x2F;桌面的特定方式）。在这些目录中的每一个中，主题都存储为子目录。通过具有相同名称的子目录，主题可以分布在多个基本目录中。这样用户就可以扩展和覆盖系统主题。</p>
<p>为了让第三方应用程序有地方安装它们的图标，应该<strong>始终存在一个名为“hicolor” [<a class="link"   href="https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#ftn.idm46015176462592" >1]<i class="fas fa-external-link-alt"></i></a>的主题</strong>。hicolor 主题的数据可从以下网址下载：<a class="link"   href="http://www.freedesktop.org/software/icon-theme/" >http://www.freedesktop.org/software/icon-theme/<i class="fas fa-external-link-alt"></i></a> 。</p>
<p>如果<strong>在当前主题中找不到图标，则需要在“hicolor”主题中查找实现</strong>。</p>
<p>每个主题都存储为基本目录的子目录。尽管主题指定的用户可见名称可能不同，但主题的内部名称始终是子目录的名称。因此，主题名称区分大小写，并且仅限于 ASCII 字符。主题名称也可能不包含逗号或空格。</p>
<p>在至少一个<strong>主题目录中必须有一个名为 index.theme 的文件来描述主题</strong>。使用按顺序搜索基本目录时找到的第一个 index.theme。该文件描述了主题的一般属性。</p>
<p>在主题目录中还有一组包含图像文件的子目录。每个目录都包含为特定标称图标大小和比例设计的图标，如 index.theme 文件所述。子目录允许有几层深，例如主题“hicolor”中的子目录“48x48&#x2F;apps”最终将位于 $basedir&#x2F;hicolor&#x2F;48x48&#x2F;apps。</p>
<p>图像文件必须是以下类型之一：<strong>PNG、XPM 或 SVG</strong>，并且<strong>扩展名必须是“.png”、“.xpm”或“.svg”（小写）</strong>。<strong>对 SVG 文件的支持是可选的</strong>。不支持 SVG 的实现应该忽略任何“.svg”文件。除此之外，可能还有一个附加文件，每个文件都有额外的图标数据。它应该与图像文件具有相同的基本名称，扩展名为“.icon”。例如，如果图标文件名为“mime_source_c.png”，相应的文件将被命名为“mime_source_c.icon”。</p>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><p>图标主题描述文件和图标数据文件都是 ini 样式的文本文件，如桌面文件规范中所述。他们没有任何编码字段。相反，它们必须始终以 UTF-8 编码存储。</p>
<p><em>index.theme 文件必须以名为Icon Theme 的</em> 部分开头，其内容根据下表 1 确定。所有列表均以逗号分隔。</p>
<h2 id="标准-Keys"><a href="#标准-Keys" class="headerlink" title="标准 Keys"></a>标准 Keys</h2><table>
<thead>
<tr>
<th>Key</th>
<th>描述</th>
<th>值类型</th>
<th>是否必需</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>图标主题的简称，例如在主题选择列表中显示</td>
<td>本地字符串</td>
<td>YES</td>
</tr>
<tr>
<td>Comment</td>
<td>描述主题的较长字符串</td>
<td>本地字符串</td>
<td>YES</td>
</tr>
<tr>
<td>Inherits</td>
<td>此主题继承自的主题的名称。如果在当前主题中找不到图标名称，则会在继承的主题中搜索（并在所有继承的主题中递归）。如果没有指定主题，则需要将“hicolor”主题添加到继承树中。<br>实现者(系统发行商或桌面环境维护团队)可以选择在最后指定的主题和 hicolor 主题之间添加其他默认主题。</td>
<td>字符串</td>
<td>NO</td>
</tr>
<tr>
<td>Directories</td>
<td>该主题的子目录列表。对于每个子目录，index.theme 文件中必须有一个部分描述该目录</td>
<td>字符串</td>
<td>YES</td>
</tr>
<tr>
<td>ScaledDirectories</td>
<td>除了目录中的子目录之外，该主题的其他子目录列表。这些目录只能由支持缩放目录的实现读取，并被添加以保持与不支持这些的旧实现的兼容性。</td>
<td>字符串</td>
<td>NO</td>
</tr>
<tr>
<td>Hidden</td>
<td>是否在主题选择用户界面中隐藏主题。这用于用户不应该看到的诸如后备主题之类的东西。</td>
<td>布尔值</td>
<td>NO</td>
</tr>
<tr>
<td>Example</td>
<td>应用作此主题外观示例的图标名称。</td>
<td>字符串</td>
<td>NO</td>
</tr>
</tbody></table>
<h2 id="目录-Keys"><a href="#目录-Keys" class="headerlink" title="目录  Keys"></a>目录  Keys</h2><p>指定的每个目录都有一个与该目录同名的相应部分。</p>
<table>
<thead>
<tr>
<th>钥匙</th>
<th>描述</th>
<th>值类型</th>
<th>是否必需</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>Size</td>
<td>此目录中图标的标称（未缩放）大小。</td>
<td>整数</td>
<td>是的</td>
<td></td>
</tr>
<tr>
<td>Scale</td>
<td>此目录中图标的目标比例。如果不存在则默认为值 1。为了向后兼容，任何比例不是 1 的目录都应该列在 ScaledDirectories 列表中，而不是目录中。</td>
<td>整数</td>
<td>不</td>
<td></td>
</tr>
<tr>
<td>Context</td>
<td>通常使用图标的上下文。这在<a class="link"   href="https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#context" >名为“上下文”的部分<i class="fas fa-external-link-alt"></i></a>中有详细讨论。</td>
<td>细绳</td>
<td>不</td>
<td></td>
</tr>
<tr>
<td>Type</td>
<td>此目录中图标的图标大小类型。有效类型为 Fixed、Scalable 和 Threshold。类型决定使用该部分中的其他键。如果未指定，则默认为阈值。</td>
<td>细绳</td>
<td>不</td>
<td></td>
</tr>
<tr>
<td>MaxSize</td>
<td>指定此目录中的图标可以缩放到的最大（未缩放）大小。如果不存在，则默认为 Size 的值。</td>
<td>整数</td>
<td>不</td>
<td>可扩展</td>
</tr>
<tr>
<td>MinSize</td>
<td>指定此目录中的图标可以缩放到的最小（未缩放）大小。如果不存在，则默认为 Size 的值。</td>
<td>整数</td>
<td>不</td>
<td>可扩展</td>
</tr>
<tr>
<td>Threshold</td>
<td>如果大小最多与所需（未缩放）大小相差这么多，则可以使用此目录中的图标。如果不存在则默认为 2。</td>
<td>整数</td>
<td>不</td>
<td>临界点</td>
</tr>
</tbody></table>
<p>除了这些组之外，您还可以向 index.theme 文件添加额外的组以扩展它。这些扩展名必须以“X-”开头，可用于将桌面特定信息添加到主题文件中。示例组名称是“X-KDE Icon Theme”或“X-Gnome Icon Theme”。</p>
<h2 id="图标-Keys"><a href="#图标-Keys" class="headerlink" title="图标 Keys"></a>图标 Keys</h2><table>
<thead>
<tr>
<th>Key</th>
<th>描述</th>
<th>值类型</th>
<th>是否必需</th>
</tr>
</thead>
<tbody><tr>
<td>DisplayName</td>
<td>一个翻译后的 UTF8 字符串，当图标在用户界面中列出时，可以用来代替图标名称。</td>
<td>本地字符串</td>
<td>NO</td>
</tr>
<tr>
<td>EmbeddedTextRectangle</td>
<td>如果存在，它指定显示图标的程序可以嵌入文本的矩形的四个角。这通常由想要在图标中显示文本文件内容预览的文件管理器使用。角由四个值的列表指定：x0、y0、x1、y1。这些值是从图标左上角开始的像素坐标，SVG 文件除外，它们在 1000x1000 坐标空间中指定，该空间缩放到图标的最终渲染大小。</td>
<td>整数</td>
<td>NO</td>
</tr>
<tr>
<td>AttachPoints</td>
<td>以“|”分隔的点列表 可用作标志&#x2F;覆盖物的锚点。这些点是从图标左上角开始的像素坐标，SVG 文件除外，它们在 1000x1000 坐标空间中指定，该空间缩放到图标的最终渲染大小。</td>
<td>坐标点</td>
<td>NO</td>
</tr>
</tbody></table>
<p>允许对 filename.icon 文件进行扩展，但键必须以“X-”开头，以避免与此格式的未来标准化扩展冲突。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>允许<code>Context</code>设计者在概念层面对图标进行分组。它不充当文件系统中的名称空间，因此图标可以具有相同的名称，但允许实现根据它进行分类和排序，例如。</p>
<p>这些是可用的上下文：</p>
<ul>
<li><strong>Actions.</strong> 表示用户启动的操作的图标，例如另存为。</li>
<li><strong>Devices.</strong> 代表现实世界设备的图标，例如打印机和鼠标。它不适用于字符或块设备等文件系统节点。</li>
<li><strong>FileSystems.</strong> 作为文件系统的一部分表示的对象的图标。例如，本地网络、“主页”和“桌面”文件夹。</li>
<li><strong>MimeTypes.</strong> 表示 MIME 类型的图标。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/058916a55/image-20230504171140092.png"
                        alt="image-20230504171140092"
                 ></p>
<h1 id="图标查找"><a href="#图标查找" class="headerlink" title="图标查找"></a>图标查找</h1><p>图标查找机制有两个全局设置，基本目录列表和当前主题的内部名称。鉴于这些，我们需要指定如何从图标名称、正常尺寸和比例中查找图标文件。</p>
<p>查找首先在当前主题中完成，然后在当前主题的每个父主题中递归，最后在名为“hicolor”的默认主题中进行（实现可能会在“hicolor”之前添加更多默认主题，但“hicolor”必须是最后一个). 一旦有任何大小的图标与主题匹配，搜索就会停止。即使在继承的主题中可能有尺寸更接近正确图标的图标，我们也不想使用它。当您更改图标大小时（例如放大），这样做可能会导致图标发生不一致的变化。</p>
<p>主题内的查找分三个阶段完成。首先扫描所有目录以寻找完全匹配的目录，例如图标文件的允许大小与查找的内容相匹配的目录。然后扫描所有目录以查找与名称匹配的图标。如果失败，我们最终会退回到无主题图标。如果我们根本找不到任何图标，则由应用程序选择一个好的后备图标，因为正确的选择取决于上下文。</p>
<p>在主题中查找图标的确切算法（伪代码）（如果实现者支持 SVG）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FindIcon(icon, size, scale) &#123;</span><br><span class="line">  filename = FindIconHelper(icon, size, scale, user selected theme);</span><br><span class="line">  if filename != none</span><br><span class="line">    return filename</span><br><span class="line"></span><br><span class="line">  filename = FindIconHelper(icon, size, scale, &quot;hicolor&quot;);</span><br><span class="line">  if filename != none</span><br><span class="line">    return filename</span><br><span class="line"></span><br><span class="line">  return LookupFallbackIcon (icon)</span><br><span class="line">&#125;</span><br><span class="line">FindIconHelper(icon, size, scale, theme) &#123;</span><br><span class="line">  filename = LookupIcon (icon, size, scale, theme)</span><br><span class="line">  if filename != none</span><br><span class="line">    return filename</span><br><span class="line"></span><br><span class="line">  if theme has parents</span><br><span class="line">    parents = theme.parents</span><br><span class="line"></span><br><span class="line">  for parent in parents &#123;</span><br><span class="line">    filename = FindIconHelper (icon, size, scale, parent)</span><br><span class="line">    if filename != none</span><br><span class="line">      return filename</span><br><span class="line">  &#125;</span><br><span class="line">  return none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下辅助函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LookupIcon (iconname, size, scale, theme) &#123;</span><br><span class="line">  for each subdir in $(theme subdir list) &#123;</span><br><span class="line">    for each directory in $(basename list) &#123;</span><br><span class="line">      for extension in (&quot;png&quot;, &quot;svg&quot;, &quot;xpm&quot;) &#123;</span><br><span class="line">        if DirectoryMatchesSize(subdir, size, scale) &#123;</span><br><span class="line">          filename = directory/$(themename)/subdir/iconname.extension</span><br><span class="line">          if exist filename</span><br><span class="line">	    return filename</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  minimal_size = MAXINT</span><br><span class="line">  for each subdir in $(theme subdir list) &#123;</span><br><span class="line">    for each directory in $(basename list) &#123;</span><br><span class="line">      for extension in (&quot;png&quot;, &quot;svg&quot;, &quot;xpm&quot;) &#123;</span><br><span class="line">        filename = directory/$(themename)/subdir/iconname.extension</span><br><span class="line">        if exist filename and DirectorySizeDistance(subdir, size, scale) &lt; minimal_size &#123;</span><br><span class="line">	   closest_filename = filename</span><br><span class="line">	   minimal_size = DirectorySizeDistance(subdir, size, scale)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if closest_filename set</span><br><span class="line">     return closest_filename</span><br><span class="line">  return none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LookupFallbackIcon (iconname) &#123;</span><br><span class="line">  for each directory in $(basename list) &#123;</span><br><span class="line">    for extension in (&quot;png&quot;, &quot;svg&quot;, &quot;xpm&quot;) &#123;</span><br><span class="line">      if exists directory/iconname.extension</span><br><span class="line">        return directory/iconname.extension</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectoryMatchesSize(subdir, iconsize, iconscale) &#123;</span><br><span class="line">  read Type and size data from subdir</span><br><span class="line">  if Scale != iconscale</span><br><span class="line">     return False;</span><br><span class="line">  if Type is Fixed</span><br><span class="line">    return Size == iconsize</span><br><span class="line">  if Type is Scaled</span><br><span class="line">    return MinSize &lt;= iconsize &lt;= MaxSize</span><br><span class="line">  if Type is Threshold</span><br><span class="line">    return Size - Threshold &lt;= iconsize &lt;= Size + Threshold</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectorySizeDistance(subdir, iconsize, iconscale) &#123;</span><br><span class="line">  read Type and size data from subdir</span><br><span class="line">  if Type is Fixed</span><br><span class="line">    return abs(Size*Scale - iconsize*iconscale)</span><br><span class="line">  if Type is Scaled</span><br><span class="line">    if iconsize*iconscale &lt; MinSize*Scale</span><br><span class="line">        return MinSize*Scale - iconsize*iconscale</span><br><span class="line">    if iconsize*iconscale &gt; MaxSize*Scale</span><br><span class="line">        return iconsize*iconscale - MaxSize*Scale</span><br><span class="line">    return 0</span><br><span class="line">  if Type is Threshold</span><br><span class="line">    if iconsize*iconscale &lt; (Size - Threshold)*Scale</span><br><span class="line">        return MinSize*Scale - iconsize*iconscale</span><br><span class="line">    if iconsize*iconsize &gt; (Size + Threshold)*Scale</span><br><span class="line">        return iconsize*iconsize - MaxSize*Scale</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在某些情况下，您并不总是希望退回到继承主题中的图标。例如，有时您会寻找一组图标，在使用继承主题中的图标之前更喜欢其中的任何一个。为了支持此类操作，实现可以包含一个函数，该函数在继承层次结构中查找图标名称列表的第一个.它看起来像这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FindBestIcon(iconList, size, scale) &#123;</span><br><span class="line">  filename = FindBestIconHelper(iconList, size, scale, user selected theme);</span><br><span class="line">  if filename != none</span><br><span class="line">    return filename</span><br><span class="line"></span><br><span class="line">  filename = FindBestIconHelper(iconList, size, scale, &quot;hicolor&quot;);</span><br><span class="line">  if filename != none</span><br><span class="line">    return filename</span><br><span class="line"></span><br><span class="line">  for icon in iconList &#123;</span><br><span class="line">    filename = LookupFallbackIcon (icon)</span><br><span class="line">    if filename != none</span><br><span class="line">      return filename</span><br><span class="line">  &#125;</span><br><span class="line">  return none;</span><br><span class="line">&#125;</span><br><span class="line">FindBestIconHelper(iconList, size, scale, theme) &#123;</span><br><span class="line">  for icon in iconList &#123;</span><br><span class="line">    filename = LookupIcon (icon, size, theme)</span><br><span class="line">    if filename != none</span><br><span class="line">      return filename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if theme has parents</span><br><span class="line">    parents = theme.parents</span><br><span class="line"></span><br><span class="line">  for parent in parents &#123;</span><br><span class="line">    filename = FindBestIconHelper (iconList, size, scale, parent)</span><br><span class="line">    if filename != none</span><br><span class="line">      return filename</span><br><span class="line">  &#125;</span><br><span class="line">  return none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能非常有用，例如在处理 mimetype 图标时，其中多少都会有一些“特定”版本的图标。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这是一个示例 index.theme 文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Icon Theme]</span></span><br><span class="line"><span class="attr">Name</span>=Birch</span><br><span class="line">Name<span class="section">[sv]</span>=Björk</span><br><span class="line"><span class="attr">Comment</span>=Icon theme with a wooden look</span><br><span class="line">Comment<span class="section">[sv]</span>=Träinspirerat ikontema</span><br><span class="line"><span class="attr">Inherits</span>=wood,default</span><br><span class="line"><span class="attr">Directories</span>=<span class="number">48</span>x48/apps,<span class="number">48</span>x48@<span class="number">2</span>/apps48x48/mimetypes,<span class="number">32</span>x32/apps,<span class="number">32</span>x32@<span class="number">2</span>/apps,scalable/apps,scalable/mimetypes</span><br><span class="line"></span><br><span class="line"><span class="section">[scalable/apps]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">48</span></span><br><span class="line"><span class="attr">Type</span>=Scalable</span><br><span class="line"><span class="attr">MinSize</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">MaxSize</span>=<span class="number">256</span></span><br><span class="line"><span class="attr">Context</span>=Applications</span><br><span class="line"></span><br><span class="line"><span class="section">[scalable/mimetypes]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">48</span></span><br><span class="line"><span class="attr">Type</span>=Scalable</span><br><span class="line"><span class="attr">MinSize</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">MaxSize</span>=<span class="number">256</span></span><br><span class="line"><span class="attr">Context</span>=MimeTypes</span><br><span class="line"></span><br><span class="line"><span class="section">[32x32/apps]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">32</span></span><br><span class="line"><span class="attr">Type</span>=Fixed</span><br><span class="line"><span class="attr">Context</span>=Applications</span><br><span class="line"></span><br><span class="line"><span class="section">[32x32@2/apps]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">32</span></span><br><span class="line"><span class="attr">Scale</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">Type</span>=Fixed</span><br><span class="line"><span class="attr">Context</span>=Applications</span><br><span class="line"></span><br><span class="line"><span class="section">[48x48/apps]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">48</span></span><br><span class="line"><span class="attr">Type</span>=Fixed</span><br><span class="line"><span class="attr">Context</span>=Applications</span><br><span class="line"></span><br><span class="line"><span class="section">[48x48@2/apps]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">48</span></span><br><span class="line"><span class="attr">Scale</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">Type</span>=Fixed</span><br><span class="line"><span class="attr">Context</span>=Applications</span><br><span class="line"></span><br><span class="line"><span class="section">[48x48/mimetypes]</span></span><br><span class="line"><span class="attr">Size</span>=<span class="number">48</span></span><br><span class="line"><span class="attr">Type</span>=Fixed</span><br><span class="line"><span class="attr">Context</span>=MimeTypes</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;share&#x2F;icons 目录中相应的目录树可能如下所示：</p>
<blockquote>
<p>birch&#x2F;index.theme<br>birch&#x2F;scalable&#x2F;apps&#x2F;mozilla.svg<br>birch&#x2F;scalable&#x2F;mimetypes&#x2F;mime_text_plain.svg<br>birch&#x2F;scalable&#x2F;mimetypes&#x2F;mime_text_plain.icon<br>birch&#x2F;48x48&#x2F;apps&#x2F;mozilla.png<br>birch&#x2F;48x48@2&#x2F;apps&#x2F;mozilla.png<br>birch&#x2F;32x32&#x2F;apps&#x2F;mozilla.png<br>birch&#x2F;32x32@2&#x2F;apps&#x2F;mozilla.png<br>birch&#x2F;48x48&#x2F;mimetypes&#x2F;mime_text_plain.png<br>birch&#x2F;48x48&#x2F;mimetypes&#x2F;mime_text_plain.icon</p>
</blockquote>
<p>其中 birch&#x2F;scalable&#x2F;mimetypes&#x2F;mime_text_plain.icon 包含：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Icon Data]</span></span><br><span class="line"><span class="attr">DisplayName</span>=Mime text/plain</span><br><span class="line"><span class="attr">EmbeddedTextRectangle</span>=<span class="number">100</span>,<span class="number">100</span>,<span class="number">900</span>,<span class="number">900</span></span><br><span class="line"><span class="attr">AttachPoints</span>=<span class="number">200</span>,<span class="number">200</span>|<span class="number">800</span>,<span class="number">200</span>|<span class="number">500</span>,<span class="number">500</span>|<span class="number">200</span>,<span class="number">800</span>|<span class="number">800</span>,<span class="number">800</span></span><br></pre></td></tr></table></figure>

<p>birch&#x2F;48x48&#x2F;mimetypes&#x2F;mime_text_plain.icon 包含：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Icon Data]</span></span><br><span class="line"><span class="attr">DisplayName</span>=Mime text/plain</span><br><span class="line"><span class="attr">EmbeddedTextRectangle</span>=<span class="number">8</span>,<span class="number">8</span>,<span class="number">40</span>,<span class="number">40</span></span><br><span class="line"><span class="attr">AttachPoints</span>=<span class="number">20</span>,<span class="number">20</span>|<span class="number">40</span>,<span class="number">40</span>|<span class="number">50</span>,<span class="number">10</span>|<span class="number">10</span>,<span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，由于目录的顺序，“mozilla”的查找将在 SVG 图标之前获取预渲染的 48x48 和 32x32 图标。（Icon Theme 中的 Directories 字段定义了查找的目录顺序）</p>
<h1 id="安装应用程序图标"><a href="#安装应用程序图标" class="headerlink" title="安装应用程序图标"></a>安装应用程序图标</h1><p>因此，您是应用程序作者，并且想要安装应用程序图标，以便它们在 KDE 和 Gnome 菜单中工作。至少你应该在 hicolor 主题中安装一个 48x48 的图标。这意味着在 $prefix&#x2F;share&#x2F;icons&#x2F;hicolor&#x2F;48x48&#x2F;apps 中安装一个 PNG 文件。您可以选择安装不同大小的图标。例如，在 $prefix&#x2F;share&#x2F;icons&#x2F;hicolor&#x2F;scalable&#x2F;apps 中安装一个 svg 图标意味着大多数桌面将有一个适用于所有尺寸的图标。您甚至可能希望安装外观与其他知名主题相匹配的图标，以便您的应用程序适合某些特定的桌面环境。</p>
<p>建议安装在 hicolor 主题中的图标看起来是中性的，因为它是一个后备主题，将与一些外观非常不同的主题结合使用。但是，如果您没有任何中性图标，请安装您所拥有的所有的 hicolor 主题图标，以便所有应用程序在所有主题中至少获得一些图标。</p>
<h1 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h1><p>本文档中描述的算法通过始终在目录中查找文件名（unix 术语中的 stat）来工作。一个好的实现应该只读取一次目录，并使用该信息在内存中进行所有查找(例如qt中QIcon的实现)。</p>
<p>这种缓存可能使用户无法在不重新启动应用程序的情况下添加图标。为了处理这个问题，任何执行缓存的实现都需要在执行缓存查找时查看顶级图标目录的最后修改时间，除非它在不到 5 秒前已经这样做了(意味着超过5秒再次获取图标时，应该重新刷新一遍内存中的信息，从而防止图标文件的更新无法及时获取到)。这意味着任何图标编辑器或主题安装程序只需要更改其更改主题的顶级目录的最后修改时间，就可以确保最终能使用到新图标。</p>
]]></content>
      <categories>
        <category>Freedesktop</category>
      </categories>
      <tags>
        <tag>标准</tag>
        <tag>XDG</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见命令的使用</title>
    <url>/2023/024414.html</url>
    <content><![CDATA[<p>基本涵盖了Linux下开发常用的命令，适合刚接触Linux的小伙伴。</p>
<h1 id="fish"><a href="#fish" class="headerlink" title="fish"></a>fish</h1><p><strong>安装</strong></p>
<p><code>sudo apt install  fish</code></p>
<p><strong>概述</strong></p>
<p>命令提示&amp;补全工具</p>
<p><strong>用法</strong><code>fish</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/1.png"
                       
                 ></p>
<p><em>Tips：可以使用方向键→键，直接补全提示的命令</em></p>
<p><strong>Q&amp;A</strong></p>
<p>使用&#x2F;usr&#x2F;bin&#x2F;fish替换现有&#x2F;bin&#x2F;bash（默认）方法：</p>
<p><code>chsh -s /usr/bin/fish</code></p>
<p>想改回 &#x2F;bin&#x2F;bash :</p>
<p><code>chsh -s /bin/bash</code></p>
<p><em>Tips：修改后需要注销才生效</em></p>
<h1 id="qdbus"><a href="#qdbus" class="headerlink" title="qdbus"></a>qdbus</h1><p><strong>概述</strong></p>
<p>基于qt的应用程序通信接口工具，常用于调用 dbus 方法、属性</p>
<p><strong>用法</strong></p>
<p><code>qdbus --session</code>                          &#x2F;&#x2F; 查看当前session所有的service信息</p>
<p><code>qdbus</code> 等同于 <code>qdbus --session</code></p>
<p><code>qdbus --system</code>                           &#x2F;&#x2F; 查看系统级别的所有的service信息</p>
<p><strong>场景</strong></p>
<p>想通过 dbus 把剪贴板打开，但记不清服务名了，依稀记得有个 Clipboard 字段</p>
<p>方法一:安装 d-feet ,查看服务列表，通过 d-feet 进行方法的调用</p>
<p>方法二(<strong>推荐</strong>):</p>
<p><code>qdbus --session | grep Clipboard</code>   &#x2F;&#x2F; 匹配出剪贴板的服务名</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/2.png"
                       
                 ><br>根据印象找到对应的服务应该为 <code>com.deepin.dde.Clipboard</code></p>
<p><code>qdbus com.deepin.dde.Clipboard /</code></p>
<p>利用 qdbus 命令提供的自动补全机制(按 tab 键)得到对应的 path 列表</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/3.png"
                       
                 ><br><code>qdbus com.deepin.dde.Clipboard /com/deepin/dde/Clipboard</code></p>
<p>继续利用 tab 进行命令的补全</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/4.png"
                       
                 ><br>得到完整的命令</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/5.png"
                       
                 ><br>Q&amp;A:<br><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/6.png"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/7.png"
                       
                 ></p>
<h1 id="dbus-monitor"><a href="#dbus-monitor" class="headerlink" title="dbus-monitor"></a>dbus-monitor</h1><p><strong>概述</strong></p>
<p>监听dbus服务接口被调用</p>
<p><strong>用法</strong></p>
<p>&#x2F;&#x2F;监听服务情况,可得知消息触发源,但监听不到属性被调用<br><code>dbus-monitor --session interface=org.freedesktop.Notifications </code></p>
<p>监听信号变化<br><code>dbus-monitor --session &quot;type=&#39;signal&#39;,interface=&#39;org.freedesktop.DBus.Properties&#39;,path=&#39;/com/deepin/dde/daemon/Dock&#39;&quot;</code></p>
<h1 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h1><p><strong>概述</strong></p>
<p>操作dconf的一套高级API，用于管理 dconf 配置</p>
<p><strong>用法</strong></p>
<p>标准用法:<code>gsettings get/set/reset  [schemas]</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/8.png"
                       
                 ></p>
<h1 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h1><p><strong>概述</strong></p>
<p>查询进程的内存映射信息，常用于查看进程运行时链接了哪些动态库</p>
<p><strong>用法</strong></p>
<p><code>pmap -p [pid]</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/8.1.png"
                       
                 ></p>
<h1 id="coredumpctl"><a href="#coredumpctl" class="headerlink" title="coredumpctl"></a>coredumpctl</h1><p><strong>安装</strong></p>
<p><code>sudo apt install systemd-coredump</code></p>
<p><strong>概述</strong></p>
<p>进程崩溃或卡死时的调试神器</p>
<p><strong>介绍</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coredumpctl [OPTIONS...]</span><br><span class="line"></span><br><span class="line">List or retrieve coredumps from the journal.</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h --help              Show this help</span><br><span class="line">     --version           Print version string</span><br><span class="line">     --no-pager          Do not pipe output into a pager</span><br><span class="line">     --no-legend         Do not print the column headers</span><br><span class="line">     --debugger=DEBUGGER Use the given debugger</span><br><span class="line">  -1                     Show information about most recent entry only</span><br><span class="line">  -S --since=DATE        Only print coredumps since the date</span><br><span class="line">  -U --until=DATE        Only print coredumps until the date</span><br><span class="line">  -r --reverse           Show the newest entries first</span><br><span class="line">  -F --field=FIELD       List all values a certain field takes</span><br><span class="line">  -o --output=FILE       Write output to FILE</span><br><span class="line">  -D --directory=DIR     Use journal files from directory</span><br><span class="line"></span><br><span class="line">  -q --quiet             Do not show info messages and privilege warning</span><br><span class="line">Commands:</span><br><span class="line">  list [MATCHES...]  List available coredumps (default)</span><br><span class="line">  info [MATCHES...]  Show detailed information about one or more coredumps</span><br><span class="line">  dump [MATCHES...]  Print first matching coredump to stdout</span><br><span class="line">  debug [MATCHES...] Start a debugger for the first matching coredump</span><br><span class="line"></span><br><span class="line">See the coredumpctl(1) man page for details.</span><br></pre></td></tr></table></figure>

<p><strong>用法</strong></p>
<p>常用命令组合:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coredumpctl list                          // 查看崩溃的进程列表</span><br><span class="line">coredumpctl debug [pid]                   // 调试崩溃进程</span><br><span class="line">coredumpctl info [pid]                    // 查看崩溃进程的堆栈信息</span><br></pre></td></tr></table></figure>



<p>查看崩溃进程列表</p>
<p><code>coredumpctl list</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/9.png"
                       
                 ></p>
<p>查看崩溃进程的堆栈信息</p>
<p><code>coredumpctl debug 26625</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/10.png"
                       
                 ></p>
<p>查看线程1的崩溃堆栈</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/11.png"
                       
                 ></p>
<p>如果你仔细点，应该会看到有一部分的堆栈并没有显示详细的信息，那是因为我们安装调试进程对应的符号包，执行以下命令并重新使用coredumpctl命令进行调试</p>
<p><code>sudo apt install dde-launcher-dbgsym</code></p>
<p>你会发现线程1的第3帧发现了我们熟知的函数，此时我们就可以到代码中进行排查了</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/12.png"
                       
                 ><br><em>Tips：也不一定就是我们代码的问题，理论上每一处都可能出问题，不过一般开发库出问题的概率较低，我们优先从自己的代码进行排查</em></p>
<p>查看所有的线程状态</p>
<p><code>info threads</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/13.png"
                       
                 ></p>
<p>会发现大部分的线程都处在 futex_wait_cancelable 的状态，一般就是阻塞了</p>
<p>切换到线程2,并查看堆栈</p>
<p><code>thread 2</code></p>
<p><code>bt</code><br><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/14.png"
                       
                 ></p>
<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p><strong>概述</strong></p>
<p>调试神器，强大地有点过分，开发必备</p>
<p><strong>安装</strong></p>
<p><code>sudo apt install gdb</code></p>
<p><strong>用法</strong></p>
<p>&#x2F;&#x2F; 调试正在运行的进程</p>
<p><code>sudo gdb -p [pid]</code></p>
<p><code>sudo gdb -p </code>pidof dde-dock&#96;&#96;</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/15.png"
                       
                 ><br>&#x2F;&#x2F; 如果此时应用卡住了(可以理解为应用执行到了某一行<strong>代码&#x2F;堆栈</strong>就停住了)</p>
<p>在gdb页面输入bt查看堆栈信息</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/16.png"
                       
                 ><br>这里一般只会显示一个线程的信息，有时候我们不确定是哪个线程卡死了</p>
<p>可以用<code>info threads</code>查看线程信息，并使用<code>thread [index]</code>切换到对应线程，再执行 bt 查看当前线程堆栈(可以用当前系统中实际运行的进程验证)。</p>
<p>(已经在 coredumpctl 章节介绍过 gdb 的部分命令了，其余的自行了解。我们不应该假定客户的电脑允许我们安装 qtcreator 或 vscode ,甚至可能不被允许重启异常的进程)</p>
<p><strong>用真实的卡死进程进行展示:</strong></p>
<p>新建test.c文件，内容如下:</p>
<blockquote>
<p>#include “stdio.h”<br>int main () {<br>    for (int i &#x3D; 0; i &lt; 10; ++i) {<br>        if (i &#x3D;&#x3D; 5) {<br>            while(1);<br>        }<br>        printf(“%d\n”, i);<br>    }<br>}</p>
</blockquote>
<p>静态编译代码，保留代码信息:</p>
<p><code>g++ -g test.c -o test</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/17.png"
                       
                 ></p>
<p>执行当前进程，运行后进程卡死</p>
<p><code>./test</code></p>
<p>调试卡死进程，寻找卡死位置</p>
<p><code>sudo gdb -p </code>pidof test&#96;&#96;</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/18.png"
                       
                 ></p>
<h1 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h1><p><strong>概述</strong></p>
<p>查看内核日志，显示开机信息</p>
<p><strong>用法</strong></p>
<p>显示和内存、硬盘、USB、TTY相关的信息</p>
<p><code>sudo dmesg | grep -E &quot;memory|dma|usb|tty&quot;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/19.png"
                       
                 ></p>
<p>实时查看内核日志,方便查看系统异常进程</p>
<p><code>sudo dmesg -w</code></p>
<p><em>Tips：当系统碰到一些硬件或者驱动相关的问题，可以使用dmesg命令辅助定位问题</em></p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p><strong>概述</strong></p>
<p>查看内存占用、进程id等信息</p>
<p><strong>用法</strong></p>
<p>普通的用法就是在终端中直接执行 top 命令，将会按照某种顺序列出系统中所有的进程信息</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/20.png"
                       
                 ></p>
<p><code>top -p [PID]</code></p>
<p>top 是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/21.png"
                       
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/22.png"
                       
                 ></p>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p><strong>安装</strong></p>
<p><code>sudo apt install htop</code></p>
<p><strong>用法</strong></p>
<p>使用 htop 查看进程占用的资源信息，按 F4 进如筛选模式，可输入想查看的进程名进行匹配，如: dde-dock</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/23.png"
                       
                 ></p>
<h1 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h1><p><strong>概述</strong></p>
<p>查看进程的PID</p>
<p><strong>用法</strong></p>
<p>比较简单，直接看下图:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/24.png"
                       
                 ><br><strong>场景</strong></p>
<p><code>pkill dde-lock</code></p>
<p>将尝试杀死 dde-lock 开头的所有进程，这里系统中存在一个 root 进程 dde-lockservice ，因此会被误杀(不过因为权限不足，会提示不允许)</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/25.png"
                       
                 ></p>
<p>我们换一种方式，指定杀死对应的进程</p>
<p><code>kill -9 `pidof dde-lock` </code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/26.png"
                       
                 ></p>
<h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p><strong>概述</strong></p>
<p>默认将指定文件的最后10行打印到标准输出</p>
<p><strong>用法</strong></p>
<p>使用 -f 参数可实时查看日志文件内容的变化</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/27.png"
                       
                 ></p>
<p>也可指定实时输出最后20行:</p>
<p><code>sudo tail -f -n 20  /var/log/auth.log</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/28.png"
                       
                 ></p>
<p>如果不加 -f 参数，则不具有实时效果</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p><strong>概述</strong></p>
<p>tail 是尾巴，head 是头，我想这个命令的作用大家应该猜出来了</p>
<p><strong>用法</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/29.png"
                       
                 ></p>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p><strong>用法</strong></p>
<p>使用 less 打开文件，支持高亮搜索内容</p>
<p><code>sudo less /var/log/auth.log</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/30.png"
                       
                 ></p>
<p>按&#x2F;键进入搜索模式，输入”error”</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/31.png"
                       
                 ></p>
<p>v : 进入编辑模式，使用配置的编辑器编辑当前文件</p>
<p>F:进入 tail -f 模式</p>
<p>n : 向前查找下一个匹配的文本</p>
<p>N : 向后查找前一个匹配的文本</p>
<p>(是不是发现和 vim 命令类似了)</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p><strong>概述</strong></p>
<p>按页显示，了解 less 其实就够用了，可以不看。</p>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p><strong>概述</strong></p>
<p>编辑工具，但我们也经常用来查看日志，尤其是在远程定位问题的时候</p>
<p><strong>用法</strong></p>
<p>我们用 cat 也可以查看文件，但当文件内容太多的时候，不方便定位某一处的文件内容</p>
<p><code>sudo vim /var/log/auth.log</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/32.png"
                       
                 ></p>
<p>内容太多，我只想在其中找到”error”相关的日志</p>
<p>1、先按 esc ，进入命令交互模式</p>
<p>2、输入”&#x2F;“ + “error”</p>
<p>3、回车确认所搜结果</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/33.png"
                       
                 ></p>
<p>按 n 显示下一处匹配的内容</p>
<p>shift+n 显示上一处</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/34.png"
                       
                 ></p>
<p><em>Tips：在命令交互区域输入:set number可以显示文件行号</em></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p><strong>概述</strong></p>
<p>查看文件内容</p>
<p><strong>用法</strong></p>
<p>查看文件内容</p>
<p><code>cat 1.txt</code></p>
<p>还可以用于文件内容的合并</p>
<p><code>cat 1.txt 2.txt &gt;&gt; 3.txt</code></p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p><strong>概述</strong></p>
<p>定时执行命令</p>
<p><strong>场景</strong></p>
<p>使用 rfkill 命令对无线设备上锁或解锁时，其锁定状态保存在内核文件中。</p>
<p>例如蓝牙的 soft block 的状态保存在 &#x2F;sys&#x2F;class&#x2F;rfkill&#x2F;rfkill0&#x2F;soft 文件中，当我们用 unblock 解锁的时候，理论上可以看到这个文件变为0</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/35.png"
                       
                 ></p>
<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p><strong>概述</strong></p>
<p>系统定时服务</p>
<p><strong>安装</strong></p>
<p><code>sudo apt install cron</code></p>
<p><strong>用法</strong></p>
<p>可以用来帮助实现一些定时操作，比如每周一到周五的下午6点让电脑爆炸（对应命令为let it boom）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[uos@uos-PC 17:29:14 ~]<span class="variable">$crontab</span> -h</span><br><span class="line">crontab: 不适用的选项 -- h</span><br><span class="line">crontab: usage error: unrecognized option</span><br><span class="line">usage:  crontab [-u user] file</span><br><span class="line">        crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br><span class="line">                (default operation is replace, per 1003.2)</span><br><span class="line">        -e      (edit user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">        -l      (list user&#x27;</span>s crontab)</span><br><span class="line">        -r      (delete user<span class="string">&#x27;s crontab)</span></span><br><span class="line"><span class="string">        -i      (prompt before deleting user&#x27;</span>s crontab)</span><br></pre></td></tr></table></figure>

<p>编辑模式:<br><code>crontab -e</code><br>第一次进入会让你选择编辑器，挑自己熟悉的来即可</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/72.png"
                       
                 ></p>
<p>查看模式<br><code>crontab -l</code><br>让我们来实现爆炸的定时功能<br>进入编辑模式<br>在文件的最后添加如下内容，保存退出即可<br><code>0 17 * * 1 &quot;let it boom&quot;</code></p>
<p>(解释下上面的字段:<br>0:表示分钟为0的时候<br>17:下午5点<br>*:一个月的任意一天，你也可以写1<del>31的任意一个数字<br>*:任意一个月，你可以写1</del>12的任意一个数字<br>1-5:一周的1-5天，即周一到周五，也可直接写1,表示周一<br>“let it boom”: 上述时间条件满足后，要触发的命令 。<strong>要注意的是，这里的命令要写绝对路径</strong>，比如写”&#x2F;usr&#x2F;bin&#x2F;echo 123”而不是写”echo 123”)</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/73.png"
                       
                 ></p>
<p>保存后使用 <code>crontab -l</code> 查看</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/74.png"
                       
                 ></p>
<p>查看 crontab 服务运行情况和任务的执行情况:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/75.png"
                       
                 ></p>
<p><em>Tips: 如果服务状态为 inactive，我想你应该先看下 systemctl 命令的介绍</em></p>
<h1 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h1><p><strong>概述</strong></p>
<p>通过快速差分算法,能够高效进行文件传输的程序</p>
<p><strong>用法</strong></p>
<p>将dir1文件夹中的内容复制到dir2中<br><code>rsync -av dir1/ dir2/</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/76.png"
                       
                 ></p>
<p>当dir1中新增一些文件中，如果我们想同步到dir2中，如果使用 <code>cp -r</code> 命令，会将之前已经同步的文件再复制一次，效率比较低。<br>此时可以再次执行 <code>rsync -av dir1/ dir2/</code>，只会进行增量拷贝，速度较快，当文件夹体积过大时，这种对比尤为明显。</p>
<p>rsync同样支持机器之间内容的转移，用法和ssh类似</p>
<p>讲远程机器桌面上的source.txt文件拷贝到当前目录</p>
<p><code>rsync -av uos@10.20.43.195:~/Desktop/source.txt ./</code></p>
<p>感兴趣的可以私下研究下下面两个练习题:<br>1、使用rsync + crond实现定时备份<br>2、使用rsync+inotify实现自动备份</p>
<p><em>Tips:</em><br><em>1、传统的 cp，scp 工具拷贝每次均为完整拷贝，而 rsync 除了完整拷贝，还具备增量拷贝的功能，因此从此性能及效率上更胜一筹。</em><br><em>2、man 手册里有大量的使用示例</em></p>
<h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p><strong>概述</strong></p>
<p>用于 Linux 之间复制文件和目录</p>
<p><strong>用法</strong></p>
<p>复制文件命令格式</p>
<p><code>scp local_file remote_username@remote_ip:remote_folder </code></p>
<p><code>scp local_file remote_username@remote_ip:remote_file </code></p>
<p>复制目录命令格式</p>
<p><code>scp -r local_folder remote_username@remote_ip:remote_folder </code></p>
<p><code>scp -r local_folder remote_ip:remote_folder </code></p>
<p>记得先打开ssh服务</p>
<p><code>systemctl enable ssh.service  --now</code></p>
<p>第一次使用 scp 传输内容，需要输入对应用户的密码</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/50.png"
                       
                 ></p>
<p><code>scp uos@10.20.6.139:~/Desktop/1.txt ./1.txt</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/51.png"
                       
                 ></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="apt-file"><a href="#apt-file" class="headerlink" title="apt-file"></a>apt-file</h1><p><strong>概述</strong></p>
<p>从apt仓库中搜索存在指定文件的的package</p>
<p><strong>安装</strong></p>
<p><code>sudo apt install apt-file</code></p>
<p><strong>用法</strong></p>
<p>更新 source 中的缓存信息:</p>
<p><code>sudo apt-file update</code></p>
<p>查看哪些包中的文件(或文件的安装路径)包含了 dde-dock 字段</p>
<p><code>apt-file search dde-dock</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/36.png"
                       
                 ></p>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p><strong>概述</strong></p>
<p>定位电脑上某个文件所在位置，优点是比较快</p>
<p><strong>安装</strong></p>
<p><code>sudo apt install locate</code></p>
<p><strong>用法</strong></p>
<p>locate 与 find 不同, find 是去硬盘找，locate 只在 &#x2F;var&#x2F;lib&#x2F;slocate 资料库中找。locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 &#x2F;var&#x2F;lib&#x2F;slocate&#x2F;slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为:</p>
<p><code>updatedb</code></p>
<p>默认情况下 updatedb 每天执行一次。</p>
<p><code>locate dde-dock.log</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/37.png"
                       
                 ><br><code>find . -name dde-dock.log</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/38.png"
                       
                 ></p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><strong>概述</strong></p>
<p>从指定路径查看文件</p>
<p><strong>用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[16:13:49] uos :: uos-PC  ➜  ~ » find /usr/bin -name &quot;dde-dock&quot;</span><br><span class="line">/usr/bin/dde-dock</span><br></pre></td></tr></table></figure>



<h1 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h1><p><strong>概述</strong></p>
<p>Debian包管理器</p>
<p><strong>用法</strong></p>
<p>查询系统中某个文件所属的包</p>
<p><code>dpkg -S /usr/lib/dde-dock/plugins/system-trays/libsound.so</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/39.png"
                       
                 ><br><code>dpkg -L</code> 查看已安装的某个包中包含的文件列表</p>
<p><code>dpkg -L d-feet</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/40.png"
                       
                 ><br><code>dpkg-deb -c dde-session-shell_5.5.93_arm64.deb</code> &#x2F;&#x2F; 查看 deb 文件中包含的文件</p>
<p>解压指定deb文件到当前目录下的tmp文件夹</p>
<p><code>dpkg -X dde-session-shell_5.5.93_arm64.deb ./tmp</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[16:23:51] uos :: uos-PC  ➜  ~/Desktop » dpkg -X dde-session-shell_5.5.93_arm64.deb ./tmp</span><br><span class="line">./</span><br><span class="line">./etc/</span><br><span class="line">./etc/deepin/</span><br><span class="line">./etc/deepin/greeters.d/</span><br><span class="line">./etc/deepin/greeters.d/00-xrandr</span><br><span class="line">./etc/deepin/greeters.d/10-cursor-theme</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>安装软件包</p>
<p><code>dpkg -i dde-session-shell_5.5.93_arm64.deb</code> </p>
<p>安装软件包，忽略依赖关系(及时依赖不满足仍然会安装)</p>
<p><code>dpkg --force-depends -i debpackage</code> </p>
<p>卸载软件包</p>
<p><code>dpkg -r debpackage</code> </p>
<p>彻底卸载软件包</p>
<p><code>dpkg -p debpackage</code> </p>
<p>查询系统中软件包的安装情况</p>
<p><code>dpkg -l |grep dde-session-shell</code> </p>
<p>查看平台的架构类型</p>
<p><code>dpkg --print-architecture</code> </p>
<h1 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h1><p><strong>概述</strong></p>
<p>相比 dpkg ,更侧重于用户的交互</p>
<p><strong>用法</strong></p>
<p>下载软件包的源码</p>
<p><code>apt source dde-dock </code></p>
<p>查看软件包的信息</p>
<p><code>apt-cache show dde-dock</code></p>
<p>下载软件包</p>
<p><code>apt download dde-dock </code></p>
<h1 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h1><p><strong>概述</strong></p>
<p>打印文件中可打印字符串</p>
<p><strong>用法</strong></p>
<p>strings 命令是二进制工具集 GNU Binutils 的一员，用于打印文件中可打印字符串， strings 命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。strings 命令对识别随机对象文件很有用。</p>
<p><code>cat /proc/self/environ | strings </code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/41.png"
                       
                 ></p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><strong>概述</strong></p>
<p>查找文件里符合条件的字符串</p>
<p>越常见的命令越是隐藏着更多的功能，这里也只介绍常用功能，具体的见 man 手册</p>
<p><strong>用法</strong></p>
<p><code>cat .cache/deepin/dde-launcher/dde-launcher.log | grep &quot;gsettings&quot;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/42.png"
                       
                 ></p>
<p>查找当前文件夹下中所有文件哪个文件中出现了 “dde-dock” 的字符串</p>
<p><code>grep -rn &quot;dde-dock&quot; .cache/</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/43.png"
                       
                 ></p>
<p>找是找到了，就是辣鸡信息太多，把这部分过滤掉，用到了 grep 的 -v 参数，继续往下看</p>
<p><code>grep -rn &quot;dde-dock&quot; .cache/ | grep -v &quot;匹配&quot;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/44.png"
                       
                 ></p>
<p>常用于检索日志中某些关键字，如:<code>grep &quot;CPU&quot;  *.log  -rn</code> 遍历当前文件下文件名后缀为 .log 的文件，其中包含 “CPU” 关键字的行，并输出关键字所在的行号。见下面示例:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/45.png"
                       
                 ></p>
<p><code>grep -i </code>忽略大小写进行匹配</p>
<p><code>grep -E [pattern]</code> 使用正则表达式进行匹配</p>
<p><code>sudo cat /var/log/auth.log | grep -i deepin_AUTH | grep -E &quot;验证|人脸&quot;</code></p>
<p><code>ps -eo lstart,etime,cmd | grep -E &#39;dde-dock|startdde&#39;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/46.png"
                       
                 ></p>
<p><em>Tips:fish的一个好处就是可以高亮匹配上的关键字</em></p>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><strong>概述</strong></p>
<p>文本处理工具</p>
<p><strong>用法</strong></p>
<p>输出 dde-session-daemon 进程的 pid</p>
<p><code>ps aux | grep dde-session-daemon | grep -v grep | awk &#39;&#123;print $2&#125;&#39;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/47.png"
                       
                 ></p>
<p><em>Tips：这个命令的命名比较有意思，感兴趣的可以查阅下，为啥叫 awk</em></p>
<h1 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h1><p><strong>概述</strong></p>
<p>给命令设置一个别名</p>
<p><strong>用法</strong></p>
<p>精简打包命令:</p>
<p>1、编辑  ~&#x2F;.bashrc 文件，在文件最后新增一行:</p>
<p><code>alias db=&quot;dpkg-buildpackage  -us -uc -nc -j8&quot;</code></p>
<p>2、退出并保存</p>
<p>3、<code>source ~/.bashrc</code>   使文件内容生效</p>
<p>4、以后再打包，直接输入 db 即可</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/48.png"
                       
                 ></p>
<p>更新shell默认的提示信息:</p>
<p>其实就是一个终端相关的环境变量，在 ~&#x2F;.bashrc 文件中新增如下行即可</p>
<p><code>export PS1=&quot;\[\e[37;10m\][\[\e[32;10m\]\u\[\e[37;10m\]@\h \t \[\e[36;10m\]\w\[\e[0m\]]\$&quot;</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/49.png"
                       
                 ></p>
<h1 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h1><p><strong>概述</strong></p>
<p>查询 systemd-journald 服务收集到的日志</p>
<p><strong>用法</strong></p>
<p>查询网络日志</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/52.png"
                       
                 ></p>
<p>查询内核日志</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/53.png"
                       
                 ></p>
<p>查看 startdde 的日志(一般用来分析 startdde 启动后按照什么顺序启动 dde-kwin,dde-session-daemon 和 dde-dock 的)</p>
<p><code>journalctl -b /usr/bin/startdde</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/54.png"
                       
                 ></p>
<p>查询指定进程的日志</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/54.1.png"
                       
                 ></p>
<h1 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h1><p><strong>概述</strong></p>
<p>查询或管理systemd服务的状态</p>
<p><strong>用法</strong></p>
<p>查询 systemd 管理的几种单元类型</p>
<p><code>systemctl --type=help</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/55.png"
                       
                 ></p>
<p>对应单元的列表</p>
<p><code>systemctl --type=service</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/56.png"
                       
                 ></p>
<p>列出所有单元及其状态</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/57.png"
                       
                 ></p>
<p>筛选 ssh 服务</p>
<p><code>systemctl --type=service | grep ssh</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/58.png"
                       
                 ></p>
<p>查询 ssh 服务的状态</p>
<p><code>systemctl status ssh.service</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/59.png"
                       
                 ></p>
<p>关闭 ssh 服务</p>
<p><code>systemctl stop ssh.service</code></p>
<p>开启 ssh 服务</p>
<p><code>systemctl start ssh.service</code></p>
<p><em>Tips:</em></p>
<p><em>系统级别单元文件路径: <code>/etc/systemd/system/</code>、<code>/usr/lib/systemd/system</code></em></p>
<p>*用户级别单元文件路径:<code>/etc/systemd/user/</code>、<code>/usr/lib/systemd/user*</code></p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p><strong>概述</strong></p>
<p>远程登录</p>
<p><strong>用法</strong></p>
<p>远程登录账户</p>
<p><code>ssh root@192.168.235.22</code></p>
<p>登录后可像操控自己的本地机器一样操控远端的机器</p>
<p><strong>Q&amp;A</strong></p>
<p>碰到以下情况时，可执行<code>ssh-keygen -A</code>或<code>ssh-keygen -R 10.20.43.195</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f <span class="string">&quot;/home/uos/.ssh/known_hosts&quot;</span> -R <span class="string">&quot;10.20.43.11&quot;</span></span><br><span class="line">ECDSA host key <span class="keyword">for</span> 10.20.43.11 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>



<h1 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h1><p><strong>概述</strong></p>
<p>修改分区表</p>
<p><strong>用法</strong></p>
<p>列出分区信息<br><code>sudo fdisk -l</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/60.png"
                       
                 ></p>
<h2 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h2><p><strong>概述</strong></p>
<p>列出所有的块设备</p>
<p><strong>用法</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/61.png"
                       
                 ></p>
<h2 id="mount-amp-umount"><a href="#mount-amp-umount" class="headerlink" title="mount&amp;umount"></a>mount&amp;umount</h2><p><strong>概述</strong></p>
<p>挂载设备与取消挂载</p>
<p><strong>用法</strong></p>
<p>插上 u 盘试一下<br><code>sudo fdisk -l</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/62.png"
                       
                 ></p>
<p>得到u盘对应的设备文件为 &#x2F;dev&#x2F;sda ,取消u盘的挂载<br><code>umount /dev/sda</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/63.png"
                       
                 ></p>
<p>格式化 u 盘为 ext4 (关联3中还包含了其他格式的格式化命令，用法基本相同)<br><code>sudo mkfs.ext4 /dev/sda</code><br>等待命令执行完成即可</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/64.png"
                       
                 ></p>
<p>此时再挂载 u 盘到对应的目录(这里是挂载到 &#x2F;media&#x2F;uos 目录中)</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/65.png"
                       
                 ></p>
<h2 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h2><p><strong>概述</strong></p>
<p>格式化文件系统</p>
<p><strong>用法</strong></p>
<p>文件系统的格式众多，对应的格式化命令也很多，我们只需要知道常用的即可，下面的命令大致了解即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.bfs       mkfs.exfat     mkfs.ext4      mkfs.msdos     mkfs.reiserfs  </span><br><span class="line">mkfs.btrfs     mkfs.ext2      mkfs.fat       mkfs.nilfs2    mkfs.vfat      </span><br><span class="line">mkfs.cramfs    mkfs.ext3      mkfs.minix     mkfs.ntfs      mkfs.xfs</span><br></pre></td></tr></table></figure>



<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p><strong>概述</strong></p>
<p>列出文件系统的整体磁盘使用量</p>
<p><strong>用法</strong></p>
<p><code>df </code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/66.png"
                       
                 ></p>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p><strong>概述</strong></p>
<p>查看磁盘使用量</p>
<p><strong>用法</strong></p>
<p><code>du .</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/67.png"
                       
                 ></p>
<h1 id="pkill-amp-killall"><a href="#pkill-amp-killall" class="headerlink" title="pkill &amp; killall"></a>pkill &amp; killall</h1><p><strong>概述</strong></p>
<p>杀死进程</p>
<p><strong>用法</strong></p>
<p><code>pkill dde-dock</code><br><code>killall dde-dock</code></p>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><p><strong>概述</strong></p>
<p>按照名称返回查找的进程ID</p>
<p><strong>用法</strong><br><code>pgrep startdde</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/68.png"
                       
                 ></p>
<p>会输出以startdde开头的进程的pid</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/69.png"
                       
                 ></p>
<h1 id="xprop"><a href="#xprop" class="headerlink" title="xprop"></a>xprop</h1><p><strong>概述</strong></p>
<p>显示指定窗口的 X 属性信息</p>
<p><strong>用法</strong></p>
<p>直接在终端中运行该命令，鼠标会变为十字光标，此时点击你要查看的窗口，终端中会输出此窗口的信息。<br>以任务栏界面为例:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/70.png"
                       
                 ></p>
<p>问题1:为什么应用最大化时不会不会遮盖住任务栏呢<br>这里要看下上图中的 _NET_WM_STRUT_PARTIAL 属性，它描述了任务栏所在的区域，窗管会根据任务栏的这个窗口属性，将普通窗口最大化时，让其·<strong>避开</strong>·此区域。<br><code>_NET_WM_STRUT_PARTIAL(CARDINAL) = 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 1919</code><br>问题2:为什么是任务栏，窗管为什么不根据其他应用的这个属性去管理应用最大化的行为<br>将上图的内容往下翻:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/71.png"
                       
                 ></p>
<p>注意这一行:<br><code>_NET_WM_WINDOW_TYPE(ATOM) = _NET_WM_WINDOW_TYPE_DOCK</code></p>
<p>这里其实就表明 dde-dock 的身份，是作为一个 DOCK 类型的窗口 ，观察其他应用，会发现只有 dde-dock 的界面是有这个属性的，从而让窗管得知。(更具体的看下面的链接)</p>
<p>通过 xprop 我们可以获取到窗口的很多信息，比如窗口标题、窗口图标、是否支持最大化等</p>
<p>关联1—窗口属性介绍</p>
<p>篇幅较多，有单独的文档进行介绍，见<a href="https://ssk-wh.github.io/2022/0948202.html">《Linux窗口属性介绍》</a></p>
<h2 id="xwininfo"><a href="#xwininfo" class="headerlink" title="xwininfo"></a>xwininfo</h2><p><strong>概述</strong></p>
<p>获取和显示指定窗口的信息，用法和功能都类似xprop</p>
<h1 id="rfkill"><a href="#rfkill" class="headerlink" title="rfkill"></a>rfkill</h1><p><strong>概述</strong></p>
<p>radio frequency kill的简写,用于管理无线电设备的软件状态(蓝牙、WIFI、GPS等)。可使某个设备处于可被软件重新激活的状态（ 软锁定 &#x2F;soft block ）或软件无法重新激活的状态（ 硬锁定 &#x2F;hard block）</p>
<p>硬锁定&#x2F;硬件锁定&#x2F;硬锁：这种方式被锁定的设备，是无法通过软件手段开启的，大家对照下笔记本的F1~F12快捷键，一般都会有一个无线网的快捷键，按了之后，无线网就无法使用了(无法通过软件手段开启)，除非再按一次，这就是 hard block (有的笔记本支持通过软件方式开启，是因为其实现方式是soft block而非hard block)。</p>
<p><strong>用法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[18:37:35] uos :: uos-PC  ➜  ~ » rfkill --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> rfkill [options] <span class="built_in">command</span> [identifier ...]</span><br><span class="line"></span><br><span class="line">Tool <span class="keyword">for</span> enabling and disabling wireless devices.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -J, --json             use JSON output format</span><br><span class="line"> -n, --noheadings       don<span class="string">&#x27;t print headings</span></span><br><span class="line"><span class="string"> -o, --output &lt;list&gt;    define which output columns to use</span></span><br><span class="line"><span class="string">     --output-all       output all columns</span></span><br><span class="line"><span class="string"> -r, --raw              use the raw output format</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> -h, --help             display this help</span></span><br><span class="line"><span class="string"> -V, --version          display version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available output columns:</span></span><br><span class="line"><span class="string"> DEVICE      kernel device name</span></span><br><span class="line"><span class="string"> ID          device identifier value</span></span><br><span class="line"><span class="string"> TYPE        device type name that can be used as identifier</span></span><br><span class="line"><span class="string"> TYPE-DESC   device type description</span></span><br><span class="line"><span class="string"> SOFT        status of software block</span></span><br><span class="line"><span class="string"> HARD        status of hardware block</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Commands:</span></span><br><span class="line"><span class="string"> help</span></span><br><span class="line"><span class="string"> event</span></span><br><span class="line"><span class="string"> list   [identifier]</span></span><br><span class="line"><span class="string"> block   identifier</span></span><br><span class="line"><span class="string"> unblock identifier</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more details see rfkill(8)</span></span><br></pre></td></tr></table></figure>

<p>常用命令就是上面列表的后三个</p>
<p>使用命令 <code>rfkill list</code> 获得设备列表，每个都包含与之关联的索引号 ，从 0 开始</p>
<p><code>rfkill list</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/77.png"
                       
                 ></p>
<p>这里可以看出蓝牙的索引为0,无线网卡的索引为1</p>
<p>如果我们对蓝牙设备开启软锁定，可以使用如下命令</p>
<p><code>rfkill block 0</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/78.png"
                       
                 ></p>
<p>这个时候打开你熟悉的控制中心，会发现蓝牙打不开了</p>
<p>如果要解锁，就执行</p>
<p><code>rfkill unblock 0</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/79.png"
                       
                 ></p>
<p>其他设备同理，只是需要你更换一下设备对应的索引号(注意，索引号并不是一成不变的，可以会随设备的变化而变化，只不过每次都是从0开始)</p>
<p>也可以用 all 代代替索引，表示所有的设备</p>
<p><code>rfkill block/unblock all</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/80.png"
                       
                 ></p>
<p>监听 rfkill 事件<br><code>rfkill event</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/81.png"
                       
                 ></p>
<p><em>Tips:</em><br><em>1、uos的飞行模式就通过 rfkill 来实现的哦</em><br><em>2、rfkill 的状态保存在对应的内核文件中，位于 &#x2F;sys&#x2F;class&#x2F;rfkill&#x2F; 目录</em></p>
<h1 id="xdg-open"><a href="#xdg-open" class="headerlink" title="xdg-open"></a>xdg-open</h1><p><strong>概述</strong></p>
<p>使用默认程序打开文件</p>
<p><strong>用法</strong></p>
<p>在终端中输入<code>xdg-open </code>‘就可以使用文管打开当前的文件夹了</p>
<p>终端输入<code>xdg-open a.txt</code>就会在文本编辑器中打开 a.txt ，对于音频、视频以及各类文档都有效。</p>
<p><em>Tips：是不是可以用来验证默认程序设置是否生效呀。</em></p>
<h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p><strong>概述</strong></p>
<p>打印程序或者库文件所依赖的共享库列表</p>
<p><strong>用法</strong></p>
<p> ldd 不是一个可执行程序，而只是一个 shell 脚本。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/81.1.png"
                       
                 ></p>
<p>ldd能够显示可执行模块的 dependency ，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的dependency，而程序并不真正执行。要不你可以在shell终端测试一下，如下：</p>
<p>export LD_TRACE_LOADED_OBJECTS&#x3D;1</p>
<p>再执行任何的程序，如 ls 等，看看程序的运行结果。</p>
<p>ldd 显示可执行模块的 dependency 的工作原理，其实质是通过 ld-linux.so（elf动态库的装载器）来实现的。我们知道，ld-linux.so 模块会先于 executable 模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so 选择了显示可执行模块的 dependency 。</p>
<p>实际上可以直接执行 ld-linux.so 模块，如：<code>/lib/ld-linux.so.2 --list program</code>（这相当于<code>ldd program</code>） </p>
<h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p><strong>概述</strong><br>Linux pstree(英文全称：display a tree of processes）) 命令将所有进程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本进程为根 ( root )，如</p>
<p>果有指定使用者 id，则树状图会只显示该使用者所拥有的进程。</p>
<p><strong>用法</strong></p>
<p>使用权限：所有使用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]</span><br><span class="line">或</span><br><span class="line">pstree -V</span><br><span class="line">**参数说明**：</span><br><span class="line"></span><br><span class="line">- -a 显示该进程的完整指令及参数, 如果是被记忆体置换出去的进程则会加上括号</span><br><span class="line">- -c 如果有重覆的进程名, 则分开列出（预设值是会在前面加上 *）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[15:28:43] uos :: uos-PC  ➜  ~ » pstree                </span><br><span class="line">systemd─┬─ECAgent───3*[&#123;ECAgent&#125;]</span><br><span class="line">        ├─EasyMonitor</span><br><span class="line">        ├─LocalPropertyRe───7*[&#123;LocalPropertyRe&#125;]</span><br><span class="line">        ....</span><br><span class="line">        ├─ipwatchd</span><br><span class="line">        ├─lightdm─┬─Xorg───57*[&#123;Xorg&#125;]</span><br><span class="line">        │         ├─lightdm─┬─startdde─┬─DeepinAIAssista───12*[&#123;DeepinAIAssista&#125;]</span><br><span class="line">        │         │         │          ├─Typora─┬─Typora───Typora───44*[&#123;Typora&#125;]</span><br><span class="line">        │         │         │          │        ├─Typora───4*[&#123;Typora&#125;]</span><br><span class="line">        │         │         │          │        ├─Typora───28*[&#123;Typora&#125;]</span><br><span class="line">        │         │         │          │        ├─chrome-sandbox───Typora───Typora</span><br><span class="line">        │         │         │          │        └─31*[&#123;Typora&#125;]</span><br><span class="line">        ....</span><br><span class="line">        │         │         │          ├─dde-clipboard───24*[&#123;dde-clipboard&#125;]</span><br><span class="line">        │         │         │          ├─dde-desktop───47*[&#123;dde-desktop&#125;]</span><br><span class="line">        │         │         │          ├─dde-launcher───41*[&#123;dde-launcher&#125;]</span><br><span class="line">        │         │         │          ├─dde-lock───26*[&#123;dde-lock&#125;]</span><br><span class="line">        │         │         │          ├─dde-osd───40*[&#123;dde-osd&#125;]</span><br><span class="line">        │         │         │          ├─dde-polkit-agen───5*[&#123;dde-polkit-agen&#125;]</span><br><span class="line">        │         │         │          ├─dde-printer-hel───9*[&#123;dde-printer-hel&#125;]</span><br><span class="line">        │         │         └─2*[&#123;lightdm&#125;]</span><br><span class="line">        │         └─2*[&#123;lightdm&#125;]</span><br><span class="line">        ├─nmbd</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure>






<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p><strong>概述</strong></p>
<p>用于修改文件或目录的访问权限。它可以更改文件或目录的读、写、执行权限，以及文件或目录的所有权</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/82.png"
                       
                 ></p>
<p><strong>用法</strong></p>
<p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式(八进制数字模式)&#x2F;符号模式指定文件的权限</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/024414/83.png"
                       
                 ></p>
<p>使用权限 : 所有使用者<br>语法<br><code>chmod [-cfvR] [--help] [--version] mode file...</code><br>参数说明<br>mode : 权限设定字串，格式如下 :</p>
<p><code>[ugoa...][[+-=][rwxX]...][,...]</code></p>
<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<p>符号模式</p>
<p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p>
<table>
<thead>
<tr>
<th>who</th>
<th>用户类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>user</td>
<td>文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group</td>
<td>文件所有者所在组</td>
</tr>
<tr>
<td>o</td>
<td>others</td>
<td>所有其他用户</td>
</tr>
<tr>
<td>a</td>
<td>all</td>
<td>所用用户, 相当于 ugo</td>
</tr>
</tbody></table>
<p>operator 的符号模式表:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>为指定的用户类型增加权限</td>
</tr>
<tr>
<td>-</td>
<td>去除指定用户类型的权限</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody></table>
<p>permission 的符号模式表:</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读</td>
<td>设置为可读权限</td>
</tr>
<tr>
<td>w</td>
<td>写</td>
<td>设置为可写权限</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
<td>设置为可执行权限</td>
</tr>
<tr>
<td>X</td>
<td>特殊执行权限</td>
<td>只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td>
</tr>
<tr>
<td>s</td>
<td>setuid&#x2F;gid</td>
<td>当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td>
</tr>
<tr>
<td>t</td>
<td>粘贴位</td>
<td>设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td>
</tr>
</tbody></table>
<p>八进制语法</p>
<p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>权限</th>
<th>rwx</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>读 + 写 + 执行</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>读 + 写</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>读 + 执行</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>只读</td>
<td>r–</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>写 + 执行</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>只写</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>只执行</td>
<td>–x</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>无</td>
<td>—</td>
<td>000</td>
</tr>
</tbody></table>
<p>例如， 765 将这样解释：</p>
<ul>
<li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li>
<li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li>
<li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li>
</ul>
<p><strong>场景</strong><br>将文件 file1.txt 设为所有人皆可读取 :</p>
<p>chmod ugo+r file1.txt</p>
<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<p>chmod a+r file1.txt</p>
<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<p>chmod ug+w,o-w file1.txt file2.txt</p>
<p>为 ex1.py 文件拥有者增加可执行权限:</p>
<p>chmod u+x ex1.py</p>
<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<p>chmod -R a+r *</p>
<p>此外chmod也可以用数字来表示权限如 :</p>
<p>chmod 777 file</p>
<p>语法为：</p>
<p>chmod abc file</p>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p><strong>r&#x3D;4，w&#x3D;2，x&#x3D;1</strong></p>
<ul>
<li>若要 rwx 属性则 4+2+1&#x3D;7；</li>
<li>若要 rw- 属性则 4+2&#x3D;6；</li>
<li>若要 r-x 属性则 4+1&#x3D;5。</li>
</ul>
<p>chmod a&#x3D;rwx file 和 chmod 777 file 效果相同</p>
<p>chmod ug&#x3D;rwx,o&#x3D;x file 和 chmod 771 file 效果相同</p>
<p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p>
<p>更多说明</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>chmod a+r file</td>
<td>给file的所有用户增加读权限</td>
</tr>
<tr>
<td>chmod a-x file</td>
<td>删除file的所有用户的执行权限</td>
</tr>
<tr>
<td>chmod a+rw file</td>
<td>给file的所有用户增加读写权限</td>
</tr>
<tr>
<td>chmod +rwx file</td>
<td>给file的所有用户增加读写执行权限</td>
</tr>
<tr>
<td>chmod u&#x3D;rw,go&#x3D; file</td>
<td>对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td>
</tr>
<tr>
<td>chmod -R u+r,go-r docs</td>
<td>对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td>
</tr>
<tr>
<td>chmod 664 file</td>
<td>对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td>
</tr>
<tr>
<td>chmod 0755 file</td>
<td>相当于u&#x3D;rwx (4+2+1),go&#x3D;rx (4+1 &amp; 4+1)。0 没有特殊模式。</td>
</tr>
<tr>
<td>chmod 4755 file</td>
<td>4设置了设置<a class="link"   href="https://www.runoob.com/wiki/%25E7%2594%25A8%25E6%2588%25B7ID" >用户ID<i class="fas fa-external-link-alt"></i></a>位，剩下的相当于 u&#x3D;rwx (4+2+1),go&#x3D;rx (4+1 &amp; 4+1)。</td>
</tr>
<tr>
<td>find path&#x2F; -type d -exec chmod a-x {} \;</td>
<td>删除可执行权限对path&#x2F;以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td>
</tr>
<tr>
<td>find path&#x2F; -type d -exec chmod a+x {} \;</td>
<td>允许所有用户浏览或通过目录path&#x2F;</td>
</tr>
</tbody></table>
<h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p><strong>概述</strong></p>
<p>英文全拼：<strong>change owner</strong>，命令用于设置文件所有者和文件关联组的命令。</p>
<p>Linux&#x2F;Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p>
<p>chown 需要超级用户 <strong>root</strong> 的权限才能执行此命令。</p>
<p>只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 chgrp 命令。</p>
<p>使用权限 : root</p>
<p><strong>用法</strong><br>chown [-cfhvR] [–help] [–version] user[:group] file…</p>
<p>参数 :</p>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<p><strong>场景</strong><br>把 &#x2F;var&#x2F;run&#x2F;httpd.pid 的所有者设置 root：</p>
<p>chown root &#x2F;var&#x2F;run&#x2F;httpd.pid</p>
<p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<p>chown runoob:runoobgroup file1.txt</p>
<p>将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<p>chown -R runoob:runoobgroup *</p>
<p>把 &#x2F;home&#x2F;runoob 的关联组设置为 512 （关联组ID），不改变所有者：</p>
<p>chown :512 &#x2F;home&#x2F;runoob</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享交流之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://www.runoob.com/linux/linux-comm-chmod.html" >https://www.runoob.com/linux/linux-comm-chmod.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.runoob.com/linux/linux-comm-chown.html" >https://www.runoob.com/linux/linux-comm-chown.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的启动</title>
    <url>/2024/0530982cbe.html</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0530982cbe/Linux%E7%9A%84%E5%90%AF%E5%8A%A8.jpg"
                       
                 ></p>
]]></content>
      <tags>
        <tag>grub</tag>
        <tag>Linux</tag>
        <tag>boot</tag>
        <tag>initrd</tag>
        <tag>initramfs</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>OverlayFS</title>
    <url>/2024/05c2403edf.html</url>
    <content><![CDATA[<p>OverlayFS（Overlay Filesystem）是一种联合文件系统，允许将一个或多个文件系统层叠合并为一个单一的文件系统视图。它最常用于容器技术（如Docker）和其他需要高效文件系统管理的场景。以下是OverlayFS的基本概念、工作原理、以及常见的使用场景。</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>OverlayFS有三个主要的目录概念：</p>
<ul>
<li><p><strong>Lower Directory（下层目录）</strong>：这是底层的只读文件系统。</p>
</li>
<li><p><strong>Upper Directory（上层目录）</strong>：这是上层的可写文件系统。</p>
</li>
<li><p><strong>Work Directory（工作目录）</strong>：这是一个用于支持上层目录操作的工作目录。</p>
</li>
</ul>
<p>OverlayFS通过将上层目录和下层目录合并，提供一个统一的视图给用户。在这个视图中，上层目录的文件会覆盖下层目录中的文件。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当你挂载OverlayFS时，你指定一个下层目录（lowerdir）、一个上层目录（upperdir）和一个工作目录（workdir）。合并后的结果会展示在一个挂载点（merged）上。<br>以下是一些操作如何在OverlayFS中处理：</p>
<ul>
<li><strong>读取文件</strong>：如果文件存在于上层目录，则读取上层目录的文件；如果不存在，则读取下层目录的文件。</li>
<li><strong>写入文件</strong>：写入操作始终发生在上层目录。如果文件在下层目录中存在，写入操作会在上层目录中创建一个文件副本并进行修改。</li>
<li><strong>删除文件</strong>：删除操作在上层目录中创建一个白化文件（whiteout file），从而在合并视图中隐藏下层目录的文件。</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>假设你有以下目录结构：</p>
<ul>
<li><strong>lowerdir</strong>：下层只读目录。</li>
<li><strong>upperdir</strong>：上层可写目录。</li>
<li><strong>workdir</strong>：工作目录。</li>
<li><strong>merged</strong>：合并后的挂载点。</li>
</ul>
<h2 id="挂载OverlayFS"><a href="#挂载OverlayFS" class="headerlink" title="挂载OverlayFS"></a>挂载OverlayFS</h2><p><strong>创建目录</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p lowerdir upperdir workdir merged</span><br></pre></td></tr></table></figure>
<p><strong>挂载OverlayFS</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo mount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged</span><br></pre></td></tr></table></figure>
<p><strong>验证挂载</strong>：<br>你可以通过以下命令查看挂载的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> merged</span><br></pre></td></tr></table></figure>
<h2 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>如果 <strong>lowerdir</strong> 包含 <strong>file1</strong>，但 <strong>upperdir</strong> 不包含，那么 <strong>file1</strong> 可以在 <strong>merged</strong> 中读取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a file in lowerdir&quot;</span> &gt; lowerdir/file1</span><br><span class="line"><span class="built_in">cat</span> merged/file1</span><br><span class="line"><span class="comment"># 输出: This is a file in lowerdir</span></span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>如果你在 <strong>merged</strong> 中写入文件，文件会出现在 <strong>upperdir</strong> 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a new file in merged&quot;</span> &gt; merged/file2</span><br><span class="line"><span class="built_in">cat</span> upperdir/file2</span><br><span class="line"><span class="comment"># 输出: This is a new file in merged</span></span><br></pre></td></tr></table></figure>

<h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>如果你修改 <strong>merged</strong> 中存在于 <strong>lowerdir</strong> 的文件，修改后的副本会保存在 <strong>upperdir</strong> 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a modified file in merged&quot;</span> &gt; merged/file1</span><br><span class="line"><span class="built_in">cat</span> upperdir/file1</span><br><span class="line"><span class="comment"># 输出: This is a modified file in merged</span></span><br><span class="line"><span class="built_in">cat</span> lowerdir/file1</span><br><span class="line"><span class="comment"># 输出: This is a file in lowerdir</span></span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>删除操作在上层目录中创建一个白化文件，从而在合并视图中隐藏下层目录的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> merged/file1</span><br><span class="line"><span class="built_in">ls</span> merged</span><br><span class="line"><span class="comment"># `file1` 不再存在</span></span><br><span class="line"><span class="built_in">ls</span> upperdir</span><br><span class="line"><span class="comment"># 输出: file1 (白化文件)</span></span><br></pre></td></tr></table></figure>

<h3 id="取消挂载"><a href="#取消挂载" class="headerlink" title="取消挂载"></a>取消挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看挂载信息（确认挂载点）</span></span><br><span class="line">sudo mount | grep merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消挂载</span></span><br><span class="line">sudo umount merged</span><br></pre></td></tr></table></figure>
<h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><ul>
<li><strong>容器技术</strong>：Docker等容器技术广泛使用OverlayFS来管理镜像层和容器层，使得镜像可以共享底层文件而不重复存储。</li>
<li><strong>开发和测试</strong>：开发人员可以使用OverlayFS创建临时的文件系统视图进行测试，而不影响原有文件系统。</li>
<li><strong>系统升级和恢复</strong>：系统管理员可以使用OverlayFS进行系统升级测试，确保系统稳定后再进行实际的升级操作。</li>
</ul>
<p>OverlayFS提供了一种高效且灵活的文件系统管理方式，适用于多种需要层叠文件系统视图的应用场景。</p>
]]></content>
      <tags>
        <tag>fs</tag>
        <tag>overlay</tag>
      </tags>
  </entry>
  <entry>
    <title>PAM模块-pam_script</title>
    <url>/2022/098105.html</url>
    <content><![CDATA[<p>先确保您对pam配置已经有了基本的了解，否则应先阅读《<a class="link"   href="https://www.yuque.com/docs/share/5c4da2a1-02cc-4637-b4d4-e0a10e00d952#" >Linux下PAM模块学习总结<i class="fas fa-external-link-alt"></i></a>》</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>这是一个可以在会话开始和结束时执行脚本的模块。<br>可以通过<code>sudo apt install libpam-script</code>安装此模块，但仍需要您手动修改pam模块的配置才能生效。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在用户登录和注销时执行一些操作，比如用户 上&#x2F;下线 通知.</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/098105/image.png"
                       
                 ></p>
<p>如果&#x2F;usr&#x2F;share&#x2F;libpam-script目录下的pam_script_auth、pam_script_acct、pam_script_passwd、pam_script_ses_open、pam_script_ses_close脚本存在的话，它会在合适的时机去调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@uos-PC:/usr/share/libpam-script<span class="comment"># ls -l</span></span><br><span class="line">总用量 24</span><br><span class="line">-rwxr-xr-x 1 root root 1366 9月  13 13:43 pam_script_acct</span><br><span class="line">-rwxr-xr-x 1 root root 1355 9月  13 13:43 pam_script_auth</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月   9 13:36 pam-script.d</span><br><span class="line">-rwxr-xr-x 1 root root 1367 9月  13 13:43 pam_script_passwd</span><br><span class="line">-rwxr-xr-x 1 root root 1365 9月  13 13:44 pam_script_ses_close</span><br><span class="line">-rwxr-xr-x 1 root root 1444 9月  13 15:08 pam_script_ses_open</span><br></pre></td></tr></table></figure>

<p>您也可以通过dir&#x3D;&#x2F;some&#x2F;path指定脚本的路径，将其作为pam模块配置的参数即可</p>
<h1 id="认证类型和默认执行的脚本名称"><a href="#认证类型和默认执行的脚本名称" class="headerlink" title="认证类型和默认执行的脚本名称"></a>认证类型和默认执行的脚本名称</h1><table>
<thead>
<tr>
<th>认证类型</th>
<th>指定脚本名称</th>
<th>自动触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>pam_script_auth</td>
<td>username&#x2F;password handshake</td>
</tr>
<tr>
<td>account</td>
<td>pam_script_acct</td>
<td>non-auth account management</td>
</tr>
<tr>
<td>passwd</td>
<td>pam_script_passwd</td>
<td>changing a password</td>
</tr>
<tr>
<td>session</td>
<td>pam_script_ses_open&#x2F;pam_script_ses_close</td>
<td>actions performed before and after a session</td>
</tr>
</tbody></table>
<p>所有脚本在被pam-script模块执行时都将被传递以下几个环境变量：<br>PAM_USER、PAM_RUSER、PAM_RHOST、PAM_SERVICE、PAM_AUTHTOK、<br>PAM_OLDAUTHTOK、PAM_TTY 和 PAM_TYPE 。<br>（上述环境变量可能因为上下文的关系返回空值)</p>
<p>对pam配置文件做出以下修改，在会话开始时将会自动查找对应路径下的pam_script_ses_open脚本并执行，在会话结束自动执行pam_script_ses_close脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@uos-PC /e/pam.d<span class="comment"># cat common-session</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/pam.d/common-session - session-related modules common to all services</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file is included from other service-specific PAM config files,</span></span><br><span class="line"><span class="comment"># and should contain a list of modules that define tasks to be performed</span></span><br><span class="line"><span class="comment"># at the start and end of sessions of *any* kind (both interactive and</span></span><br><span class="line"><span class="comment"># non-interactive).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># As of pam 1.0.1-6, this file is managed by pam-auth-update by default.</span></span><br><span class="line"><span class="comment"># To take advantage of this, it is recommended that you configure any</span></span><br><span class="line"><span class="comment"># local modules either before or after the default block, and use</span></span><br><span class="line"><span class="comment"># pam-auth-update to manage selection of other modules.  See</span></span><br><span class="line"><span class="comment"># pam-auth-update(8) for details.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># here are the per-package modules (the &quot;Primary&quot; block)</span></span><br><span class="line">session [default=1]                     pam_permit.so</span><br><span class="line"><span class="comment"># here&#x27;s the fallback if no module succeeds</span></span><br><span class="line">session requisite                       pam_deny.so</span><br><span class="line"><span class="comment"># prime the stack with a positive return value if there isn&#x27;t one already;</span></span><br><span class="line"><span class="comment"># this avoids us returning an error just because nothing sets a success code</span></span><br><span class="line"><span class="comment"># since the modules above will each just jump around</span></span><br><span class="line">session required                        pam_permit.so</span><br><span class="line"><span class="comment"># and here are more per-package modules (the &quot;Additional&quot; block)</span></span><br><span class="line">session required        pam_unix.so </span><br><span class="line">session required    		pam_udcp.so </span><br><span class="line">session optional        pam_systemd.so </span><br><span class="line">session optional        pam_mkhomedir.so <span class="built_in">umask</span>=077</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增下面一行配置</span></span><br><span class="line">session optional        pam_script.so</span><br><span class="line"><span class="comment"># end of pam-auth-update config</span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>您也可以libpam-script包中提供的 README.examples 文件，从而了解更多的信息。</p>
<p>常见的使用示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会话开始后自动执行pam_script_ses_open脚本,结束后自动执行pam_script_ses_close脚本</span></span><br><span class="line">session optional        pam_script.so  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名密码认证时自动执行pam_script_auth脚本</span></span><br><span class="line">auth 		optional        pam_script.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码时自动执行pam_script_passwd脚本</span></span><br><span class="line">passwd 	optional        pam_script.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查帐号属性时自动执行pam_script_acct脚本</span></span><br><span class="line">account	optional        pam_script.so</span><br></pre></td></tr></table></figure>

<h1 id="场景拓展"><a href="#场景拓展" class="headerlink" title="场景拓展"></a>场景拓展</h1><p>1、ssh远程登录时，通过脚本在本地进行交互式提醒，避免被远程侵入<br>2、对session的open和close做记录，并集中时间统一上传，做大数据分析(用户许可的前提下)</p>
<h1 id="示例脚本"><a href="#示例脚本" class="headerlink" title="示例脚本"></a>示例脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An example pam-script, which can be used as a template for your own</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The accepted list of scripts:</span></span><br><span class="line"><span class="comment">#       pam_script_auth</span></span><br><span class="line"><span class="comment">#       pam_script_acct</span></span><br><span class="line"><span class="comment">#       pam_script_passwd</span></span><br><span class="line"><span class="comment">#       pam_script_ses_open</span></span><br><span class="line"><span class="comment">#       pam_script_ses_close</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The environment variables passed by pam-script onto the script</span></span><br><span class="line"><span class="comment"># (all will exist but some may be null if not applicable):</span></span><br><span class="line"><span class="comment">#       PAM_SERVICE     - the application that&#x27;s invoking the PAM stack</span></span><br><span class="line"><span class="comment">#       PAM_TYPE        - the module-type (e.g. auth,account,session,password)</span></span><br><span class="line"><span class="comment">#       PAM_USER        - the user being authenticated into</span></span><br><span class="line"><span class="comment">#       PAM_RUSER       - the remote user, the user invoking the application</span></span><br><span class="line"><span class="comment">#       PAM_RHOST       - remote host</span></span><br><span class="line"><span class="comment">#       PAM_TTY         - the controlling tty</span></span><br><span class="line"><span class="comment">#       PAM_AUTHTOK     - password in readable text</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># assume a GNU compatible date</span></span><br><span class="line">stamp=`/bin/date +<span class="string">&#x27;%Y%m%d%H%M%S %a&#x27;</span>`</span><br><span class="line"><span class="comment"># get the script name (could be link)</span></span><br><span class="line">script=`<span class="built_in">basename</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">LOGFILE=/tmp/pam-script.log</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$stamp</span> <span class="variable">$script</span> <span class="variable">$PAM_SERVICE</span> <span class="variable">$PAM_TYPE</span>                              \</span><br><span class="line">        user=<span class="variable">$PAM_USER</span> ruser=<span class="variable">$PAM_RUSER</span> rhost=<span class="variable">$PAM_RHOST</span>                \</span><br><span class="line">        <span class="built_in">tty</span>=<span class="variable">$PAM_TTY</span>                                                    \</span><br><span class="line">        args=[<span class="string">&quot;<span class="variable">$@</span>&quot;</span>]                                                     \</span><br><span class="line">        &gt;&gt; <span class="variable">$LOGFILE</span></span><br><span class="line"><span class="built_in">chmod</span> 666 <span class="variable">$LOGFILE</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># success</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>示例脚本输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[uos@uos-PC 11:04:40 ~]$ <span class="built_in">cat</span> /tmp/pam-script.log </span><br><span class="line">20220913104655 二 pam_script_ses_open su session user=admin ruser=uos rhost= <span class="built_in">tty</span>=pts/4 args=[]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、脚本的权限不能过高，否则会被pam_script拒绝执行(安全问题)，可以考虑将权限设置为755，报错信息可以查阅&#x2F;var&#x2F;log&#x2F;auth.log文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_path_perms</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fs</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">mode_t</span> ALL_EXEC_MASK = (S_IXUSR|S_IXGRP|S_IXOTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* note: checking security properties like this leaves us with a race</span></span><br><span class="line"><span class="comment">* condition, because the stat()/execve() execution is not atomic.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* likely candidates for overcoming this would have been fexecve() or</span></span><br><span class="line"><span class="comment">* execveat(). But both suffer from a side effect (at least on</span></span><br><span class="line"><span class="comment">* Linux/glibc implementation) that causes scripts to be called like</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &quot;bash /proc/self/fd/&lt;num&gt; &lt;argv1&gt; ...&quot;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This would break existing scripts that can&#x27;t make out their</span></span><br><span class="line"><span class="comment">* basename/dirname any more to base decisions on them.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* An explicit environment variable could be added that carries the</span></span><br><span class="line"><span class="comment">* &quot;real&quot; basename but that would complicate things even more.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* test for script existence first */</span></span><br><span class="line">    <span class="keyword">if</span> (stat(path, &amp;fs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* stat failure */</span></span><br><span class="line">        pam_script_syslog(LOG_ERR,<span class="string">&quot;can not stat %s&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fs.st_mode &amp; ALL_EXEC_MASK) != ALL_EXEC_MASK) &#123;</span><br><span class="line">        <span class="comment">/* script not executable at all levels */</span></span><br><span class="line">        pam_script_syslog(LOG_ALERT,</span><br><span class="line">                          <span class="string">&quot;path %s not fully executable&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fs.st_mode &amp; S_IWOTH) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* script is world writeable, probably not a good idea */</span></span><br><span class="line">        pam_script_syslog(LOG_ALERT,</span><br><span class="line">                          <span class="string">&quot;path %s is world-writeable, rejecting for &quot;</span></span><br><span class="line">                          <span class="string">&quot;security reasons&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fs.st_uid != <span class="number">0</span> || fs.st_gid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* script should be owned by root:root */</span></span><br><span class="line">        pam_script_syslog(LOG_ALERT,</span><br><span class="line">                          <span class="string">&quot;path %s is not owned by root:root, rejecting for security reasons&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Written by Jeroen Nijhof &lt;jeroen@jeroennijhof.nl&gt; 2005/03/01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> *  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> *  (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> *  GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> *  along with this program - see the file COPYING.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- includes --- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>			<span class="comment">/* varg... */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>			<span class="comment">/* strcmp,strncpy,... */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>			<span class="comment">/* stat, fork, wait */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>			<span class="comment">/* stat */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>			<span class="comment">/* wait */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>			<span class="comment">/* stat, fork, execve, **environ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>			<span class="comment">/* calloc, setenv, putenv */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* enable these module-types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SM_AUTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SM_ACCOUNT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SM_SESSION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SM_PASSWORD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;security/pam_appl.h&gt;</span>		<span class="comment">/* pam_* */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;security/pam_modules.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_VSYSLOG</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span>			<span class="comment">/* vsyslog */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- customize these defines --- */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAM_SCRIPT_DIR</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PAM_SCRIPT_DIR	<span class="string">&quot;/usr/bin&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_AUTH		<span class="string">&quot;pam_script_auth&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_ACCT		<span class="string">&quot;pam_script_acct&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_PASSWD	<span class="string">&quot;pam_script_passwd&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_SES_OPEN	<span class="string">&quot;pam_script_ses_open&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_SES_CLOSE	<span class="string">&quot;pam_script_ses_close&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- defines --- */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_EXTERN	extern</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_USER <span class="string">&quot;nobody&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- macros --- */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAM_SCRIPT_SETENV(key)						\</span></span><br><span class="line"><span class="meta">	&#123;<span class="keyword">if</span> (pam_get_item(pamh, key, &amp;envval) == PAM_SUCCESS)		\</span></span><br><span class="line"><span class="meta">		pam_script_setenv(#key, (const char *) envval);		\</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span>	pam_script_setenv(#key, (const char *) NULL);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* external variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* convenient function to throw into one of the methods below</span></span><br><span class="line"><span class="comment"> * for setting as a breakpoint for debugging purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pam_script_xxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal helper functions */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pam_script_syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, format);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_VSYSLOG</span></span><br><span class="line">	openlog(PACKAGE, LOG_CONS|LOG_PID, LOG_AUTH);</span><br><span class="line">	vsyslog(priority, format, args);</span><br><span class="line">	closelog();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, args);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pam_script_setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_SETENV</span></span><br><span class="line">	setenv(key, (value?value:<span class="string">&quot;&quot;</span>), <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> HAVE_PUTENV</span></span><br><span class="line">	<span class="type">char</span>	 buffer[BUFSIZE],</span><br><span class="line">		*str;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">snprintf</span>(buffer, BUFSIZE, <span class="string">&quot;%s=%s&quot;</span>, key, value ? value : <span class="string">&quot;&quot;</span>) &gt; BUFSIZE) &#123;</span><br><span class="line">		<span class="comment">// insufficient space</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((str = strdup(buffer)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		putenv(str);</span><br><span class="line">	&#125; <span class="comment">/* else &#123;</span></span><br><span class="line"><span class="comment">	     untrapped memory error - just do not add to environment</span></span><br><span class="line"><span class="comment">	&#125; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">error</span> Can not set the environment</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pam_script_get_user</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">const</span> <span class="type">char</span> **user)</span> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = pam_get_user(pamh, user, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval != PAM_SUCCESS) &#123;</span><br><span class="line">		pam_script_syslog(LOG_ALERT, <span class="string">&quot;pam_get_user returned error: %s&quot;</span>,</span><br><span class="line">			pam_strerror(pamh,retval));</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*user == <span class="literal">NULL</span> || **user == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		pam_script_syslog(LOG_ALERT, <span class="string">&quot;username not known&quot;</span>);</span><br><span class="line">		retval = pam_set_item(pamh, PAM_USER,</span><br><span class="line">			(<span class="type">const</span> <span class="type">void</span> *) DEFAULT_USER);</span><br><span class="line">		<span class="keyword">if</span> (retval != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> PAM_USER_UNKNOWN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_path_perms</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fs</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">mode_t</span> ALL_EXEC_MASK = (S_IXUSR|S_IXGRP|S_IXOTH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * note: checking security properties like this leaves us with a race</span></span><br><span class="line"><span class="comment">	 * condition, because the stat()/execve() execution is not atomic.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * likely candidates for overcoming this would have been fexecve() or</span></span><br><span class="line"><span class="comment">	 * execveat(). But both suffer from a side effect (at least on</span></span><br><span class="line"><span class="comment">	 * Linux/glibc implementation) that causes scripts to be called like</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * &quot;bash /proc/self/fd/&lt;num&gt; &lt;argv1&gt; ...&quot;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This would break existing scripts that can&#x27;t make out their</span></span><br><span class="line"><span class="comment">	 * basename/dirname any more to base decisions on them.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * An explicit environment variable could be added that carries the</span></span><br><span class="line"><span class="comment">	 * &quot;real&quot; basename but that would complicate things even more.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* test for script existence first */</span></span><br><span class="line">	<span class="keyword">if</span> (stat(path, &amp;fs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* stat failure */</span></span><br><span class="line">		pam_script_syslog(LOG_ERR,<span class="string">&quot;can not stat %s&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fs.st_mode &amp; ALL_EXEC_MASK) != ALL_EXEC_MASK) &#123;</span><br><span class="line">		<span class="comment">/* script not executable at all levels */</span></span><br><span class="line">		pam_script_syslog(LOG_ALERT,</span><br><span class="line">			<span class="string">&quot;path %s not fully executable&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((fs.st_mode &amp; S_IWOTH) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* script is world writeable, probably not a good idea */</span></span><br><span class="line">		pam_script_syslog(LOG_ALERT,</span><br><span class="line">				<span class="string">&quot;path %s is world-writeable, rejecting for &quot;</span></span><br><span class="line">				<span class="string">&quot;security reasons&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fs.st_uid != <span class="number">0</span> || fs.st_gid != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* script should be owned by root:root */</span></span><br><span class="line">		pam_script_syslog(LOG_ALERT,</span><br><span class="line">				<span class="string">&quot;path %s is not owned by root:root, rejecting for security reasons&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pam_script_exec</span><span class="params">(<span class="type">pam_handle_t</span> *pamh,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *script, <span class="type">const</span> <span class="type">char</span> *user,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> rv, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>	retval = rv,</span><br><span class="line">		status,</span><br><span class="line">		i;</span><br><span class="line">	<span class="type">char</span>	cmd[BUFSIZE] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">	<span class="type">char</span>	**newargv;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *envval = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">pid_t</span>	child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for pam.conf options */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(argv[i],<span class="string">&quot;onerr=&quot;</span>,<span class="number">6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i],<span class="string">&quot;onerr=fail&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">				retval = rv;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i],<span class="string">&quot;onerr=success&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">				retval = PAM_SUCCESS;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				pam_script_syslog(LOG_ERR,</span><br><span class="line">					<span class="string">&quot;invalid option: %s&quot;</span>, argv[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(argv[i],<span class="string">&quot;dir=&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">const</span> <span class="type">char</span> *new_dir = argv[i] + <span class="number">4</span>;</span><br><span class="line">			<span class="type">const</span> <span class="type">int</span> MAX_DIR_LEN = BUFSIZE - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (*new_dir) &#123; <span class="comment">/* got new scriptdir */</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">snprintf</span>(cmd, MAX_DIR_LEN, <span class="string">&quot;%s&quot;</span>, new_dir) &gt; MAX_DIR_LEN) &#123;</span><br><span class="line">					pam_script_syslog(LOG_ERR,<span class="string">&quot;script dir %s exceeds maximum supported path length&quot;</span>, new_dir);</span><br><span class="line">					cmd[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in">strncpy</span>(cmd, PAM_SCRIPT_DIR, BUFSIZE - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* strip trailing &#x27;/&#x27; */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">size_t</span> curlen = <span class="built_in">strlen</span>(cmd);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (curlen == <span class="number">0</span> || cmd[curlen<span class="number">-1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		cmd[curlen - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check the base directory permissions */</span></span><br><span class="line">	<span class="keyword">if</span> (check_path_perms(cmd) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(cmd,<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(script) &gt; (BUFSIZE - <span class="built_in">strlen</span>(cmd) - <span class="number">1</span>)) &#123;</span><br><span class="line">		pam_script_syslog(LOG_ERR,<span class="string">&quot;script path %s/%s exceeds maximum supported path length&quot;</span>, cmd, script);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strncat</span>(cmd,script,BUFSIZE-<span class="built_in">strlen</span>(cmd)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check the script permissions */</span></span><br><span class="line">	<span class="keyword">if</span> (check_path_perms(cmd) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Execute external program */</span></span><br><span class="line">	<span class="comment">/* fork process */</span></span><br><span class="line">	<span class="keyword">switch</span>(child_pid = fork()) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:				<span class="comment">/* fork failure */</span></span><br><span class="line">		pam_script_syslog(LOG_ALERT,</span><br><span class="line">			<span class="string">&quot;script %s fork failure&quot;</span>, cmd);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="keyword">case</span>  <span class="number">0</span>:				<span class="comment">/* child */</span></span><br><span class="line">		<span class="comment">/* Get PAM environment, pass it onto the child&#x27;s environment */</span></span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_SERVICE);</span><br><span class="line">		pam_script_setenv(<span class="string">&quot;PAM_TYPE&quot;</span>, type);</span><br><span class="line">		pam_script_setenv(<span class="string">&quot;PAM_USER&quot;</span>, user);</span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_RUSER);</span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_RHOST);</span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_TTY);</span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_AUTHTOK);</span><br><span class="line">		PAM_SCRIPT_SETENV(PAM_OLDAUTHTOK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* construct newargv */</span></span><br><span class="line">		<span class="keyword">if</span> (!(newargv = (<span class="type">char</span> **) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *), argc+<span class="number">2</span>))) &#123;</span><br><span class="line">			<span class="comment">// for rationale see below</span></span><br><span class="line">			_exit(<span class="number">127</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		newargv[<span class="number">0</span>] = cmd;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">			newargv[<span class="number">1</span>+i] = (<span class="type">char</span> *) argv[i];</span><br><span class="line">		&#125;</span><br><span class="line">		(<span class="type">void</span>) execve(cmd, newargv, environ);</span><br><span class="line">		<span class="comment">/* shouldn&#x27;t get here, unless an error */</span></span><br><span class="line">		pam_script_syslog(LOG_ALERT,</span><br><span class="line">			<span class="string">&quot;script %s exec failure&quot;</span>, cmd);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * explicitly exit() here to avoid continuing execution of the</span></span><br><span class="line"><span class="comment">		 * PAM stack in the forked process in an undefined manner.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 127 is typically the exit code when something fundamentally</span></span><br><span class="line"><span class="comment">		 * went wrong with starting a child process.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * use _exit() instead of exit() to avoid execution of any</span></span><br><span class="line"><span class="comment">		 * cleanup code like atexit() handlers.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		_exit(<span class="number">127</span>);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:				<span class="comment">/* parent */</span></span><br><span class="line">		(<span class="type">void</span>) waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">			<span class="keyword">return</span> (WEXITSTATUS(status) ? rv : PAM_SUCCESS);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pam_script_converse</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pam_message **message, <span class="keyword">struct</span> pam_response **response)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pam_conv</span> *<span class="title">conv</span>;</span></span><br><span class="line"></span><br><span class="line">	retval = pam_get_item(pamh, PAM_CONV, (<span class="type">const</span> <span class="type">void</span> **)(<span class="type">void</span> *) &amp;conv);</span><br><span class="line">	<span class="keyword">if</span> (retval == PAM_SUCCESS) &#123;</span><br><span class="line">		retval = conv-&gt;conv(argc, (<span class="type">const</span> <span class="keyword">struct</span> pam_message **) message,</span><br><span class="line">				response, conv-&gt;appdata_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pam_script_set_authtok</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">char</span> *prompt, <span class="type">int</span> authtok)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>	retval;</span><br><span class="line">	<span class="type">char</span>	*password;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pam_message</span> <span class="title">msg</span>[1],*<span class="title">pmsg</span>[1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pam_response</span> *<span class="title">response</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up conversation call */</span></span><br><span class="line">	pmsg[<span class="number">0</span>] = &amp;msg[<span class="number">0</span>];</span><br><span class="line">	msg[<span class="number">0</span>].msg_style = PAM_PROMPT_ECHO_OFF;</span><br><span class="line">	msg[<span class="number">0</span>].msg = prompt;</span><br><span class="line">	response = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_converse(pamh, <span class="number">1</span>, pmsg, &amp;response)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (response) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; PAM_DISALLOW_NULL_AUTHTOK) &amp;&amp; response[<span class="number">0</span>].resp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">free</span>(response);</span><br><span class="line">			<span class="keyword">return</span> PAM_AUTH_ERR;</span><br><span class="line">		&#125;</span><br><span class="line">		password = response[<span class="number">0</span>].resp;</span><br><span class="line">	  	response[<span class="number">0</span>].resp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> PAM_CONV_ERR;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(response);</span><br><span class="line">	pam_set_item(pamh, authtok, password);</span><br><span class="line">	<span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pam_script_senderr</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pam_message</span> <span class="title">msg</span>[1],*<span class="title">pmsg</span>[1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pam_response</span> *<span class="title">response</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up conversation call */</span></span><br><span class="line">	pmsg[<span class="number">0</span>] = &amp;msg[<span class="number">0</span>];</span><br><span class="line">	msg[<span class="number">0</span>].msg_style = PAM_ERROR_MSG;</span><br><span class="line">	msg[<span class="number">0</span>].msg = message;</span><br><span class="line">	response = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_converse(pamh, <span class="number">1</span>, pmsg, &amp;response)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(response);</span><br><span class="line">	<span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- authentication management functions --- */</span></span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_authenticate</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *user=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> *password;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_get_user(pamh, &amp;user)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Check if PAM_AUTHTOK is set by early pam modules and</span></span><br><span class="line"><span class="comment">	* if not ask user for password.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pam_get_item(pamh, PAM_AUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!password) &#123;</span><br><span class="line">		retval = pam_script_set_authtok(pamh, flags, argc, argv, <span class="string">&quot;Password: &quot;</span>, PAM_AUTHTOK);</span><br><span class="line">		<span class="keyword">if</span> (retval != PAM_SUCCESS)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pam_script_exec(pamh, <span class="string">&quot;auth&quot;</span>, PAM_SCRIPT_AUTH,</span><br><span class="line">		user, PAM_AUTH_ERR, argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_setcred</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- account management functions --- */</span></span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_acct_mgmt</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">		     <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *user=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_get_user(pamh, &amp;user)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pam_script_exec(pamh, <span class="string">&quot;account&quot;</span>, PAM_SCRIPT_ACCT,</span><br><span class="line">		user,PAM_AUTH_ERR,argc,argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- password management --- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * instead of memset for clearing memory, hopefully not being optimized out</span></span><br><span class="line"><span class="comment"> * by the compiler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">safe_clearmem</span><span class="params">(<span class="type">char</span> *mem, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		mem[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_chauthtok</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">		     <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *user = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> *password = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> new_pass1[BUFSIZE];</span><br><span class="line">        <span class="type">char</span> new_pass2[BUFSIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_get_user(pamh, &amp;user)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( flags &amp; PAM_UPDATE_AUTHTOK ) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if PAM_OLDAUTHTOK is set by early pam modules and</span></span><br><span class="line"><span class="comment">		 * if not ask user (not root) for current password.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pam_get_item(pamh, PAM_OLDAUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line">		<span class="keyword">if</span> (!password &amp;&amp; <span class="built_in">strcmp</span>(user, <span class="string">&quot;root&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			retval = pam_script_set_authtok(pamh, flags, argc, argv, <span class="string">&quot;Current password: &quot;</span>, PAM_OLDAUTHTOK);</span><br><span class="line">			<span class="keyword">if</span> (retval != PAM_SUCCESS)</span><br><span class="line">				<span class="keyword">return</span> retval;</span><br><span class="line">			pam_get_item(pamh, PAM_OLDAUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if PAM_AUTHTOK is set by early pam modules and</span></span><br><span class="line"><span class="comment">		 * if not ask user for the new password.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pam_get_item(pamh, PAM_AUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line">		<span class="keyword">if</span> (!password) &#123;</span><br><span class="line">			retval = pam_script_set_authtok(pamh, flags, argc, argv, <span class="string">&quot;New password: &quot;</span>, PAM_AUTHTOK);</span><br><span class="line">			<span class="keyword">if</span> (retval != PAM_SUCCESS)</span><br><span class="line">				<span class="keyword">return</span> retval;</span><br><span class="line">			pam_get_item(pamh, PAM_AUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line">			<span class="built_in">snprintf</span>(new_pass1, BUFSIZE, <span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">			password = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			retval = pam_script_set_authtok(pamh, flags, argc, argv, <span class="string">&quot;New password (again): &quot;</span>, PAM_AUTHTOK);</span><br><span class="line">			<span class="keyword">if</span> (retval != PAM_SUCCESS) &#123;</span><br><span class="line">				safe_clearmem(new_pass1, <span class="keyword">sizeof</span>(new_pass1));</span><br><span class="line">				<span class="keyword">return</span> retval;</span><br><span class="line">			&#125;</span><br><span class="line">			retval = pam_get_item(pamh, PAM_AUTHTOK, (<span class="type">void</span>*) &amp;password);</span><br><span class="line">			<span class="built_in">snprintf</span>(new_pass2, BUFSIZE, <span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">			password = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Check if new passwords are the same */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(new_pass1, new_pass2) != <span class="number">0</span>) &#123;</span><br><span class="line">				retval = pam_script_senderr(pamh, flags, argc, argv,</span><br><span class="line">						<span class="string">&quot;You must enter the same password twice.&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (retval == PAM_SUCCESS)</span><br><span class="line">					retval = PAM_AUTHTOK_ERR;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			safe_clearmem(new_pass1, <span class="keyword">sizeof</span>(new_pass1));</span><br><span class="line">			safe_clearmem(new_pass2, <span class="keyword">sizeof</span>(new_pass2));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (retval != PAM_SUCCESS)</span><br><span class="line">				<span class="keyword">return</span> PAM_AUTHTOK_ERR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pam_script_exec(pamh, <span class="string">&quot;password&quot;</span>, PAM_SCRIPT_PASSWD,</span><br><span class="line">			user, PAM_AUTHTOK_ERR, argc, argv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- session management --- */</span></span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_open_session</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *user = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_get_user(pamh, &amp;user)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pam_script_exec(pamh, <span class="string">&quot;session&quot;</span>, PAM_SCRIPT_SES_OPEN,</span><br><span class="line">		user, PAM_SESSION_ERR, argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PAM_EXTERN</span><br><span class="line"><span class="type">int</span> <span class="title function_">pam_sm_close_session</span><span class="params">(<span class="type">pam_handle_t</span> *pamh, <span class="type">int</span> flags, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *user = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((retval = pam_script_get_user(pamh, &amp;user)) != PAM_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pam_script_exec(pamh, <span class="string">&quot;session&quot;</span>, PAM_SCRIPT_SES_CLOSE,</span><br><span class="line">		user, PAM_SESSION_ERR, argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* end of module definition */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PAM_STATIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* static module data */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pam_module</span> _<span class="title">pam_script_modstruct</span> =</span> &#123;</span><br><span class="line">	<span class="string">&quot;pam_script&quot;</span>,</span><br><span class="line">	pam_sm_authenticate,</span><br><span class="line">	pam_sm_setcred,</span><br><span class="line">	pam_sm_acct_mgmt,</span><br><span class="line">	pam_sm_open_session,</span><br><span class="line">	pam_sm_close_session,</span><br><span class="line">	pam_sm_chauthtok</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://linux.die.net/man/5/pam_script" >pam_script - Linux man page<i class="fas fa-external-link-alt"></i></a>—部分信息已经过时了，以本文内容为准</p>
<p><a class="link"   href="https://github.com/jeroennijhof/pam_script" >https://github.com/jeroennijhof/pam_script<i class="fas fa-external-link-alt"></i></a>—Homepage</p>
<p><a class="link"   href="https://linux.die.net/man/8/pam_exec" >https://linux.die.net/man/8/pam_exec<i class="fas fa-external-link-alt"></i></a>—pam_exec(当我看完了pam_script，发现了pam_exec,emmm…)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>QT实现生产者-消费者模型</title>
    <url>/2023/086eb5fc91.html</url>
    <content><![CDATA[<h1 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h1><p>基于 Qt 实现QT实现生产者-消费者模型的demo</p>
<span id="more"></span>

<h2 id="使用信号量实现-QSemaphore"><a href="#使用信号量实现-QSemaphore" class="headerlink" title="使用信号量实现-QSemaphore"></a>使用信号量实现-QSemaphore</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSemaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQueue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">100</span>;</span><br><span class="line"><span class="function">QSemaphore <span class="title">writeSemaphore</span><span class="params">(bufferSize)</span></span>;</span><br><span class="line">QSemaphore readSemaphore;</span><br><span class="line">QQueue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> resources_index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 0~100ms内随机产生一个资源</span></span><br><span class="line">            QThread::<span class="built_in">msleep</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>));</span><br><span class="line">            writeSemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">            queue.<span class="built_in">append</span>(resources_index++);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;+++&quot;</span> &lt;&lt; resources_index &lt;&lt; <span class="string">&quot;produced&quot;</span>;</span><br><span class="line">            readSemaphore.<span class="built_in">release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            readSemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">            <span class="type">int</span> resources_index = queue.<span class="built_in">takeFirst</span>();</span><br><span class="line">            writeSemaphore.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 0~500ms内随机消费一个资源</span></span><br><span class="line">            QThread::<span class="built_in">msleep</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">500</span>));</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; resources_index &lt;&lt; <span class="string">&quot;consumed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Producer producer;</span><br><span class="line">    Consumer consumer;</span><br><span class="line">    producer.<span class="built_in">start</span>();</span><br><span class="line">    consumer.<span class="built_in">start</span>();</span><br><span class="line">    producer.<span class="built_in">wait</span>();</span><br><span class="line">    consumer.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用条件变量实现-QWaitCondition"><a href="#使用条件变量实现-QWaitCondition" class="headerlink" title="使用条件变量实现-QWaitCondition"></a>使用条件变量实现-QWaitCondition</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Producer</span>(QWaitCondition *wc1, QWaitCondition *wc2, QMutex *mutex, QQueue&lt;<span class="type">int</span>&gt; &amp;queue, QObject *parent = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">QThread</span>(parent)</span><br><span class="line">        , <span class="built_in">m_consumeWaitCondition</span>(wc1)</span><br><span class="line">        , <span class="built_in">m_produceWaitCondition</span>(wc2)</span><br><span class="line">        , <span class="built_in">m_mutex</span>(mutex)</span><br><span class="line">        , <span class="built_in">m_queue</span>(queue)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0~100ms内随机产生一个资源</span></span><br><span class="line">            QThread::<span class="built_in">msleep</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">            m_mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> resource_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (m_queue.<span class="built_in">size</span>() &lt; bufferSize) &#123;</span><br><span class="line">                m_queue.<span class="built_in">append</span>(resource_index++);</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;+++&quot;</span> &lt;&lt; resource_index &lt;&lt; <span class="string">&quot;produced&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m_produceWaitCondition-&gt;<span class="built_in">wait</span>(m_mutex);</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            m_mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            m_consumeWaitCondition-&gt;<span class="built_in">wakeOne</span>();</span><br><span class="line">            m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWaitCondition *m_consumeWaitCondition;</span><br><span class="line">    QWaitCondition *m_produceWaitCondition;</span><br><span class="line">    QMutex *m_mutex;</span><br><span class="line">    QQueue&lt;<span class="type">int</span>&gt; &amp;m_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Consumer</span>(QWaitCondition *wc1, QWaitCondition *wc2, QMutex *mutex, QQueue&lt;<span class="type">int</span>&gt; &amp;queue, QObject *parent = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">QThread</span>(parent)</span><br><span class="line">        , <span class="built_in">m_consumeWaitCondition</span>(wc1)</span><br><span class="line">        , <span class="built_in">m_produceWaitCondition</span>(wc2)</span><br><span class="line">        , <span class="built_in">m_mutex</span>(mutex)</span><br><span class="line">        , <span class="built_in">m_queue</span>(queue)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> resources_index = <span class="number">-1</span>;</span><br><span class="line">            m_mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (m_queue.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                resources_index = m_queue.<span class="built_in">takeFirst</span>();</span><br><span class="line">                m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m_consumeWaitCondition-&gt;<span class="built_in">wait</span>(m_mutex);</span><br><span class="line">                m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_mutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            m_produceWaitCondition-&gt;<span class="built_in">wakeAll</span>();</span><br><span class="line">            m_mutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 0~500ms内随机消费一个资源</span></span><br><span class="line">            QThread::<span class="built_in">msleep</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">500</span>));</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; resources_index &lt;&lt; <span class="string">&quot;consumed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWaitCondition *m_consumeWaitCondition;</span><br><span class="line">    QWaitCondition *m_produceWaitCondition;</span><br><span class="line">    QMutex *m_mutex;</span><br><span class="line">    QQueue&lt;<span class="type">int</span>&gt; &amp;m_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWaitCondition queueNotEmpty;</span><br><span class="line">    QWaitCondition queueNotFull;</span><br><span class="line">    QMutex mutex;</span><br><span class="line">    QQueue&lt;<span class="type">int</span>&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function">Producer <span class="title">producer</span><span class="params">(&amp;queueNotEmpty, &amp;queueNotFull, &amp;mutex, taskQueue)</span></span>;</span><br><span class="line">    <span class="function">Consumer <span class="title">consumer</span><span class="params">(&amp;queueNotEmpty, &amp;queueNotFull, &amp;mutex, taskQueue)</span></span>;</span><br><span class="line">    producer.<span class="built_in">start</span>();</span><br><span class="line">    consumer.<span class="built_in">start</span>();</span><br><span class="line">    producer.<span class="built_in">wait</span>();</span><br><span class="line">    consumer.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Creator常用技巧</title>
    <url>/2023/04f1bafce9.html</url>
    <content><![CDATA[<h1 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h1><p>Qt Creator默认并没有启用相关功能。您可以通过打开<strong>帮助-&gt;关于插件</strong>页面，选择Beautifier功能，并重启Qt Creator来启用该功能。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/1.png"
                       
                 ></p>
<p>关于Qt Creator的Beautifier功能的具体配置，请参考下面链接中的详细说明</p>
<p><a class="link"   href="https://blog.csdn.net/qq_33154343/article/details/101397429" >QtCreator设置代码美化astyle之Artistic<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>风格美化工具只是一种辅助工具。养成良好的编码习惯后，这个工具对您来说可能就不再必要了。但偶尔使用它来检查编码风格是否规范仍然是一个很好的选择。</p>
</blockquote>
<h1 id="多线程编译"><a href="#多线程编译" class="headerlink" title="多线程编译"></a>多线程编译</h1><p><strong>工具-&gt;选项-&gt;Kits-&gt;构建套件</strong></p>
<p>选择编译时的默认Kits,找到Environment选项</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/1.2.png"
                       
                 ></p>
<p>点击 Change</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/1.3.png"
                       
                 ></p>
<p>写入 “MAKEFLAGS&#x3D;-j8”,保存即可，后续所有项目的均默认开启多核编译，无需再手动配置</p>
<h1 id="版权信息添加"><a href="#版权信息添加" class="headerlink" title="版权信息添加"></a>版权信息添加</h1><p>deepin的开源项目一般托管在<a class="link"   href="https://github.com/linuxdeepin" >GitHub<i class="fas fa-external-link-alt"></i></a>上。请注意观察每个项目中源码文件的规范，通常都会在文件顶部放置版权信息。手动添加版权信息可能会有遗漏，在日常开发中不太可靠。幸运的是，Qt Creator提供了一种自动添加版权信息的方式：</p>
<p><strong>工具-&gt;选项-&gt;C++-&gt;文件命名</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/2.png"
                       
                 ></p>
<p>将需要添加的版权信息写到一个文件中，这里选择这个文件即可。</p>
<h1 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h1><p>如果您已经安装了 Git 工具，并进行了相关配置（ Linux 系统通常无需配置），在浏览代码时需要了解其提交历史，通常需要使用<code>git blame</code>命令来追溯代码来源。而Qt Creator 提供了一种更加快捷的方式来实现这个功能。</p>
<p>Alt+G,Alt+B 追溯当前文件内容</p>
<p>您也可以通过菜单完成同样的操作</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/3.png"
                       
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/4.png"
                       
                 ></p>
<p>点击左侧的 <em>Commit Hash</em> 可以看到提交的所有的内容</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/5.png"
                       
                 ></p>
<h1 id="自定义片段"><a href="#自定义片段" class="headerlink" title="自定义片段"></a>自定义片段</h1><p>偶尔需要在项目中写一些调试信息，比如</p>
<p><code>qDebug() &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt; __FILE__;</code></p>
<p><code>setStyleSheet(background-color: red);</code></p>
<p>或者更长的代码，但是要是每次都重新输入一遍未免有些麻烦</p>
<p><strong>工具-&gt;选项-&gt;文本编辑器-&gt;片段</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/6.png"
                       
                 ></p>
<p>点击<strong>添加</strong>，在<strong>触发</strong>一列写上片段的名称,<strong>种类</strong>一列固定填写 custom,下方的输入框中输入关联的内容，点击<strong>Apply</strong>生效。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/7.png"
                       
                 ></p>
<p>实际测试一下,在编码时输入 <em>test</em> ，触发代码提示，选择 <em>test custom</em>，回车即可生成之前预设的内容</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/8.png"
                       
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/9.png"
                       
                 ></p>
<h1 id="显示配色调整"><a href="#显示配色调整" class="headerlink" title="显示配色调整"></a>显示配色调整</h1><p>Qt Creator内置了集中主题，同时也允许用户自定义主题。</p>
<p>主题：<strong>工具-&gt;选项-&gt;环境-&gt;Interface-&gt;Theme</strong></p>
<p>字体和颜色：<strong>工具-&gt;选项-&gt;文本编辑器-&gt;字体和颜色</strong></p>
<p>比如我常用的字体和颜色是内置的Default</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/10.png"
                       
                 ></p>
<p>这种模式下，如果当前主题选择的是 <em>Flat light</em> ,会导致行号显示的不太清晰。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/11.png"
                       
                 ></p>
<p>我们可以复制一份Color Scheme然后对其修改(内置的Scheme不允许直接修改)</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/12.png"
                       
                 ></p>
<p>复制后自行命名,例如，这里命令为test</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/13.png"
                       
                 ></p>
<p>选中当前新增的test Scheme，选择<em><strong>行号</strong></em>，点击 <em><strong>前景颜色</strong></em>，自行修改为期望的颜色，最终记得<strong>Apply</strong>生效</p>
<h1 id="快速整理格式"><a href="#快速整理格式" class="headerlink" title="快速整理格式"></a>快速整理格式</h1><p>astyle 美化插件开启后，可以设置为保存时自动调整格式</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/14.png"
                       
                 ></p>
<p>也可以选中代码后，Ctrl+I 快捷键触发代码的格式化。</p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Ctrl+B 编译</p>
<p>Ctrl+R 运行</p>
<p>F5 开始调试运行</p>
<p>Ctrl+I 整理选中部分内容的代码格式</p>
<p>F4 快速跳转到头文件&#x2F;源文件</p>
<p>F3 查找定位</p>
<p>Ctrl+Shift+F 高级查找</p>
<p>批量重命名</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/15.png"
                       
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04f1bafce9/16.png"
                       
                 ></p>
]]></content>
      <tags>
        <tag>编码工具</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt-DBus使用方式(非xml2cpp形式)</title>
    <url>/2021/1136969.html</url>
    <content><![CDATA[<p>相信来到桌面组的都已经培训过关于DBus服务的adapter和interface的用法，这里再补充一下不借助这种方式直接获取属性，调用其方法，关联其信号的方法：</p>
<h1 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h1><p>后面会用到自定义类型，所以我们提前定义它，并实现其&lt;&lt;，&gt;&gt;操作符函数，最后要在使用之前在Qt的元类型系统和Qt D_Bus类型系统注册．以供DBus通讯体系自动识别并使用．<br>其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDBusMessage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDBusArgument&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DisplayRect</span>&#123;</span><br><span class="line">qint16 x;</span><br><span class="line">qint16 y;</span><br><span class="line">quint16 width;</span><br><span class="line">quint16 height;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">QRect</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QRect</span>(x, y, width, height);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(DisplayRect)</span><br><span class="line"></span><br><span class="line">QDBusArgument &amp;<span class="keyword">operator</span>&lt;&lt;(QDBusArgument &amp;argument, <span class="type">const</span> DisplayRect &amp;rect);</span><br><span class="line"><span class="type">const</span> QDBusArgument &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="type">const</span> QDBusArgument &amp;argument, DisplayRect &amp;rect);</span><br><span class="line">QDebug <span class="keyword">operator</span>&lt;&lt;(QDebug deg, <span class="type">const</span> DisplayRect &amp;rect);</span><br><span class="line"></span><br><span class="line">QDBusArgument &amp;<span class="keyword">operator</span>&lt;&lt;(QDBusArgument &amp;argument, <span class="type">const</span> DisplayRect &amp;rect)</span><br><span class="line">&#123;</span><br><span class="line">    argument.<span class="built_in">beginStructure</span>();</span><br><span class="line">    argument &lt;&lt; rect.x &lt;&lt; rect.y &lt;&lt; rect.width &lt;&lt; rect.height;</span><br><span class="line">    argument.<span class="built_in">endStructure</span>();</span><br><span class="line">    <span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> QDBusArgument &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="type">const</span> QDBusArgument &amp;argument, DisplayRect &amp;rect)</span><br><span class="line">&#123;</span><br><span class="line">    argument.<span class="built_in">beginStructure</span>();</span><br><span class="line">    argument &gt;&gt; rect.x &gt;&gt; rect.y &gt;&gt; rect.width &gt;&gt; rect.height;</span><br><span class="line">    argument.<span class="built_in">endStructure</span>();</span><br><span class="line">    <span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QDebug <span class="keyword">operator</span>&lt;&lt;(QDebug deg, <span class="type">const</span> DisplayRect &amp;rect)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; rect.x &lt;&lt; <span class="string">&quot;y:&quot;</span> &lt;&lt; rect.y &lt;&lt; <span class="string">&quot;width:&quot;</span> &lt;&lt; rect.width &lt;&lt; <span class="string">&quot;height:&quot;</span> &lt;&lt; rect.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>qDBusRegisterMetaType&lt;DisplayRect&gt;();</code>进行注册</p>
<h1 id="1-关联服务属性信号变化并解析当前值"><a href="#1-关联服务属性信号变化并解析当前值" class="headerlink" title="1 关联服务属性信号变化并解析当前值"></a>1 关联服务属性信号变化并解析当前值</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDBusConnection::<span class="built_in">sessionBus</span>().<span class="built_in">connect</span>(<span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;/com/deepin/dde/daemon/Dock&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;org.freedesktop.DBus.Properties&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;PropertiesChanged&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;sa&#123;sv&#125;as&quot;</span>,</span><br><span class="line">                                          <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleDBusSignal</span>(QDBusMessage)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleDBusSignal</span><span class="params">(<span class="type">const</span> QDBusMessage &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QList&lt;QVariant&gt; arguments = msg.<span class="built_in">arguments</span>();</span><br><span class="line">    <span class="comment">// 参数固定长度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span> != arguments.<span class="built_in">count</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 返回的数据中,这一部分对应的是数据发送方的interfacename,可判断是否是自己需要的服务</span></span><br><span class="line">    QString interfaceName = msg.<span class="built_in">arguments</span>().<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (interfaceName != <span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    QVariantMap changedProps = <span class="built_in">qdbus_cast</span>&lt;QVariantMap&gt;(arguments.<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">value</span>&lt;QDBusArgument&gt;());</span><br><span class="line">    QStringList keys = changedProps.<span class="built_in">keys</span>();</span><br><span class="line">    foreach (<span class="type">const</span> QString &amp;prop, keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop == <span class="string">&quot;FrontendWindowRect&quot;</span>) &#123; <span class="comment">// &#x27;FrontendWindowRect&#x27;属性发生变化－－－自定义类型</span></span><br><span class="line">            QVariant ret = changedProps[prop];</span><br><span class="line">            QDBusArgument argu = ret.<span class="built_in">value</span>&lt;QDBusArgument&gt;();</span><br><span class="line">            DisplayRect rect;</span><br><span class="line">            argu &gt;&gt; rect;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; rect;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prop == <span class="string">&quot;Position&quot;</span>) &#123; <span class="comment">// &#x27;Position&#x27;属性发生变化－－－原生类型</span></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Position&quot;</span> &lt;&lt; changedProps[prop].<span class="built_in">toInt</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="２-获取DBus服务的属性"><a href="#２-获取DBus服务的属性" class="headerlink" title="２ 获取DBus服务的属性"></a>２ 获取DBus服务的属性</h1><h2 id="2-1-原生类型"><a href="#2-1-原生类型" class="headerlink" title="2.1 原生类型"></a>2.1 原生类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2_1\ 获取DBus服务的属性之原生类型</span></span><br><span class="line">    <span class="function">QDBusInterface <span class="title">inter2_1</span><span class="params">(<span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="string">&quot;/com/deepin/dde/daemon/Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            QDBusConnection::sessionBus(), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; inter2_1.<span class="built_in">property</span>(<span class="string">&quot;Position&quot;</span>).<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QDBusInterface <span class="title">inter</span><span class="params">(<span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="string">&quot;/com/deepin/dde/daemon/Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="string">&quot;com.deepin.dde.daemon.Dock&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         QDBusConnection::sessionBus(), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> entries = inter.<span class="built_in">property</span>(<span class="string">&quot;Entries&quot;</span>).value&lt;QList&lt;QDBusObjectPath&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="2-2-自定义类型"><a href="#2-2-自定义类型" class="headerlink" title="2.2 自定义类型"></a>2.2 自定义类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2_2\ 获取DBus服务的属性之自定义类型</span></span><br><span class="line"> <span class="function">QDBusInterface <span class="title">inter2_2</span><span class="params">(<span class="string">&quot;com.deepin.daemon.Display&quot;</span>, <span class="string">&quot;/com/deepin/daemon/Display&quot;</span>, <span class="string">&quot;org.freedesktop.DBus.Properties&quot;</span>)</span></span>;</span><br><span class="line"> QString interafce = <span class="string">&quot;com.deepin.daemon.Display&quot;</span>;</span><br><span class="line"> QString arg1 = <span class="string">&quot;PrimaryRect&quot;</span>;</span><br><span class="line"> QDBusMessage msg = inter2_2.<span class="built_in">call</span>(<span class="string">&quot;Get&quot;</span>, interafce, arg1);</span><br><span class="line"></span><br><span class="line"> QVariant var = msg.<span class="built_in">arguments</span>().<span class="built_in">first</span>();</span><br><span class="line"> QDBusVariant dbvFirst = var.<span class="built_in">value</span>&lt;QDBusVariant&gt;();</span><br><span class="line"> QVariant vFirst = dbvFirst.<span class="built_in">variant</span>();</span><br><span class="line"> QDBusArgument dbusArgs = vFirst.<span class="built_in">value</span>&lt;QDBusArgument&gt;();</span><br><span class="line"></span><br><span class="line"> DisplayRect rect;</span><br><span class="line"> dbusArgs &gt;&gt; rect;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; rect;</span><br></pre></td></tr></table></figure>

<h1 id="3-调用DBus服务的方法"><a href="#3-调用DBus服务的方法" class="headerlink" title="3 调用DBus服务的方法"></a>3 调用DBus服务的方法</h1><h2 id="3-1-无返回值"><a href="#3-1-无返回值" class="headerlink" title="3.1 无返回值"></a>3.1 无返回值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3_1\ 调用DBus服务的方法-无参调用-无返回值</span></span><br><span class="line"><span class="function">QDBusInterface <span class="title">inter3_1</span><span class="params">(<span class="string">&quot;com.deepin.dde.Clipboard&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;/com/deepin/dde/Clipboard&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;com.deepin.dde.Clipboard&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        QDBusConnection::sessionBus(), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">inter3_1.<span class="built_in">call</span>(<span class="string">&quot;Toggle&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-有返回值"><a href="#3-2-有返回值" class="headerlink" title="3.2 有返回值"></a>3.2 有返回值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3_2\ 调用DBus服务的方法-无参调用-有返回值</span></span><br><span class="line"><span class="function">QDBusInterface <span class="title">inter3_2</span><span class="params">(<span class="string">&quot;com.deepin.daemon.Network&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;/com/deepin/daemon/Network&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;com.deepin.daemon.Network&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        QDBusConnection::sessionBus(), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">QDBusMessage msg3_2 = inter3_2.<span class="built_in">call</span>(<span class="string">&quot;GetProxyIgnoreHosts&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; msg3_2.<span class="built_in">arguments</span>().<span class="built_in">first</span>().<span class="built_in">toString</span>();</span><br></pre></td></tr></table></figure>

<h2 id="3-3-带参调用"><a href="#3-3-带参调用" class="headerlink" title="3.3 带参调用"></a>3.3 带参调用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//3_3\ 调用DBus服务的方法-带参调用</span></span><br><span class="line">    <span class="function">QDBusInterface <span class="title">inter3_3</span><span class="params">(<span class="string">&quot;com.deepin.deepinid.Client&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="string">&quot;/com/deepin/deepinid/Client&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="string">&quot;com.deepin.deepinid.Client&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                            QDBusConnection::sessionBus(), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">inter3_3.<span class="built_in">call</span>(<span class="string">&quot;Authorize&quot;</span>, <span class="built_in">QString</span>(<span class="string">&quot;clientID&quot;</span>), <span class="built_in">QStringList</span>(<span class="string">&quot;list&quot;</span>), <span class="built_in">QString</span>(<span class="string">&quot;callback&quot;</span>), <span class="built_in">QString</span>(<span class="string">&quot;state&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="4-通过qdbus命令行查看属性值"><a href="#4-通过qdbus命令行查看属性值" class="headerlink" title="4 通过qdbus命令行查看属性值"></a>4 通过qdbus命令行查看属性值</h1><p>&#x2F;&#x2F; 获取Display服务的PrimartRect属性内容<br><code>qdbus --literal  com.deepin.daemon.Display /com/deepin/daemon/Display com.deepin.daemon.Display.PrimaryRect</code></p>
<p>&#x2F;&#x2F; 获取dock的geometry属性内容<br><code>qdbus --literal  com.deepin.dde.Dock /com/deepin/dde/Dock com.deepin.dde.Dock.geometry</code></p>
<h1 id="5-通过dbus-send命令调用服务的方法"><a href="#5-通过dbus-send命令调用服务的方法" class="headerlink" title="5 通过dbus-send命令调用服务的方法"></a>5 通过dbus-send命令调用服务的方法</h1><p>&#x2F;&#x2F; 调用方法[传参]dbus-send支持的参数类型包括：string | int16 | uint16 | int32 | uint32 | int64 | uint64 | double | byte | boolean | objpath<br><code>dbus-send --session --print-reply --dest=com.deepin.daemon.Network /com/deepin/daemon/Network com.deepin.daemon.Network.DisconnectDevice string:/org/freedesktop/NetworkManager/Devices/2</code></p>
<h1 id="6-通过dbus-monitor监听DBus信息流"><a href="#6-通过dbus-monitor监听DBus信息流" class="headerlink" title="6 通过dbus-monitor监听DBus信息流"></a>6 通过dbus-monitor监听DBus信息流</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/1136969/image.png"
                       
                 ><br>&#x2F;&#x2F; 监听服务情况,可得知消息触发源,但监听不到属性被调用<br><code>dbus-monitor --session interface=org.freedesktop.Notifications </code></p>
<p>&#x2F;&#x2F; 监听信号变化<br><code>dbus-monitor --session &quot;type=&#39;signal&#39;,interface=&#39;org.freedesktop.DBus.Properties&#39;,path=&#39;/com/deepin/dde/daemon/Dock&#39;&quot;</code></p>
<h1 id="7-通过busctl读写属性"><a href="#7-通过busctl读写属性" class="headerlink" title="7 通过busctl读写属性"></a>7 通过busctl读写属性</h1><p>&#x2F;&#x2F; 查询显示驱动相关信息<br><code>busctl get-property com.deepin.system.SystemInfo /com/deepin/system/SystemInfo com.deepin.system.SystemInfo DisplayDriver</code></p>
<p>&#x2F;&#x2F; 关闭窗管特效<br><code>busctl set-property com.deepin.wm /com/deepin/wm com.deepin.wm compositingEnabled b false</code></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>DBus</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt-动画思维导图</title>
    <url>/2023/0247906.html</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0247906/%E6%A6%82%E8%BF%B0.png"
                       
                 ></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>QT中一些常用的宏和函数</title>
    <url>/2023/0989f4c455.html</url>
    <content><![CDATA[<p>QT中一些常用的宏和函数</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Q_ASSERT<br/>Q_ASSERT_X</td>
<td>常用于断言，Release模式下不起作用</td>
</tr>
<tr>
<td>Q_ASSUME</td>
<td>&#x3D; Q_ASSERT_X + Q_UNREACHABLE</td>
</tr>
<tr>
<td>Q_COREAPP_STARTUP_FUNCTION</td>
<td>添加一个全局函数，在QCoreApplication构造时被执行。<br>要注意，这里的执行比QGuiApplication的初始化要早。</td>
</tr>
<tr>
<td>Q_DISABLE_COPY</td>
<td>禁用类的拷贝构造函数和赋值构造函数，常用于单例类的实现</td>
</tr>
<tr>
<td>Q_FOREACH</td>
<td>不在建议使用，等价于foreach关键字</td>
</tr>
<tr>
<td>Q_FOREVER</td>
<td>等价于forever关键字</td>
</tr>
<tr>
<td>Q_GLOBAL_STATIC<br>Q_GLOBAL_STATIC_WITH_ARGS</td>
<td>创建一个全局的，静态的对应类型，但相比于static Type t这种写法有一定优势</td>
</tr>
<tr>
<td>Q_LOGGING_CATEGORY</td>
<td>快速声明一个日志的category对象</td>
</tr>
<tr>
<td>Q_OS_*</td>
<td>区分不同的平台，常见的有Q_OS_ANDROID，Q_OS_LINUX，Q_OS_WIN64等</td>
</tr>
<tr>
<td>Q_PROCESSOR_*</td>
<td>区分不同的处理器环境，例如Q_PROCESSOR_ARM，Q_PROCESSOR_MIPS，Q_PROCESSOR_X86_64等</td>
</tr>
<tr>
<td>Q_LIKELY<br/>Q_UNLIKELY</td>
<td>缓存命中，提高执行效率。</td>
</tr>
<tr>
<td>Q_UNREACHABLE</td>
<td>执行到这里，程序会发生未定义的行为。常见的后果就是崩溃，用于标记永远不会执行到的语句</td>
</tr>
<tr>
<td>Q_UNUSED</td>
<td>没有用到部分参数或对象时，编译器会发出警告，使用此宏减少警告。</td>
</tr>
<tr>
<td>qAbs</td>
<td>返回参数的绝对值</td>
</tr>
<tr>
<td>qMax</td>
<td>返回两个参数中较大的一个</td>
</tr>
<tr>
<td>qMin</td>
<td>返回两个参数中较小的一个</td>
</tr>
<tr>
<td>qRound</td>
<td>返回较近的整数</td>
</tr>
<tr>
<td>qBound</td>
<td>返回最小值到最大值范围内的一个合理值</td>
</tr>
<tr>
<td>qAddPreRoutine</td>
<td>在QCoreApplication构造时执行操作</td>
</tr>
<tr>
<td>qAddPostRoutine</td>
<td>在QCoreApplication析构时执行操作</td>
</tr>
<tr>
<td>qDeleteAll</td>
<td>删除容器中的所有元素，元素必须是指针类型(注意：qDeleteAll只做元素的delete操作，并不会将元素从容器中remove，需要手动对容器进行clear)</td>
</tr>
</tbody></table>
<p>头文件</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>QtMath</td>
<td>如果你需要做一些数学计算，请包含这个头文件，包含了常用的绝对值，取整，三角计算等函数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Qt关键点</p>
<p>Qt 5.11 Qt Widgets Model&#x2F;View Programming</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>StatusNotifierItem(状态通知标准)</title>
    <url>/2023/0250816.html</url>
    <content><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a class="link"   href="https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/" >https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该规范定义了视觉项目的管理，通常是用于向用户报告应用程序状态或提供对该应用程序执行的常见操作的快速访问的图标。 它旨在补充但与 freedesktop 的桌面通知规范没有直接关系，旨在替代 freedesktop 系统托盘规范，更加面向模型视图，为工作空间提供更多自由，在图形方面更贴近它的视觉风格语言。</p>
<p>此规范未定义通知项的方面，这完全是特定于实现(状态通知)的。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0250816/image.png"
                        alt="image.png"
                 ></p>
<h3 id="示例用例将包括："><a href="#示例用例将包括：" class="headerlink" title="示例用例将包括："></a>示例用例将包括：</h3><p>混音器音量控制。</p>
<p>电池指示器。</p>
<p>即时通讯在线状态。</p>
<p>通用应用程序信息和操作，如媒体播放器控件。</p>
<h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>Status Notifier Item系统依赖于通过D-BUS的进程间通信，由三部分组成：</p>
<p>StatusNotifierItem:  每个想要使用系统状态通知机制的应用程序都应将自己的 StatusNotifierItem 注册到会话总线。</p>
<p>StatusNotifierWatcher: 用于跟踪 StatusNotifierItem 的每个活动实例的服务，StatusNotifierHost 使用它来获取所有状态通知实例的列表。它还会在添加和删除状态通知实例时发出通知。</p>
<p>StatusNotifierHost: 想要实现 StatusNotifierItem 实例可视化的应用程序必须在会话总线中注册一个 StatusNotifierHost。</p>
<h2 id="StatusNotifierItem"><a href="#StatusNotifierItem" class="headerlink" title="StatusNotifierItem"></a>StatusNotifierItem</h2><p>每个应用程序都可以通过在会话总线上注册服务 org.freedesktop.StatusNotifierItem-PID-ID 来注册任意数量的 Status Notifier Items，其中 PID 是应用程序的进程 ID，ID 是通过同一个应用程序注册的不同实例之间的任意数字的唯一标识符。</p>
<p>一旦创建了 StatusNotifierItem 的新实例，应用程序必须将唯一的实例名称注册到 StatusNotifierWatcher，见 StatusNotifierWatcher 章节。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>STRING org.freedesktop.StatusNotifierItem.Category ();</p>
<p>描述此项目的类别。</p>
<p>Category 属性的允许值为：</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationStatus</td>
<td>该项目描述了通用应用程序的状态，例如媒体播放器的当前状态。在无法知道项目类别的情况下，例如当项目被另一个不兼容或模拟的系统代理时，ApplicationStatus 可以用作合理的默认fallack。</td>
</tr>
<tr>
<td>Communications</td>
<td>该项目描述了面向通信的应用程序的状态，例如即时消息程序或电子邮件客户端。</td>
</tr>
<tr>
<td>SystemServices</td>
<td>该项目描述了系统的服务，用户没有将其视为独立的应用程序，例如磁盘索引服务活动的指示器。</td>
</tr>
<tr>
<td>Hardware</td>
<td>该项目描述了特定硬件的状态和控制，例如电池充电指示器或声卡音量控制。</td>
</tr>
</tbody></table>
<h4 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h4><p>STRING org.freedesktop.StatusNotifierItem.Id ();</p>
<p>对于这个应用程序来说,它应该是一个唯一的并且在会话之间保持一致的名称，例如应用程序名称本身。</p>
<h4 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h4><p>STRING org.freedesktop.StatusNotifierItem.Title ();</p>
<p>它是描述应用程序的名称，它可以比 Id 更具描述性。</p>
<h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>STRING org.freedesktop.StatusNotifierItem.Status ();</p>
<p>描述此项或相关应用程序的状态。</p>
<p>Status 属性的允许值为：</p>
<table>
<thead>
<tr>
<th>Status</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Passive</td>
<td>该项目不会向用户传达重要信息，它可以被视为“空闲”状态，并且可视化图形可能会选择隐藏它。</td>
</tr>
<tr>
<td>Active</td>
<td>该项目处于活动状态，更重要的是该项目将以某种方式显示给用户。</td>
</tr>
<tr>
<td>NeedsAttention</td>
<td>该项目携带对用户来说非常重要的信息，例如电池电量即将耗尽，并希望激励用户直接干预。可视化应该以某种方式强调(例如图标闪烁)具有 NeedsAttention 状态的项目。</td>
</tr>
</tbody></table>
<h4 id="WindowId"><a href="#WindowId" class="headerlink" title="WindowId"></a>WindowId</h4><p>UINT32 org.freedesktop.StatusNotifierItem.WindowId ();</p>
<p>它是窗口的依赖于窗口系统的标识符，应用程序可以通过此属性选择其窗口之一可用，或者如果它不感兴趣则设置为 0。</p>
<h4 id="IconName"><a href="#IconName" class="headerlink" title="IconName"></a>IconName</h4><p>STRING org.freedesktop.StatusNotifierItem.IconName ();</p>
<p>StatusNotifierItem 可以带有一个图标，可视化可以使用该图标来标识项目。</p>
<p>一个图标可以通过其符合 Freedesktop 的图标名称来标识，由该属性携带，或者由图标数据本身，也可由属性 IconPixmap 携带。如果两者都可用，可视化更喜欢图标名称而不是图标像素图（FIXME：目前不是很明确：如果找不到图标名称的话，是否可以将像素图用作fallback？）</p>
<h4 id="IconPixmap"><a href="#IconPixmap" class="headerlink" title="IconPixmap"></a>IconPixmap</h4><p>ARRAY(INT, INT, ARRAY BYTE) org.freedesktop.StatusNotifierItem.IconPixmap ();</p>
<p>携带图标的 ARGB32 二进制表示，本规范中使用的图标数据格式在<strong>图标</strong>章节中进行描述</p>
<h4 id="OverlayIconName"><a href="#OverlayIconName" class="headerlink" title="OverlayIconName"></a>OverlayIconName</h4><p>STRING org.freedesktop.StatusNotifierItem.OverlayIconName ();</p>
<p>被Freedesktop 兼容的图标名称。这可以被可视化用来指示额外的状态信息，例如作为主图标的叠加。</p>
<h4 id="OverlayIconPixmap"><a href="#OverlayIconPixmap" class="headerlink" title="OverlayIconPixmap"></a>OverlayIconPixmap</h4><p>ARRAY(INT, INT, ARRAY BYTE) org.freedesktop.StatusNotifierItem.OverlayIconPixmap ();</p>
<p>上一段中描述的叠加图标的 ARGB32 二进制的表示。</p>
<h4 id="AttentionIconName"><a href="#AttentionIconName" class="headerlink" title="AttentionIconName"></a>AttentionIconName</h4><p>STRING org.freedesktop.StatusNotifierItem.AttentionIconName ();</p>
<p>图标的 Freedesktop 兼容名称。可视化可以使用它来指示该项目处于 RequestingAttention 状态。</p>
<h4 id="AttentionIconPixmap"><a href="#AttentionIconPixmap" class="headerlink" title="AttentionIconPixmap"></a>AttentionIconPixmap</h4><p>ARRAY(INT, INT, ARRAY BYTE) org.freedesktop.StatusNotifierItem.AttentionIconPixmap ();</p>
<p>上一段中描述的请求注意图标的 ARGB32 二进制表示。</p>
<h4 id="AttentionMovieName"><a href="#AttentionMovieName" class="headerlink" title="AttentionMovieName"></a>AttentionMovieName</h4><p>STRING org.freedesktop.StatusNotifierItem.AttentionMovieName ();</p>
<p>项目还可以指定与 RequestingAttention 状态关联的动画。这应该是一个被 freedesktop 兼容的图标名称或完整路径。可视化可以自行决定在此属性和 AttentionIconPixmap 之间进行选择（或两者都不使用）。</p>
<h4 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h4><p>(STRING, ARRAY(INT, INT, ARRAY BYTE), STRING, STRING) org.freedesktop.StatusNotifierItem.ToolTip ();</p>
<p>描述与此项目关联的额外信息的数据结构，可以通过工具提示（或任何其他可视化认为合适的方式）进行可视化。参数的意义分别是：</p>
<p>STRING: 图标名称(被freedesktop兼容的)</p>
<p>ARRAY(INT, INT, ARRAY BYTE): 图标数据</p>
<p>STRING: 提示的标题</p>
<p>STRING: 此工具提示的描述性文本。它还可以包含 HTML 标记语言的子集，有关允许的标记列表，请参阅节<strong>标记</strong>。</p>
<h4 id="ItemIsMenu"><a href="#ItemIsMenu" class="headerlink" title="ItemIsMenu"></a>ItemIsMenu</h4><p>BOOL: 该项目仅支持上下文菜单，可视化应该更喜欢显示菜单或发送 ContextMenu() 而不是 Activate()</p>
<h4 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h4><p>OBJECT PATH: 应该实现 com.canonical.dbusmenu 接口的对象的 DBus 路径</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h4><p>VOID org.freedesktop.StatusNotifierItem.ContextMenu (INT x, INT y);</p>
<p>要求状态通知器项目显示上下文菜单，这通常是用户输入的结果，例如鼠标右键单击项目的图形表示。</p>
<p>x 和 y 参数是在当前屏幕的被点击的坐标，被用来提示菜单应该在何处显示。</p>
<h4 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h4><p>VOID org.freedesktop.StatusNotifierItem.Activate (INT x, INT y);</p>
<p>要求激活状态通知器项目，这通常是用户输入的结果，例如鼠标左键单击项目的图形表示。应用程序将执行任何被认为适当的任务作为激活请求。</p>
<p>x 和 y 参数是在当前屏幕的被点击的坐标，被认为对显示最终窗口（如果有）会有帮助。</p>
<h4 id="SecondaryActivate"><a href="#SecondaryActivate" class="headerlink" title="SecondaryActivate"></a>SecondaryActivate</h4><p>VOID org.freedesktop.StatusNotifierItem.SecondaryActivate (INT x, INT y);</p>
<p>与 Activate 相比，被认为是次要且次要的激活形式。这通常是用户输入的结果，例如在项目的图形表示上单击鼠标中键。应用程序将执行任何被认为适当的任务作为激活请求。</p>
<p>x 和 y 参数是在当前屏幕的被点击的坐标，被认为对显示最终窗口（如果有）会有帮助。</p>
<h4 id="Scroll"><a href="#Scroll" class="headerlink" title="Scroll"></a>Scroll</h4><p>VOID org.freedesktop.StatusNotifierItem.Scroll (INT delta, STRING orientation);</p>
<p>用户要求滚动操作。这是由输入引起的，例如鼠标滚轮在项目的图形表示上。</p>
<p>delta参数代表滚动量，orientation参数代表滚动请求的水平或垂直方向，其合法值为horizontal和vertical。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="NewTitle"><a href="#NewTitle" class="headerlink" title="NewTitle"></a>NewTitle</h4><p>VOID org.freedesktop.StatusNotifierItem.NewTitle ();</p>
<p>该项目有一个新标题：图形表示应立即更新此值。</p>
<h4 id="NewIcon"><a href="#NewIcon" class="headerlink" title="NewIcon"></a>NewIcon</h4><p>VOID org.freedesktop.StatusNotifierItem.NewIcon ();</p>
<p>该项目有一个新图标：图形表示应立即更新此值。</p>
<h4 id="NewAttentionIcon"><a href="#NewAttentionIcon" class="headerlink" title="NewAttentionIcon"></a>NewAttentionIcon</h4><p>VOID org.freedesktop.StatusNotifierItem.NewAttentionIcon ();</p>
<p>该项目有一个新的关注图标：图形表示应立即更新此值。</p>
<h4 id="NewOverlayIcon"><a href="#NewOverlayIcon" class="headerlink" title="NewOverlayIcon"></a>NewOverlayIcon</h4><p>VOID org.freedesktop.StatusNotifierItem.NewOverlayIcon ();</p>
<p>该项目有一个新的叠加图标：图形表示应立即更新此值。</p>
<h4 id="NewToolTip"><a href="#NewToolTip" class="headerlink" title="NewToolTip"></a>NewToolTip</h4><p>VOID org.freedesktop.StatusNotifierItem.NewToolTip ();</p>
<p>该项目有一个新的提示信息：图形表示应立即更新此值。</p>
<h4 id="NewStatus"><a href="#NewStatus" class="headerlink" title="NewStatus"></a>NewStatus</h4><p>VOID org.freedesktop.StatusNotifierItem.NewStatus (STRING status);</p>
<p>该项目有一个新的状态：图形表示应立即更新此值。</p>
<h2 id="StatusNotifierWatcher"><a href="#StatusNotifierWatcher" class="headerlink" title="StatusNotifierWatcher"></a>StatusNotifierWatcher</h2><p>任意时间都将有且只有一个 org.freedesktop.StatusNotifierWatcher 服务实例在会话中被注册。 此服务用于跟踪 StatusNotifierItem 实例，枚举它们并在注册新实例或取消注册旧的实例时发出通知。</p>
<p>它还用于跟踪 org.freedesktop.StatusNotifierHost 实例，以便有一种简单的方法来了解是否至少有一个服务被注册用于StatusNotifierItem的可视化工作(即显示这些状态通知图标)。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="RegisterStatusNotifierItem"><a href="#RegisterStatusNotifierItem" class="headerlink" title="RegisterStatusNotifierItem"></a>RegisterStatusNotifierItem</h4><p>VOID org.freedesktop.StatusNotifierWatcher.RegisterStatusNotifierItem (STRING service);</p>
<p>将 StatusNotifierItem 以其在会话总线上的全名形式注册到 StatusNotifierWatcher 中，例如 org.freedesktop.StatusNotifierItem-4077-1。 StatusNotifierItem 实例必须注册到观察者(Watcher服务)，以便被观察者和 StatusNotifierHost 实例注意到。 如果注册的 StatusNotifierItem 离开会话总线，StatusNotifierWatcher 应该自动注意到它并将其从注册服务列表中删除。</p>
<h4 id="RegisterStatusNotifierHost"><a href="#RegisterStatusNotifierHost" class="headerlink" title="RegisterStatusNotifierHost"></a>RegisterStatusNotifierHost</h4><p>VOID org.freedesktop.StatusNotifierWatcher.RegisterStatusNotifierHost (STRING service);</p>
<p>将 StatusNotifierHost 注册到 StatusNotifierWatcher 中，以其在会话总线上的全名形式，例如 org.freedesktop.StatusNotifierHost-4005。 每个打算显示 StatusNotifierItem 内容的 NotficationHost 实例都应该使用此方法注册到 StatusNotifierWatcher。 当每个 StatusNotifierHost 消失时，StatusNotifierWatcher 应该自动通知。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h4 id="RegisteredStatusNotifierItems"><a href="#RegisteredStatusNotifierItems" class="headerlink" title="RegisteredStatusNotifierItems"></a>RegisteredStatusNotifierItems</h4><p>ARRAY(STRING) org.freedesktop.StatusNotifierWatcher.RegisteredStatusNotifierItems ();</p>
<p>包含 StatusNotifierItem 的所有已注册实例的列表。数组的所有元素都应对应于方法调用时会话总线上实际运行的服务。</p>
<h4 id="IsStatusNotifierHostRegistered"><a href="#IsStatusNotifierHostRegistered" class="headerlink" title="IsStatusNotifierHostRegistered"></a>IsStatusNotifierHostRegistered</h4><p>BOOL org.freedesktop.StatusNotifierWatcher.IsStatusNotifierHostRegistered ();</p>
<p>如果至少有一个 StatusNotifierHost 已向名为 RegisterStatusNotifierHost 的部分注册并且当前正在运行，则为真。如果没有注册和运行 StatusNotifierHost，则所有 StatusNotifierItem 实例都应使用 Freedesktop 系统托盘规范作为替代实现。</p>
<h4 id="ProtocolVersion"><a href="#ProtocolVersion" class="headerlink" title="ProtocolVersion"></a>ProtocolVersion</h4><p>INT org.freedesktop.StatusNotifierWatcher.ProtocolVersion ();</p>
<p>StatusNotifierWatcher 实例实现的协议版本。</p>
<h3 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h3><h4 id="StatusNotifierItemRegistered"><a href="#StatusNotifierItemRegistered" class="headerlink" title="StatusNotifierItemRegistered"></a>StatusNotifierItemRegistered</h4><p>BOOL org.freedesktop.StatusNotifierWatcher.StatusNotifierItemRegistered (STRING service);</p>
<p>一个新的 StatusNotifierItem服务被注册了，信号的参数是实例的会话总线名称。 StatusNotifierHost 实现应该监听此信号以了解他们何时应该更新状态通知信息。</p>
<h4 id="StatusNotifierItemUnregistered"><a href="#StatusNotifierItemUnregistered" class="headerlink" title="StatusNotifierItemUnregistered"></a>StatusNotifierItemUnregistered</h4><p>BOOL org.freedesktop.StatusNotifierWatcher.StatusNotifierItemUnregistered (STRING service);</p>
<p>同上面的信号，当一个已经注册的StatusNotifierItem服务取消注册时发出。</p>
<h4 id="StatusNotifierHostRegistered"><a href="#StatusNotifierHostRegistered" class="headerlink" title="StatusNotifierHostRegistered"></a>StatusNotifierHostRegistered</h4><p>BOOL org.freedesktop.StatusNotifierWatcher.StatusNotifierHostRegistered ();</p>
<p>已注册新的 StatusNotifierHost，StatusNotifierItem 实例知道它们可以使用此协议而不是 freedesktop 系统托盘协议。</p>
<h2 id="StatusNotifierHost"><a href="#StatusNotifierHost" class="headerlink" title="StatusNotifierHost"></a>StatusNotifierHost</h2><p>StatusNotifierHost 是对应的应用程序中的一个对象，该对象负责注册的 StatusNotifierItem 实例的实际图形显示。</p>
<p>此服务的实例在 Dbus 会话总线上注册，名称为 org.freedesktop.StatusNotifierHost-id，其中 id 是唯一标识符，它使名称在总线上保持唯一，例如应用程序的进程 ID。如果同一进程注册了多个 StatusNotifierHost，则为另一种类型的标识符。</p>
<p>StatusNotifierHost 实例不需要任何特定的属性、方法或信号注册到总线。重要的是服务在总线上的存在，以通知 StatusNotifierWatcher当前有一个应用程序在负责 StatusNotifierItem 在图形层面的显示。</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>工具提示的子文本可能包含标记。标记是基于 XML 的，由 XHTML 的一小部分组成。</p>
<p>StatusNotifierHost 可视化应支持以下标签。虽然它是可选的，但它是推荐的。不支持这些标签的 StatusNotifierHost 应该将它们过滤掉。</p>
<table>
<thead>
<tr>
<th>tags</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;b&gt; ... &lt;/b&gt;</code></td>
<td>加粗</td>
</tr>
<tr>
<td><code>&lt;i&gt; ... &lt;/i&gt;</code></td>
<td>斜体</td>
</tr>
<tr>
<td><code>&lt;u&gt; ... &lt;/u&gt;</code></td>
<td>下划线</td>
</tr>
<tr>
<td><code>&lt;a href=&quot;...&quot;&gt; ... &lt;/a&gt;</code></td>
<td>超链接</td>
</tr>
</tbody></table>
<p>图像可以与绝对路径名一起用作图像源。 alt 标签是强制性的。</p>
<p>本规范不需要完整的 HTML 实现，并且通知永远不应利用上面未列出的标签。 由于工具提示不能替代复杂的对话框，因此不需要高级布局，并且实际上可能会由于内存使用和屏幕空间而限制该系统可以运行的数量。 此类示例包括 PDA、某些手机和内存不足的慢速 PC 或掌上电脑。</p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>所有图标都可以通过其数据的特定序列化在总线上传输，能够表示同一图像的多种分辨率或相同尺寸图像的简短瞄准。</p>
<p>图标在签名为 a(iiay) 的原始图像数据结构数组中传输，每个图标分别描述宽度、高度和图像数据。数据以 ARGB32 格式表示，并采用网络字节顺序，以便于小端和大端机器之间的网络通信。</p>
<p>出于同样的原因，使用 XSLT 或 CSS 样式表的完整 XML 或 XHTML 实现不是本规范的一部分。必须以更复杂的形式呈现的信息应该使用特定于应用程序的对话框、Web 浏览器或其他一些显示机制。</p>
<p>上面指定的标签标记内容的方式允许它们在某些实现中被剥离而不影响实际内容。</p>
]]></content>
      <categories>
        <category>Freedesktop</category>
      </categories>
      <tags>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>UOS桌面启动流程图</title>
    <url>/2023/03918.html</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/03918/1.jpg"
                       
                 ></p>
]]></content>
      <tags>
        <tag>UOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Wayland Coding 速记-Staging</title>
    <url>/2024/05df3c7382.html</url>
    <content><![CDATA[<p>因工作需要加之个人比较感兴趣的原因，在实现 Wayland 合成器相关协议之途中，随笔记录记录一些相关的基础知识。</p>
<span id="more"></span>

<p><a name="Tmrp0"></a></p>
<h2 id="Wayland"><a href="#Wayland" class="headerlink" title="Wayland"></a>Wayland</h2><p>关于 wayland 的总结，个人觉得下面一段话挺好：</p>
<blockquote>
<p>WaylandWayland is a replacement for the X11 window system protocol and architecture with the aim to be easier to develop, extend, and maintain.<br /></p>
<p>WaylandWayland 是 X11 窗口系统协议和架构的替代品，旨在更易于开发、扩展和维护。<br /></p>
<p>Wayland is the language (protocol) that applications can use to talk to a display server in order to make themselves visible and get input from the user (a person). A Wayland server is called a “compositor”. Applications are Wayland clients.<br /></p>
<p>Wayland 是应用程序可用来与显示服务器对话的语言（协议），以便使自己可见并获取用户（人）的输入。 Wayland 服务器被称为“合成器”。应用程序是 Wayland 客户端。<br /></p>
<p>Wayland also refers to a system architecture. It is not just a server-client relationship between a compositor and applications. There is no single common Wayland server like Xorg is for X11, but every graphical environment brings with it one of many compositor implementations. Window management and the end user experience are often tied to the compositor rather than swappable components.<br /></p>
<p>Wayland 也指一种系统架构。它不仅仅是合成器和应用程序之间的服务器-客户端关系。没有像 Xorg 那样适用于 X11 的单一通用 Wayland 服务器，但每个图形环境都带来了许多合成器实现之一。窗口管理和最终用户体验通常与合成器而不是可交换组件相关。<br /></p>
<p>A core part of Wayland architecture is libwayland: an inter-process communication library that translates a protocol definition in XML to a C language API. This library does not implement Wayland, it merely encodes and decodes Wayland messages. The actual implementations are in the various compositor and application toolkit projects.<br /></p>
<p>Wayland 架构的核心部分是 libwayland：一个进程间通信库，它将 XML 中的协议定义转换为 C 语言 API。该库没有实现 Wayland，它只是对 Wayland 消息进行编码和解码。实际的实现是在各种合成器和应用程序工具包项目中。<br /></p>
<p>Wayland does not restrict where and how it is used. A Wayland compositor could be a standalone display server running on Linux kernel modesetting and evdev input devices or on many other operating systems, or a nested compositor that itself is an X11 or Wayland application (client). Wayland can even be used in application-internal communication as is done in some web browsers.<br /></p>
<p>Wayland 不限制其使用地点和方式。 Wayland 合成器可以是在 Linux 内核模式设置和 evdev 输入设备或许多其他操作系统上运行的独立显示服务器，也可以是本身就是 X11 或 Wayland 应用程序（客户端）的嵌套合成器。 Wayland 甚至可以用于应用程序内部通信，就像某些 Web 浏览器中所做的那样。<br /></p>
<p>Part of the Wayland project is also the Weston reference implementation of a Wayland compositor. Weston can run as an X client or under Linux KMS and ships with a few demo clients. The Weston compositor is a minimal and fast compositor and is suitable for many embedded and mobile use cases.</p>
<p>Wayland 项目的一部分也是 Wayland 合成器的 Weston 参考实现。 Weston 可以作为 X 客户端或在 Linux KMS 下运行，并附带一些演示客户端。 Weston 合成器是一个最小且快速的合成器，适用于许多嵌入式和移动用例。</p>
</blockquote>
<p><a name="LJoxs"></a></p>
<h2 id="开发库"><a href="#开发库" class="headerlink" title="开发库"></a>开发库</h2><p>后续开发内容均基于 libwayland-dev 进行。</p>
<p><a name="yTd8M"></a></p>
<h3 id="主要结构体"><a href="#主要结构体" class="headerlink" title="主要结构体"></a>主要结构体</h3><table>
<thead>
<tr>
<th><strong>Struct</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>wl_display</td>
<td>代表一个 Wayland 显示服务器的连接。它用于管理客户端和服务器之间的通信和事件处理</td>
<td>struct wl_display *wl_display_create(void);<br />void wl_display_run(struct wl_display *display);<br />struct wl_list *wl_display_get_client_list(struct wl_display *display);</td>
</tr>
<tr>
<td>wl_global</td>
<td>用于描述全局对象。这些全局对象在 Wayland 显示服务器中注册，可以被客户端发现和使用。<strong>wl_global</strong> 对象通常表示服务器中提供的某些功能或接口，例如 compositor、shell、seat 等</td>
<td>struct wl_global *wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind);</td>
</tr>
<tr>
<td>wl_event_loop</td>
<td>用于管理事件循环。在 Wayland 服务器中，事件循环用于处理来自客户端的请求、内部超时事件以及文件描述符上的事件。</td>
<td>struct wl_event_loop *wl_event_loop_create(void);<br />void wl_event_loop_destroy(struct wl_event_loop *loop);</td>
</tr>
<tr>
<td>wl_event_source</td>
<td>用于描述一个事件源。在 Wayland 服务器的事件循环中，事件源可以是文件描述符事件、定时器事件或信号事件。</td>
<td>struct wl_event_source *wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data);</td>
</tr>
<tr>
<td>wl_interface</td>
<td>用于描述 Wayland 协议中的接口。接口是 Wayland 协议的基本构建块，定义了客户端和服务器之间可以进行的交互。每个接口包括一组方法（requests）和事件（events）。</td>
<td>struct wl_interface {<br />    const char *name;<br />    int version;<br />    int method_count;<br />    const struct wl_message *methods;<br />    int event_count;<br />    const struct wl_message *events;<br />};</td>
</tr>
<tr>
<td>wl_message</td>
<td>用于描述接口中的每个方法和事件。</td>
<td>static const struct wl_message my_interface_events[] &#x3D; { { “something_done”, “s”, NULL }  &#x2F;&#x2F; “s” 表示事件发送一个字符串参数 };</td>
</tr>
<tr>
<td>wl_resource</td>
<td>用于表示 Wayland 客户端与服务器之间的一个协议对象。它在客户端和服务器之间传递方法调用和事件通知。每个 <strong>wl_resource</strong> 都与一个特定的 <strong>wl_interface</strong>（接口）相关联，表示该接口的一个实例。</td>
<td>struct wl_resource *wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id);<br />void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy);</td>
</tr>
<tr>
<td>wl_surface</td>
<td>代表了一个可供客户端绘制的表面（Surface）。它是构建用户界面的基本单元，可以是窗口、按钮、文本框等可见的元素。<strong>wl_surface</strong> 通过 Wayland 协议与客户端和服务器进行通信，客户端可以向 <strong>wl_surface</strong> 发送绘图指令，服务器则负责将这些指令转换为屏幕上的图像。</td>
<td></td>
</tr>
<tr>
<td>wl_output</td>
<td>Wayland 中用于表示显示器（output）的接口。每个 <strong>wl_output</strong> 对象代表了系统中的一个物理显示设备，比如显示器或投影仪。通过 <strong>wl_output</strong> 接口，客户端程序可以获取有关显示器的信息，如分辨率、缩放因子、物理尺寸、制造商信息等，并接收显示器的事件，如模式更改、连接状态变化等。</td>
<td>wl_output_add_geometry_listener</td>
</tr>
<tr>
<td>wl_client</td>
<td>用于表示一个连接到 Wayland 服务器的客户端。它负责管理客户端连接、处理客户端的请求，并向客户端发送事件</td>
<td>struct wl_client *wl_resource_get_client(struct wl_resource *resource);<br />void wl_client_post_no_memory(struct wl_client *client);<br />void wl_client_post_implementation_error(struct wl_client *client, const char *msg);<br />void wl_client_post_event(struct wl_client *client, uint32_t opcode, …);</td>
</tr>
<tr>
<td>wl_signal</td>
<td>用于实现发布-订阅模式的信号机制。它允许对象在状态变化时通知感兴趣的侦听器（监听器）。<strong>wl_signal</strong> 是一个简单但功能强大的机制，可以在 Wayland 服务端内部或者在客户端与服务端之间传递事件通知。</td>
<td>struct wl_signal my_signal;<br />wl_signal_init(&amp;my_signal);<br />void my_signal_handler(struct wl_listener *listener, void *data) {<br />    printf(“Signal received with data: %s\n”, (char *)data);<br />}<br />struct wl_listener my_listener;<br />my_listener.notify &#x3D; my_signal_handler;<br />wl_signal_add(&amp;my_signal, &amp;my_listener);<br />&#x2F;&#x2F; send signal to notify all listener<br />const char *signal_data &#x3D; “Hello, World!”;<br />wl_signal_emit(&amp;my_signal, (void *)signal_data);</td>
</tr>
<tr>
<td>wl_listener</td>
<td>用于监听 <strong>wl_signal</strong> 发出的信号。每个 <strong>wl_listener</strong> 都包含一个回调函数，当监听的信号发出时，该回调函数会被调用。这种机制使得对象之间的通信变得更加灵活和解耦。</td>
<td>struct wl_listener {<br />    struct wl_list link;<br />    wl_notify_func_t notify;<br />};<br />struct wl_listener my_listener;<br />my_listener.notify &#x3D; my_signal_handler; &#x2F;&#x2F; 设置回调函数<br />wl_signal_add(&amp;my_signal, &amp;my_listener); &#x2F;&#x2F; 将监听器添加到信号中</td>
</tr>
<tr>
<td>wl_list</td>
<td>Wayland 核心库中的一个双向链表实现，用于在 Wayland 内部和相关组件中进行列表管理</td>
<td>struct wl_list {<br />    struct wl_list *prev;<br />    struct wl_list *next;<br />};<br />void wl_list_init(struct wl_list *list);<br />void wl_list_insert(struct wl_list *list, struct wl_list *elm);<br />void wl_list_remove(struct wl_list *elm);<br />wl_list_for_each &amp; wl_list_for_each_safe</td>
</tr>
<tr>
<td>wl_shm_buffer</td>
<td>Wayland 的共享内存（Shared Memory）缓冲区，用于在客户端和服务器之间共享图像数据。它允许客户端将图像数据写入共享内存，然后将该内存区域作为缓冲区发送到服务器。服务器可以直接访问这个共享内存，从而避免了数据的拷贝，提高了效率</td>
<td></td>
</tr>
<tr>
<td>wl_shm_pool</td>
<td>Wayland 提供的一个共享内存池，用于在客户端和服务器之间共享图像数据。<strong>wl_shm_pool</strong> 是通过 Wayland 的 <strong>wl_shm</strong> 接口创建的，它允许客户端从共享内存中分配多个缓冲区。这些缓冲区可以被客户端用来绘制图像，并将其传递给服务器显示。</td>
<td></td>
</tr>
<tr>
<td>wl_protocol_logger</td>
<td>用于记录 Wayland 协议的消息。它允许开发者记录客户端和服务器之间交换的协议消息，方便调试和分析 Wayland 协议的使用情况。</td>
<td>struct wl_protocol_logger {<br />    void (*log)(void *user_data, struct wl_resource *resource,<br />                uint32_t opcode, const struct wl_message *message,<br />                union wl_argument *args);<br />    void *user_data;<br />};<br /><br />struct wl_protocol_logger logger &#x3D; { <br />.log &#x3D; protocol_log, <br />.user_data &#x3D; “Wayland”  &#x2F;&#x2F; 这里可以传递任何用户数据<br /> }; <br />wl_display_add_protocol_logger(display, &amp;logger);</td>
</tr>
<tr>
<td>wl_display_add_destroy_listener</td>
<td>绑定到一个 wl_listener 结构，通过指定 wl_listener 的.notify成员实现对 display 销毁时的监听<br />用于在 wl_display 对象销毁时注册一个回调函数。这个回调函数会在 wl_display 对象销毁时被调用，以便进行清理或其他必要的操作。</td>
<td>manager-&gt;display_destroy.notify &#x3D; handle_display_destroy;<br />    wl_display_add_destroy_listener(display, &amp;manager-&gt;display_destroy);</td>
</tr>
</tbody></table>
<p><a name="jKOh5"></a></p>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><table>
<thead>
<tr>
<th><strong>Function</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>wl_display_add_destroy_listener</td>
<td>绑定到一个 wl_listener 结构，通过指定 wl_listener 的.notify成员实现对 display 销毁时的监听<br />用于在 wl_display 对象销毁时注册一个回调函数。这个回调函数会在 wl_display 对象销毁时被调用，以便进行清理或其他必要的操作。</td>
<td>manager-&gt;display_destroy.notify &#x3D; handle_display_destroy;<br />    wl_display_add_destroy_listener(display, &amp;manager-&gt;display_destroy);</td>
</tr>
<tr>
<td>wl_event_loop_add_destroy_listener</td>
<td>用于向事件循环添加一个监听器，以便在事件循环被销毁时触发回调函数。</td>
<td>struct wl_listener *wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, wl_listener *listener);</td>
</tr>
<tr>
<td>wl_global_create</td>
<td>用于创建一个全局对象，并将其注册到 Wayland 显示服务器上。全局对象可以被客户端程序获取并使用，从而实现客户端和服务器之间的通信。</td>
<td>struct wl_global *wl_global_create(struct wl_display *display,<br />                                   const struct wl_interface *interface,<br />                                   int version,<br />                                   void *data,<br />                                   wl_global_bind_func_t bind);</td>
</tr>
<tr>
<td>wl_global_remove</td>
<td>类似wl_global_destroy，但并不销毁。通常使用 wl_global_destroy 即可</td>
<td></td>
</tr>
<tr>
<td>wl_global_destroy</td>
<td>销毁一个全局对象。</td>
<td></td>
</tr>
<tr>
<td>wl_resource_set_implementation</td>
<td>用于将一组回调函数（即接口实现）和用户数据关联到一个 <strong>wl_resource</strong> 对象。每当与该资源相关的客户端请求到达时，Wayland 会调用相应的回调函数，从而实现具体的行为。</td>
<td>void wl_resource_set_implementation(struct wl_resource *resource,<br /> const void *implementation,<br />void *data,<br /> wl_resource_destroy_func_t destroy);</td>
</tr>
<tr>
<td>wl_resource_set_user_data</td>
<td>用于将用户自定义的数据与特定的 <strong>wl_resource</strong> 资源关联起来。这使得在处理资源相关的回调时，可以访问和使用这些用户数据。</td>
<td>void wl_resource_set_user_data(struct wl_resource *resource, void *user_data);</td>
</tr>
<tr>
<td>wl_display_roundtrip</td>
<td>Wayland 客户端程序中常用的函数之一，用于同步地发送请求并等待服务器对请求的响应。它会阻塞当前线程，直到服务器返回响应或者发生错误。</td>
<td>int wl_display_roundtrip(struct wl_display *display);</td>
</tr>
<tr>
<td>wl_resource_get_user_data</td>
<td>用于获取与特定 <strong>wl_resource</strong> 资源关联的用户数据。这个函数通常与 <strong>wl_resource_set_user_data</strong> 一起使用，后者用于将用户数据与资源关联。</td>
<td>void *wl_resource_get_user_data(struct wl_resource *resource);</td>
</tr>
</tbody></table>
<p><a name="Vw3Mb"></a></p>
<h3 id="核心文件"><a href="#核心文件" class="headerlink" title="核心文件"></a>核心文件</h3><p>wayland-server-core.h</p>
<p><a name="ICOD6"></a></p>
<h2 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h2><p>详见: <a class="link"   href="https://wayland.app/protocols/" >https://wayland.app/protocols/<i class="fas fa-external-link-alt"></i></a><br>:::success<br><em>实际上，wayland 合成器就是一组协议的实现者。</em><br>:::<br>wayland 协议大致分为 core(核心)、stable(稳定)、staging(考虑中，可能会变为稳定)、unstable(不稳定)等，表明其当前状态，出于兼容考虑，合成器的开发应且务必实现 core 和 stable 协议，视情况需要实现部分 unstable 或其它甚至是自定义协议。</p>
<p><a name="AgOPi"></a></p>
<h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Wayland</td>
<td>Wayland 核心协议，这个文件定义了客户端和服务器之间通信的标准接口，包括各种对象、请求和事件。是使用其他协议的前提。</td>
</tr>
</tbody></table>
<p><a name="mcV5i"></a></p>
<h3 id="Stable"><a href="#Stable" class="headerlink" title="Stable"></a>Stable</h3><table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Presentation time</td>
<td>Presentation-Time 协议是为了解决音频与视频同步播放时出现的问题而设计的。它允许客户端在显示器上的特定时间点提交图像，以确保图像在预期时间显示，从而实现音频和视频的同步播放。</td>
</tr>
<tr>
<td>Viewporter</td>
<td>它旨在支持客户端动态调整输出显示区域（viewport）的大小和位置。这个协议特别适用于需要对输出进行缩放、平移或裁剪的应用场景，比如 VR（虚拟现实）和多显示器环境下的窗口管理器等。</td>
</tr>
<tr>
<td>XDG shell</td>
<td>定义了一种标准的方式来管理窗口和窗口管理器之间的通信，使得窗口的创建、调整和销毁等操作能够在 Wayland 环境下进行。</td>
</tr>
<tr>
<td>Linux DMA-BUF</td>
<td>Linux 内核中用于在设备之间共享内存的机制。DMA-BUF 全称是 Direct Memory Access Buffer，它允许不同的设备（如图形处理器、显示器、摄像头等）直接访问内核中的一块共享内存区域，而无需复制数据到每个设备的私有内存中。</td>
</tr>
<tr>
<td>Tablet</td>
<td>旨在提供对触摸板和手写板等输入设备的更丰富支持。它定义了一组标准接口，使得客户端能够更好地与这些特殊输入设备进行交互，并实现更丰富的用户体验。</td>
</tr>
</tbody></table>
<p><a name="sOLys"></a></p>
<h3 id="Staging"><a href="#Staging" class="headerlink" title="Staging"></a>Staging</h3><table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>XDG activation</td>
<td>旨在提供一种标准化的方式来启动和激活桌面应用程序。它定义了一组接口，允许应用程序和桌面环境之间进行通信，以便启动应用程序、切换窗口焦点、和处理用户交互。</td>
</tr>
<tr>
<td>DRM lease</td>
<td>允许应用程序临时租用图形硬件资源，例如显示器和显卡，从而绕过窗口系统，直接控制这些资源。这在虚拟现实（VR）和增强现实（AR）等需要低延迟和高性能图形渲染的应用中尤为重要。</td>
</tr>
<tr>
<td>DRM synchronization object</td>
<td>用于在图形渲染过程中协调和同步不同操作和资源的使用。它们在确保图形管线中的各个阶段按正确顺序执行、避免资源竞争和数据不一致方面发挥着关键作用。</td>
</tr>
<tr>
<td>Session lock</td>
<td>用于保护用户会话安全，防止未授权的访问。当用户暂时离开工作站时，可以锁定会话以确保其正在运行的应用程序和数据不会被其他人查看或篡改。</td>
</tr>
<tr>
<td>Single-pixel buffer</td>
<td>专门用于优化小图形元素的传输和渲染。它的主要目标是提供一种高效的方式来处理单个像素的图形操作，这对于某些类型的图形应用程序（如光标、点状图形、单色图形元素等）非常重要。</td>
</tr>
<tr>
<td>Content type hint</td>
<td>允许客户端向合成器（compositor）提供关于表面（surface）内容类型的提示。这些提示有助于合成器优化渲染和处理不同类型的内容，提高显示性能和视觉效果。</td>
</tr>
<tr>
<td>Idle notify</td>
<td>使客户端能够接收用户空闲状态的通知，从而在用户不活动时执行特定任务。这种机制有助于优化系统资源使用，提高用户体验，特别是在屏幕保护和节能模式等应用场景中。通过合理使用该协议，开发者可以显著提升应用程序的智能化和响应能力。</td>
</tr>
<tr>
<td>Tearing control</td>
<td>旨在解决屏幕撕裂问题。屏幕撕裂是在显示器刷新过程中，显示的图像部分来自于不同的帧，导致图像出现不连续的现象。这种现象在快速运动的场景中特别明显。Tearing Control 协议通过提供机制让客户端和合成器协作，来减少或消除屏幕撕裂，提高显示效果和用户体验。</td>
</tr>
<tr>
<td>Xwayland shell</td>
<td>Xwayland 是 Wayland 的一个兼容层，使得 X11 应用程序可以在 Wayland 合成器上运行。Xwayland Shell 协议是一个特定的 Wayland 扩展协议，旨在为运行在 Xwayland 上的 X11 客户端提供更好的窗口管理和集成支持。这个协议使得 Wayland 合成器能够更好地控制和管理这些 X11 窗口，从而提高整体用户体验。</td>
</tr>
<tr>
<td>Fractional scale</td>
<td>用于支持显示器的分数缩放（Fractional Scaling）。传统的显示器缩放通常只支持整数比例，例如 1x、2x、3x 等，这可能无法完全满足高分辨率显示器上的 UI 缩放需求。Fractional Scale 协议允许用户以分数形式（如 1.25x、1.5x、1.75x 等）调整 UI 的缩放级别，以更好地适应高分辨率显示器和不同的视觉需求。</td>
</tr>
<tr>
<td>Cursor shape</td>
<td>旨在允许客户端动态地改变鼠标指针的形状。这个协议使得应用程序可以根据需要更改鼠标指针的外观，以提供更好的用户体验和交互反馈。</td>
</tr>
<tr>
<td>Foreign toplevel list</td>
<td>旨在提供一种机制，让 Wayland 合成器（compositor）可以跟踪和管理来自外部系统的顶层窗口（例如 X11 窗口）。通过这个协议，Wayland 合成器可以更好地集成和管理来自不同窗口系统的窗口，提供更统一的用户体验。</td>
</tr>
<tr>
<td>Security context</td>
<td>Security Context 协议为 Wayland 提供了一种机制，允许客户端和服务端在通信中传递安全上下文信息，增强通信的安全性。尽管该协议需要客户端和服务端的正确实现，并可能带来一定的性能开销，但它能够有效地保护通信内容的机密性和完整性，并支持基于权限的访问控制，从而提高了 Wayland 通信的安全性。</td>
</tr>
<tr>
<td>Transient seat</td>
<td>它允许在同一系统上的不同输入设备之间建立父子关系。这种关系对于多屏幕系统或者具有多个输入设备的系统非常有用，它能够确保特定的输入设备（例如触摸板或者鼠标）仅控制特定的屏幕或应用程序。</td>
</tr>
<tr>
<td>XDG toplevel drag</td>
<td>用于实现在 Wayland 上对窗口进行拖动操作。这个协议允许用户在屏幕上拖动应用程序的顶层窗口，以便更改其位置或将其拖入其他工作区等。XDG Toplevel Drag 协议的实现使得用户能够通过简单的拖动操作来管理和组织窗口，提高了桌面环境的交互性和可用性。</td>
</tr>
<tr>
<td>XDG dialog windows</td>
<td>旨在为桌面环境提供一种标准化的方式来管理对话框窗口。该协议定义了一组接口和事件，用于创建、显示和管理对话框窗口，并规定了对话框窗口的行为和外观，以提供更一致的用户体验。</td>
</tr>
<tr>
<td>Alpha modifier protocol</td>
<td>它允许客户端与服务器协商窗口表面（surface）的 Alpha 值，以实现窗口的透明度调整。</td>
</tr>
</tbody></table>
<p>其他协议请查阅：<a class="link"   href="https://wayland.app/protocols/" >https://wayland.app/protocols/<i class="fas fa-external-link-alt"></i></a></p>
<p><a name="Z39oa"></a></p>
<h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p>使用 wayland-scanner 命令将协议文件(XML)生成胶水代码，如果是服务端，需设置新协议的实现，客户端直接调用胶水代码的接口即可。<br><a name="RzRTz"></a></p>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>参考 <a class="link"   href="https://gitlab.freedesktop.org/wlroots/wlroots/-/tree/0.17?ref_type=heads" >wlroots<i class="fas fa-external-link-alt"></i></a> 项目，不再赘述。<br />附一些之前手写的合成器对 <a class="link"   href="https://wayland.app/protocols/ext-session-lock-v1" >ext_session_lock_v1<i class="fas fa-external-link-alt"></i></a> 协议支持的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ext-session-lock-server-protocol.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_event_loop</span> *<span class="title">event_loop</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_global</span> *<span class="title">global</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_list</span> <span class="title">contexts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_listener</span> <span class="title">display_destroy</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">lock</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">destroy</span>;</span></span><br><span class="line">    &#125; events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_list</span> <span class="title">contexts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">get_lock_surface</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">unlock_and_destroy</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">destroy</span>;</span></span><br><span class="line">    &#125; events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">surface</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">output</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">ack_configure</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">wl_signal</span> <span class="title">destroy</span>;</span></span><br><span class="line">    &#125; events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_v1_destroy</span><span class="params">(<span class="keyword">struct</span> ext_session_lock_v1 *context)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_surface_v1_destroy</span><span class="params">(<span class="keyword">struct</span> ext_session_lock_surface_v1 *context)</span>;</span><br><span class="line"><span class="keyword">struct</span> ext_session_lock_manager_v1 *<span class="title function_">ext_session_lock_manager_v1_create</span><span class="params">(<span class="keyword">struct</span> wl_display *display)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ext_session_lock_manager_impl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_surface_handle_destroy</span><span class="params">(<span class="keyword">struct</span> wl_client *client, <span class="keyword">struct</span> wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    wl_resource_destroy(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lock_surface_handle_ack_configure</span><span class="params">([[maybe_unused]] <span class="keyword">struct</span> wl_client *client,</span></span><br><span class="line"><span class="params">                                              <span class="keyword">struct</span> wl_resource *resource,</span></span><br><span class="line"><span class="params">                                              <span class="type">uint32_t</span> serial)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_surface_v1 *&gt;(wl_resource_get_user_data(resource));</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.ack_configure, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1_interface</span> <span class="title">lock_surface_implementation</span> =</span> &#123;</span><br><span class="line">    .destroy = lock_surface_handle_destroy,</span><br><span class="line">    .ack_configure = lock_surface_handle_ack_configure,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_surface_v1_destroy</span><span class="params">(<span class="keyword">struct</span> ext_session_lock_surface_v1 *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.destroy, context);</span><br><span class="line">    <span class="built_in">free</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_surface_v1_destroy_func</span><span class="params">(wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_surface_v1 *&gt;(wl_resource_get_user_data(resource));</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ext_session_lock_surface_v1_destroy(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lock_handle_get_lock_surface</span><span class="params">(<span class="keyword">struct</span> wl_client *client,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">struct</span> wl_resource *lock_resource,</span></span><br><span class="line"><span class="params">                                         <span class="type">uint32_t</span> id,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">struct</span> wl_resource *surface,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">struct</span> wl_resource *output)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_v1 *&gt;(wl_resource_get_user_data(lock_resource));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">resource</span> =</span> wl_resource_create(client,</span><br><span class="line">                                                      &amp;ext_session_lock_surface_v1_interface,</span><br><span class="line">                                                      EXT_SESSION_LOCK_V1_DESTROY_SINCE_VERSION,</span><br><span class="line">                                                      id);</span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wl_resource_post_no_memory(lock_resource);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1</span> *<span class="title">lock_surface</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_surface_v1 *&gt;(<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*lock_surface)));</span><br><span class="line">    <span class="keyword">if</span> (lock_surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wl_resource_post_no_memory(lock_resource);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wl_resource_set_implementation(resource,</span><br><span class="line">                                   &amp;lock_surface_implementation,</span><br><span class="line">                                   lock_surface,</span><br><span class="line">                                   ext_session_lock_surface_v1_destroy_func);</span><br><span class="line"></span><br><span class="line">    wl_resource_set_user_data(resource, lock_surface);</span><br><span class="line"></span><br><span class="line">    wl_signal_init(&amp;lock_surface-&gt;events.ack_configure);</span><br><span class="line">    wl_signal_init(&amp;lock_surface-&gt;events.destroy);</span><br><span class="line"></span><br><span class="line">    lock_surface-&gt;resource = resource;</span><br><span class="line">    lock_surface-&gt;surface = surface;</span><br><span class="line">    lock_surface-&gt;output = output;</span><br><span class="line">    lock_surface-&gt;id = id;</span><br><span class="line"></span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.get_lock_surface, lock_surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lock_handle_destroy</span><span class="params">([[maybe_unused]] <span class="keyword">struct</span> wl_client *client,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    wl_resource_destroy(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lock_handle_unlock_and_destroy</span><span class="params">(<span class="keyword">struct</span> wl_client *client, <span class="keyword">struct</span> wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_v1 *&gt;(wl_resource_get_user_data(resource));</span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.unlock_and_destroy, context);</span><br><span class="line">    lock_handle_destroy(client, resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1_interface</span> <span class="title">lock_implementation</span> =</span> &#123;</span><br><span class="line">    .destroy = lock_handle_destroy,</span><br><span class="line">    .get_lock_surface = lock_handle_get_lock_surface,</span><br><span class="line">    .unlock_and_destroy = lock_handle_unlock_and_destroy,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">manager_handle_destroy</span><span class="params">(<span class="keyword">struct</span> wl_client *client, <span class="keyword">struct</span> wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_manager_v1 *&gt;(wl_resource_get_user_data(resource));</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.destroy, context);</span><br><span class="line">    wl_list_remove(wl_resource_get_link(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_v1_destroy</span><span class="params">(<span class="keyword">struct</span> ext_session_lock_v1 *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    wl_signal_emit_mutable(&amp;context-&gt;events.destroy, context);</span><br><span class="line">    <span class="built_in">free</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_session_lock_v1_destroy_func</span><span class="params">(wl_resource *resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_v1 *&gt;(wl_resource_get_user_data(resource));</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ext_session_lock_v1_destroy(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">manager_handle_lock</span><span class="params">(<span class="keyword">struct</span> wl_client *client,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> wl_resource *manager_resource,</span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">manager</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_manager_v1 *&gt;(wl_resource_get_user_data(manager_resource));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">resource</span> =</span> wl_resource_create(client,</span><br><span class="line">                                                      &amp;ext_session_lock_v1_interface,</span><br><span class="line">                                                      EXT_SESSION_LOCK_V1_DESTROY_SINCE_VERSION,</span><br><span class="line">                                                      id);</span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wl_resource_post_no_memory(manager_resource);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span> *<span class="title">context</span> =</span></span><br><span class="line">        static_cast&lt;ext_session_lock_v1 *&gt;(<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*context)));</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wl_resource_post_no_memory(manager_resource);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wl_resource_set_implementation(resource,</span><br><span class="line">                                   &amp;lock_implementation,</span><br><span class="line">                                   context,</span><br><span class="line">                                   ext_session_lock_v1_destroy_func);</span><br><span class="line">    wl_resource_set_user_data(resource, context);</span><br><span class="line"></span><br><span class="line">    wl_signal_init(&amp;context-&gt;events.get_lock_surface);</span><br><span class="line">    wl_signal_init(&amp;context-&gt;events.unlock_and_destroy);</span><br><span class="line">    wl_signal_init(&amp;context-&gt;events.destroy);</span><br><span class="line"></span><br><span class="line">    context-&gt;resource = resource;</span><br><span class="line">    context-&gt;id = id;</span><br><span class="line">    wl_list_init(&amp;context-&gt;contexts);</span><br><span class="line">    wl_list_insert(&amp;manager-&gt;contexts, wl_resource_get_link(resource));</span><br><span class="line"></span><br><span class="line">    wl_signal_emit_mutable(&amp;manager-&gt;events.lock, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1_interface</span> <span class="title">lock_manager_implementation</span> =</span> &#123;</span><br><span class="line">    .destroy = manager_handle_destroy,</span><br><span class="line">    .lock = manager_handle_lock,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bind_ext_session_lock_manager_v1</span><span class="params">(<span class="keyword">struct</span> wl_client *client,</span></span><br><span class="line"><span class="params">                                             <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                             <span class="type">uint32_t</span> version,</span></span><br><span class="line"><span class="params">                                             <span class="type">uint32_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">manager</span> =</span></span><br><span class="line">        static_cast&lt;<span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *&gt;</span>(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_resource</span> *<span class="title">resource</span> =</span></span><br><span class="line">        wl_resource_create(client, &amp;ext_session_lock_manager_v1_interface, version, id);</span><br><span class="line">    <span class="keyword">if</span> (!resource) &#123;</span><br><span class="line">        wl_client_post_no_memory(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wl_resource_set_implementation(resource, &amp;lock_manager_implementation, manager, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    wl_list_insert(&amp;manager-&gt;contexts, wl_resource_get_link(resource));</span><br><span class="line"></span><br><span class="line">    manager-&gt;client = resource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_display_destroy</span><span class="params">(<span class="keyword">struct</span> wl_listener *listener, [[maybe_unused]] <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">manager</span> =</span></span><br><span class="line">        wl_container_of(listener, manager, display_destroy);</span><br><span class="line">    wl_signal_emit_mutable(&amp;manager-&gt;events.destroy, manager);</span><br><span class="line">    wl_list_remove(&amp;manager-&gt;display_destroy.link);</span><br><span class="line">    wl_global_destroy(manager-&gt;global);</span><br><span class="line">    <span class="built_in">free</span>(manager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SESSION_LOCK_MANAGEMENT_V1_VERSION 1</span></span><br><span class="line"></span><br><span class="line">ext_session_lock_manager_v1 *<span class="title function_">ext_session_lock_manager_v1_create</span><span class="params">(wl_display *display)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">manager</span> =</span></span><br><span class="line">        static_cast&lt;<span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *&gt;</span>(<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*manager)));</span><br><span class="line">    <span class="keyword">if</span> (!manager) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    manager-&gt;event_loop = wl_display_get_event_loop(display);</span><br><span class="line">    manager-&gt;global = wl_global_create(display,</span><br><span class="line">                                       &amp;ext_session_lock_manager_v1_interface,</span><br><span class="line">                                       SESSION_LOCK_MANAGEMENT_V1_VERSION,</span><br><span class="line">                                       manager,</span><br><span class="line">                                       bind_ext_session_lock_manager_v1);</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;global) &#123;</span><br><span class="line">        <span class="built_in">free</span>(manager);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wl_signal_init(&amp;manager-&gt;events.lock);</span><br><span class="line">    wl_signal_init(&amp;manager-&gt;events.destroy);</span><br><span class="line">    wl_list_init(&amp;manager-&gt;contexts);</span><br><span class="line"></span><br><span class="line">    manager-&gt;display_destroy.notify = handle_display_destroy;</span><br><span class="line">    wl_display_add_destroy_listener(display, &amp;manager-&gt;display_destroy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>协议的书写上面大同小异，其他协议均按照类似的代码方式进行了支持，如感兴趣，强烈建议参阅  <a class="link"   href="https://gitlab.freedesktop.org/wlroots/wlroots/-/tree/0.17?ref_type=heads" >wlroots<i class="fas fa-external-link-alt"></i></a> 、weston、sway、mutter、kwin等项目的源码。<br><a name="Q6MUv"></a></p>
<h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><p>以 <a class="link"   href="https://wayland.app/protocols/ext-session-lock-v1" >ext_session_lock_v1<i class="fas fa-external-link-alt"></i></a> 协议为例，客户端(例如锁屏程序)的实现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成协议头文件</span></span><br><span class="line">wayland-scanner client-header ext-session-lock-v1.xml client.h</span><br><span class="line"><span class="comment"># 生成协议源文件(通过命令生成的代码，全是胶水代码)</span></span><br><span class="line">wayland-scanner code ext-session-lock-v1.xml client.c</span><br></pre></td></tr></table></figure>

<p>main文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wayland-client.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_display</span> *<span class="title">display</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_registry</span> *<span class="title">registry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_compositor</span> *<span class="title">compositor</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_surface</span> *<span class="title">surface</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wl_output</span> *<span class="title">output</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_manager_v1</span> *<span class="title">lock_manager</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1</span> *<span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1</span> *<span class="title">lock_surface</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">on_locked</span><span class="params">(<span class="type">void</span> *data, <span class="keyword">struct</span> ext_session_lock_v1 *lock)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Session successfully locked.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">on_configure</span><span class="params">(<span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> ext_session_lock_surface_v1 *ext_session_lock_surface_v1,</span></span><br><span class="line"><span class="params">			  <span class="type">uint32_t</span> serial,</span></span><br><span class="line"><span class="params">			  <span class="type">uint32_t</span> width,</span></span><br><span class="line"><span class="params">			  <span class="type">uint32_t</span> height)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received configure event, send ack_configure back\n&quot;</span>);</span><br><span class="line">    ext_session_lock_surface_v1_ack_configure(ext_session_lock_surface_v1, serial);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_v1_listener</span> <span class="title">lock_listener</span> =</span> &#123;</span><br><span class="line">    on_locked</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext_session_lock_surface_v1_listener</span> <span class="title">lock_surface_listener</span> =</span> &#123;</span><br><span class="line">    on_configure</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">registry_handle_global</span><span class="params">(<span class="type">void</span> *data, <span class="keyword">struct</span> wl_registry *registry, <span class="type">uint32_t</span> id,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span> *interface, <span class="type">uint32_t</span> version)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_data</span> *<span class="title">example_data</span> =</span> data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(interface, <span class="string">&quot;ext_session_lock_manager_v1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        example_data-&gt;lock_manager = wl_registry_bind(registry, id, &amp;ext_session_lock_manager_v1_interface, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(interface, <span class="string">&quot;wl_compositor&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        example_data-&gt;compositor = wl_registry_bind(registry, id, &amp;wl_compositor_interface, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got wl_compositor\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(interface, <span class="string">&quot;wl_output&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        example_data-&gt;output = wl_registry_bind(registry, id, &amp;wl_output_interface, version);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got wl_output\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">wl_registry_listener</span> <span class="title">registry_listener</span> =</span> &#123;</span><br><span class="line">    registry_handle_global,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">example_data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data.lock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    data.display = wl_display_connect(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!data.display) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to connect to Wayland display.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get registry</span></span><br><span class="line">    data.registry = wl_display_get_registry(data.display);</span><br><span class="line">    wl_registry_add_listener(data.registry, &amp;registry_listener, &amp;data);</span><br><span class="line">    wl_display_roundtrip(data.display);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data.lock_manager || !data.compositor || !data.output) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Required interfaces not available\n&quot;</span>);</span><br><span class="line">        wl_registry_destroy(data.registry);</span><br><span class="line">        wl_display_disconnect(data.display);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request lock</span></span><br><span class="line">    data.lock = ext_session_lock_manager_v1_lock(data.lock_manager);</span><br><span class="line">    ext_session_lock_v1_add_listener(data.lock, &amp;lock_listener, &amp;data);</span><br><span class="line">    wl_display_roundtrip(data.display);</span><br><span class="line">    <span class="keyword">if</span> (!data.lock) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Required interfaces: lock not available\n&quot;</span>);</span><br><span class="line">        wl_registry_destroy(data.registry);</span><br><span class="line">        wl_display_disconnect(data.display);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request destroy</span></span><br><span class="line">    <span class="comment">// ext_session_lock_manager_v1_destroy(data.lock);</span></span><br><span class="line">    <span class="comment">// wl_display_roundtrip(data.display);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // Wait for events</span></span><br><span class="line">    <span class="comment">// while (wl_display_dispatch(data.display) != -1) &#123;</span></span><br><span class="line">    <span class="comment">//     // Handle events</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create surface</span></span><br><span class="line">    data.surface = wl_compositor_create_surface(data.compositor);</span><br><span class="line">    <span class="keyword">if</span> (!data.surface) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create wl_surface\n&quot;</span>);</span><br><span class="line">        wl_registry_destroy(data.registry);</span><br><span class="line">        wl_display_disconnect(data.display);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request get_lock_surface</span></span><br><span class="line">    data.lock_surface = ext_session_lock_v1_get_lock_surface(data.lock, data.surface, data.output);</span><br><span class="line">    ext_session_lock_surface_v1_add_listener(data.lock_surface, &amp;lock_surface_listener, &amp;data);</span><br><span class="line">    wl_display_roundtrip(data.display);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request unlock_and_destroy</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Start Unlock\n&quot;</span>);</span><br><span class="line">    ext_session_lock_v1_unlock_and_destroy(data.lock);</span><br><span class="line">    wl_display_roundtrip(data.display);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unlock success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for events</span></span><br><span class="line">    <span class="keyword">while</span> (wl_display_dispatch(data.display) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle events</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    ext_session_lock_manager_v1_destroy(data.lock_manager);</span><br><span class="line">    wl_registry_destroy(data.registry);</span><br><span class="line">    wl_display_disconnect(data.display);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 <code>gcc -o client client.c main.c -lwayland-client</code>编译生成 client 二进制。<br />运行：注意在运行此二进制之前，需要指定其 WAYLAND_DISPLAY环境变量，这是由 Wayland 合成器决定的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> WAYLAND_DISPLAY=wayland-0</span><br><span class="line">./client</span><br></pre></td></tr></table></figure>

<p>至此，我们已经完成了一个简单的客户端调用 Wayland 协议的 demo。在实际开发中，这些调用通常由各种开发库进行了封装。例如，libqtwayland 就是由 Qt 对部分 Wayland 协议的调用进行了封装，从而使得开发者在开发桌面应用时无需直接处理协议调用，只需使用 Qt 中已有的类和接口即可。</p>
<blockquote>
<p>&#x2F;&#x2F; By A Way<br>A week 的合成器之旅达到 Ending,以后有时间再继续丰富.</p>
</blockquote>
<p><a name="Xir9t"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://wayland.freedesktop.org/" >https://wayland.freedesktop.org/<i class="fas fa-external-link-alt"></i></a><br /><a class="link"   href="https://wayland.arktoria.org/index.html" >The Wayland Protocol 中文版<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>wayland</tag>
      </tags>
  </entry>
  <entry>
    <title>XDG Base Directory Specification(XDG 基本目录规范)</title>
    <url>/2023/048c94961b.html</url>
    <content><![CDATA[<p>原文链接：<a class="link"   href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" >https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>各种指定文件和文件格式的规范。本规范通过定义一个或多个相对于文件所在位置的基本目录来定义应在何处查找这些文件。</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>XDG 基本目录规范基于以下概念：</p>
<ul>
<li>有一个单一的基本目录，用户特定的数据文件应该写入该基本目录。该目录由环境变量定义<code>$XDG_DATA_HOME</code>。</li>
<li>有一个单一的基本目录，用户特定的配置文件应该写到这个目录中。该目录由环境变量定义<code>$XDG_CONFIG_HOME</code>。</li>
<li>有一个单一的基本目录，用户特定的状态数据应该写入该目录。该目录由环境变量定义<code>$XDG_STATE_HOME</code>。</li>
<li>有一个单一的基本目录，用户特定的可执行文件可以相对于该目录写入。</li>
<li>有一组优先排序的基本目录，数据文件应根据这些目录进行搜索。这组目录由环境变量定义<code>$XDG_DATA_DIRS</code>。</li>
<li>有一组优先排序的基本目录，配置文件应该根据这些目录进行搜索。这组目录由环境变量定义<code>$XDG_CONFIG_DIRS</code>。</li>
<li>有一个相对于用户特定的非必要（缓存）数据应该写入的单一基本目录。该目录由环境变量定义<code>$XDG_CACHE_HOME</code>。</li>
<li>有一个单一的基本目录，用户特定的运行时文件和其他文件对象应该相对于该目录放置。该目录由环境变量定义<code>$XDG_RUNTIME_DIR</code>。</li>
</ul>
<p>这些环境变量中设置的所有路径都必须是绝对路径。如果<strong>实现</strong>（指实现此规范的角色，常指桌面环境和其发行商）在任何这些变量中遇到相对路径，它应该认为该路径无效并忽略它。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><code>$XDG_DATA_HOME</code>定义应存储用户特定数据文件的基本目录。如果 <code>$XDG_DATA_HOME</code>未设置或为空， <code>$HOME</code>则应使用等于 &#x2F;.local&#x2F;share 的默认值。</p>
<p><code>$XDG_CONFIG_HOME</code>定义应存储用户特定配置文件的基本目录。如果 <code>$XDG_CONFIG_HOME</code>未设置或为空， <code>$HOME</code>则应使用等于 &#x2F;.config 的默认值。</p>
<p><code>$XDG_STATE_HOME</code>定义应存储用户特定状态文件的基本目录。如果 <code>$XDG_STATE_HOME</code>未设置或为空， <code>$HOME</code>则应使用等于 &#x2F;.local&#x2F;state 的默认值。</p>
<p><code>$XDG_STATE_HOME</code>包含应在（应用程序）重新启动之间持续存在的状态数据，但对于用户而言，这些数据不重要或可移植性不够，因此应将其存储在<code>$XDG_DATA_HOME</code>. 它可能包含：</p>
<ul>
<li>操作历史记录（日志、历史记录、最近使用的文件……）</li>
<li>可以在重新启动时重复使用的应用程序的当前状态（视图、布局、打开的文件、撤消历史记录……）</li>
</ul>
<p>用户特定的可执行文件可能存储在 <code>$HOME</code>&#x2F;.local&#x2F;bin 中。发行版应确保此目录显示在 UNIX<code>$PATH</code> 环境变量中的适当位置。</p>
<p>由于<code>$HOME</code>可能在不同体系结构的系统之间共享，因此将编译后的二进制文件安装到 <code>$HOME</code>&#x2F;.local&#x2F;bin 可能会在不同体系结构的系统上使用时导致问题。这通常不是问题，但 <code>$HOME</code>如果将已编译的二进制文件放入其中，就会变得部分特定于体系结构，这点需要注意。</p>
<p><code>$XDG_DATA_DIRS</code>定义优先排序的基本目录集，以搜索除 <code>$XDG_DATA_HOME</code>基本目录之外的数据文件。中的目录<code>$XDG_DATA_DIRS</code>应以冒号“:”分隔。</p>
<p>如果<code>$XDG_DATA_DIRS</code>未设置或为空，则应使用等于 &#x2F;usr&#x2F;local&#x2F;share&#x2F;:&#x2F;usr&#x2F;share&#x2F; 的值。</p>
<p><code>$XDG_CONFIG_DIRS</code>定义优先排序的基本目录集，以搜索除 <code>$XDG_CONFIG_HOME</code>基本目录之外的配置文件。中的目录<code>$XDG_CONFIG_DIRS</code>应以冒号“:”分隔。</p>
<p>如果<code>$XDG_CONFIG_DIRS</code>未设置或为空，则应使用等于 &#x2F;etc&#x2F;xdg 的值。</p>
<p>基本目录的顺序表示它们的重要性；列出的第一个目录是最重要的(优先级更高的)。当在多个地方定义相同的信息时，相对重要的基目录(Base Directory)定义的信息更优先。定义的基目录<code>$XDG_DATA_HOME</code>被认为比<code>$XDG_DATA_DIRS</code>定义的任何基目录都重要。定义的基目录<code>$XDG_CONFIG_HOME</code>被认为比<code>$XDG_CONFIG_DIRS</code>定义的任何基目录都重要。</p>
<p><code>$XDG_CACHE_HOME</code>定义应存储用户特定的非必要数据文件的基本目录。如果 <code>$XDG_CACHE_HOME</code>未设置或为空， <code>$HOME</code>则应使用等于 &#x2F;.cache 的默认值。</p>
<p><code>$XDG_RUNTIME_DIR</code>定义基本目录，用户特定的非必要运行时文件和其他文件对象（例如套接字、命名管道…）应该存储在该目录中。该目录必须由用户拥有，并且他必须是唯一具有读写权限的人。它的 Unix 访问模式必须是 0700。</p>
<p>目录的生命周期必须绑定到正在登录的用户。它必须在用户首次登录时创建，如果用户完全注销，则目录必须被删除。如果用户多次登录，他应该指向同一个目录，并且该目录必须从他第一次登录到他最后一次注销系统继续存在，并且在这期间不会被删除。目录中的文件不得在重启或完整的注销&#x2F;登录周期后继续存在。</p>
<p>该目录必须位于本地文件系统上，并且不与任何其他系统共享。该目录必须完全符合操作系统的标准。更具体地说，在类 Unix 操作系统上 AF_UNIX 套接字、符号链接、硬链接、适当的权限、文件锁定、稀疏文件、内存映射、文件更改通知，必须支持可靠的硬链接计数，并且对文件名没有限制应该强加字符集。此目录中的文件可能会定期清理。为确保您的文件不被删除，他们应该至少每 6 小时的单调时间修改一次他们的访问时间戳，或者应该在文件上设置“粘性”位。</p>
<p>如果<code>$XDG_RUNTIME_DIR</code>未设置，应用程序应回退到具有类似功能的替换目录并打印一条警告消息。应用程序应该将此目录用于通信和同步目的，并且不应在其中放置较大的文件，因为它可能驻留在运行时内存中并且不一定要换出到磁盘。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>其他规范可以通过将数据文件的位置指定为 <code>$XDG_DATA_DIRS</code>&#x2F;subdir&#x2F;filename 来引用此规范。这意味着：</p>
<ul>
<li>此类文件应安装到<code>$datadir</code>&#x2F;subdir&#x2F;filename，<code>$datadir</code>默认为 &#x2F;usr&#x2F;share。</li>
<li>可以在 <code>$XDG_DATA_HOME</code> &#x2F;subdir&#x2F;filename 中创建数据文件的用户特定版本，如果 <code>$XDG_DATA_HOME</code>未设置则使用其默认值。</li>
<li>数据文件的查找应该搜索相对于<code>$XDG_DATA_HOME</code>和 <code>$XDG_DATA_DIRS</code>指定的所有基本目录的 .&#x2F;subdir&#x2F;filename 。如果环境变量未设置或为空，则应使用本规范定义的默认值。</li>
</ul>
<p>规范可以通过将配置文件的位置指定为 <code>$XDG_CONFIG_DIRS</code>&#x2F;subdir&#x2F;filename 来引用此规范。这意味着：</p>
<ul>
<li>默认配置文件应安装到<code>$sysconfdir</code>&#x2F;xdg&#x2F;subdir&#x2F;filename，<code>$sysconfdir</code>默认为 &#x2F;etc。</li>
<li>配置文件的用户特定版本可以在 <code>$XDG_CONFIG_HOME</code>&#x2F;subdir&#x2F;filename 中创建，如果 <code>$XDG_CONFIG_HOME</code>未设置则使用其默认值。</li>
<li>配置文件的查找应该搜索相对于<code>$XDG_CONFIG_HOME</code>和<code>$XDG_CONFIG_DIRS</code>指示的所有基本目录的 .&#x2F;subdir&#x2F;filename 。如果环境变量未设置或为空，则应使用本规范定义的默认值。</li>
</ul>
<p>如果在尝试写入文件时目标目录不存在，则应尝试使用权限创建它<code>0700</code>。如果目标目录已经存在，则不应更改权限。应用程序应该准备好处理无法写入文件的情况，这可能是因为目录不存在且无法创建，也可能是出于任何其他原因。在这种情况下，它可能会选择向用户显示一条错误消息。</p>
<p>当试图读取文件时，如果某个目录中的文件由于任何原因不可访问，例如因为目录不存在，文件不存在或用户无权打开文件，则处理应该跳过该目录中的文件。如果因此根本找不到所需的文件，应用程序可能会选择向用户显示一条错误消息。</p>
<p>当文件位于多个基本目录下(如<code>$XDG_DATA_DIRS</code>和<code>$XDG_CONFIG_DIRS</code>中均存在)时， 规范应该定义此时的行为。例如，它可以定义仅应使用最重要的基本目录下的文件，或者，作为另一个示例，它可以定义合并来自不同文件的信息的规则（取不同文件内容的并集，冲突之处以高优先级文件内容为准）。</p>
]]></content>
      <categories>
        <category>Freedesktop</category>
      </categories>
      <tags>
        <tag>标准</tag>
        <tag>XDG</tag>
      </tags>
  </entry>
  <entry>
    <title>debian开源软件包打patch操作-小记</title>
    <url>/2023/0448209.html</url>
    <content><![CDATA[<p>打patch的主要目的是为了方便管理和协作。当我们需要对一个开源项目进行修改时，如果直接在源码上修改，那么我们的修改会和原始代码混在一起，不方便管理和维护。</p>
<span id="more"></span>

<p>因此，打patch就可以将我们的修改单独保存为一个补丁文件，方便我们管理和维护。当我们需要重新编译安装这个项目时，可以通过应用这个补丁文件来快速地将我们的修改应用到项目中，而不需要手动修改源码。</p>
<p>此外，如果其他人也需要对这个项目进行修改，他们也可以通过打patch来保存自己的修改，并且这些补丁文件可以很容易地合并在一起，使得协作变得更加方便。</p>
<h1 id="怎么操作"><a href="#怎么操作" class="headerlink" title="怎么操作"></a>怎么操作</h1><p>如果使用的是quilt,可以按照如下步骤：</p>
<p>export QUILT_PATCHES&#x3D;debian&#x2F;patches</p>
<p>quilt push -a</p>
<p>quilt new [patch file]</p>
<p>quilt add [monitor file]</p>
<p>&#x2F;&#x2F;do your change</p>
<p>quilt refresh</p>
<p>将其他修改删除，保留patch文件，修改debian&#x2F;patches&#x2F;series，之后提交到仓库即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>patch</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客本地部署</title>
    <url>/2024/05b59ef6f5.html</url>
    <content><![CDATA[<p>在本地快速预览博客部署效果，可按照此步骤操作。否则直接向源文件仓库中提交 md 文档即可。</p>
<span id="more"></span>

<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><p><code>sudo apt install npm</code><br>uos系统中的默认版本有点问题，无法通过npm安装其他包(如果您的版本没问题，直接跳到下一下节)，可按照 <a class="link"   href="https://github.com/nodesource/distributions" >nodesource<i class="fas fa-external-link-alt"></i></a> 的 <a class="link"   href="https://github.com/nodesource/distributions/blob/master/README.md" >README<i class="fas fa-external-link-alt"></i></a> 更新 nodejs.<br>或按照以下步骤(适合 Debian 系的 Linux 发行版):<br><code>sudo apt-get install -y curl</code><br><code>curl -fsSL https://deb.nodesource.com/setup_20.x -o nodesource_setup.sh</code><br><code>sudo -E bash nodesource_setup.sh</code><br><code>sudo apt-get install -y nodejs</code></p>
<p>安装成功后，通过 <code>node -v</code> 查看安装后的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; node -v</span><br><span class="line">v20.13.1</span><br></pre></td></tr></table></figure>

<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><code>cd your_hexo_dir</code><br><code>npm install hexo</code><br>阿拉的电脑已经安装过了，所以安装结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm install hexo</span><br><span class="line">npm notice Beginning October 4, 2021, all connections to the npm registry - including <span class="keyword">for</span> package installation - must use TLS 1.2 or higher. You are currently using plaintext http to connect. Please visit the GitHub blog <span class="keyword">for</span> more information: https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/</span><br><span class="line">npm notice Beginning October 4, 2021, all connections to the npm registry - including <span class="keyword">for</span> package installation - must use TLS 1.2 or higher. You are currently using plaintext http to connect. Please visit the GitHub blog <span class="keyword">for</span> more information: https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/</span><br><span class="line"></span><br><span class="line">up to <span class="built_in">date</span> <span class="keyword">in</span> 2s</span><br><span class="line"></span><br><span class="line">22 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>

<p>此时正常情况下可以使用 <code>npm hexo server</code> 或 <code>npm run server</code> 查看预览效果</p>
<p>如果碰到 npm 不识别 hexo 命令的情况，请自行配置 npm 的环境变量，或者找到当前安装的 hexo 命令所在，一般在当前安装目录的 <code>node_modules/hexo/bin/</code> 下，之后执行即可，例如 <code>./node_modules/hexo/bin/hexo s</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uos@uos-PC ~ ./node_modules/hexo/bin/hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  </span><br><span class="line">------------------------------------------</span><br><span class="line">     __  ___  _______  _______ .______</span><br><span class="line">    |  |/  / |   ____||   ____||   _  \</span><br><span class="line">    |  <span class="string">&#x27;  /  |  |__   |  |__   |  |_)  |</span></span><br><span class="line"><span class="string">    |    &lt;   |   __|  |   __|  |   ___/</span></span><br><span class="line"><span class="string">    |  .  \  |  |____ |  |____ |  |</span></span><br><span class="line"><span class="string">    |__|\__\ |_______||_______|| _|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------------------</span></span><br><span class="line"><span class="string">Keep version 4.1.2</span></span><br><span class="line"><span class="string">Documentation: https://keep-docs.xpoet.cn</span></span><br><span class="line"><span class="string">------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INFO  Start processing</span></span><br><span class="line"><span class="string">INFO  url_submission: Start generating url list...</span></span><br><span class="line"><span class="string">INFO  url_submission: Page urls will generate into file named submit_url.txt</span></span><br><span class="line"><span class="string">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span></span><br></pre></td></tr></table></figure>

<p>之后在浏览器中访问 <code>[http://localhost:4000/]</code> 就可以看到预览效果了.</p>
<p>后期如果只是为了提交新文章，只需要 clone 对应的项目到本地，在 source&#x2F;_posts 目录下新建文档即可。提交后由经由 github actions 自动部署并发布。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>npm 执行时提示不存在 package.json 文件，执行 <code>npm init</code> 进行初始化。再执行你要执行的操作，如 <code>npm install hexo</code><br>详情可参考<a class="link"   href="https://blog.csdn.net/weixin_40161974/article/details/99441501" >https://blog.csdn.net/weixin_40161974&#x2F;article&#x2F;details&#x2F;99441501<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a class="link"   href="https://hexo.io/zh-cn/docs/" >hexo官方说明<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>npm</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables命令详解</title>
    <url>/2023/04a5477427.html</url>
    <content><![CDATA[<p>iptables是Linux防火墙系统的重要组成部分，主要功能是实现对网络数据包进出设备及转发的控制。它能够添加、删除具体的过滤规则，并可对数据包所做的操作进行控制，例如允许或禁止数据包通过特定的端口或地址。iptables默认维护着4个表和5个链来控制网络数据包的流动，可以使用命令行工具进行配置和管理。</p>
<span id="more"></span>

<h1 id="4表"><a href="#4表" class="headerlink" title="4表"></a>4表</h1><table>
<thead>
<tr>
<th>表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Filter</td>
<td>Filter是iptables的默认表，也是最常用的表之一。它可以进行基于源IP地址、目标IP地址、端口号等多种条件的过滤，以允许或禁止数据包通过特定的端口或地址。</td>
</tr>
<tr>
<td>NAT</td>
<td>NAT表用于网络地址转换（Network Address Translation），可以实现对源IP地址、目标IP地址、端口号等网络协议字段进行转换。NAT表包含3个内建链：PREROUTING链、POSTROUTING链和OUTPUT链。</td>
</tr>
<tr>
<td>Mangle</td>
<td>Mangle表可以修改数据包的TTL（Time To Live）值，以及数据包的QoS（Quality of Service）信息。</td>
</tr>
<tr>
<td>Raw</td>
<td>Raw表用于处理异常情况，例如某些不需要被过滤的包，或者需要使用ICMP错误报告的数据包。Raw表包含3个内建链：PREROUTING链、OUTPUT链和POSTROUTING链。</td>
</tr>
</tbody></table>
<h1 id="5链"><a href="#5链" class="headerlink" title="5链"></a>5链</h1><table>
<thead>
<tr>
<th>链</th>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INPUT</td>
<td>到达本地主机</td>
<td>该链用于对进入本机的数据包进行过滤，可以设置允许或拒绝不同来源的数据包进入本机，例如，可以阻止某些IP地址或端口号的连接请求。</td>
</tr>
<tr>
<td>OUTPUT</td>
<td>从本地主机发送出去</td>
<td>该链用于对本机发出的数据包进行过滤，可以设置只允许通过特定端口或协议发送数据包，或者禁止向特定IP地址或端口号发送数据包等。</td>
</tr>
<tr>
<td>FORWARD</td>
<td>转发到另一个接口</td>
<td>该链用于对经过本机的数据包进行过滤，例如，可以设置将某些流量重定向到另一台服务器上，或者拒绝不符合条件的数据包从本机转发。</td>
</tr>
<tr>
<td>PREROUTING</td>
<td>在路由决策之前</td>
<td>该链是在数据包路由之前执行的，可以对进入本机的数据包进行修改或重定向，例如，可以设置端口映射规则将外部的请求转发至内网服务器。</td>
</tr>
<tr>
<td>POSTROUTING</td>
<td>在路由决策之后</td>
<td>该链是在数据包路由之后执行的，可以对经过本机的数据包进行修改或重定向，例如，可以设置NAT规则，将私有IP地址转换为公共IP地址以便访问互联网。</td>
</tr>
</tbody></table>
<p>防火墙的数据流图如下表，不同的链处于不同的阶段。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04a5477427/1.png"
                       
                 ></p>
<h1 id="堵通策略"><a href="#堵通策略" class="headerlink" title="堵通策略"></a>堵通策略</h1><p>iptables 的堵通策略可分为以下几种情况</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>基于IP地址</td>
<td>iptables可以根据源IP地址或目标IP地址来过滤流量。通过设置规则，可以允许或者拒绝特定IP地址或者IP地址段的数据流，从而实现基于IP地址的堵通策略。</td>
</tr>
<tr>
<td>基于端口号</td>
<td>iptables还可以根据源端口号或目标端口号来过滤数据流。通过设置规则，可以允许或者拒绝特定端口号或者端口号范围的数据流，从而实现基于端口号的堵通策略。</td>
</tr>
<tr>
<td>基于协议类型</td>
<td>iptables还可以根据传输层协议类型（如TCP、UDP等）来过滤数据流。通过设置规则，可以允许或者拒绝特定协议类型的数据流，从而实现基于协议类型的堵通策略。</td>
</tr>
<tr>
<td>基于数据包状态</td>
<td>iptables还可以根据数据包的状态（如已建立连接、未建立连接等）来过滤数据流。通过设置规则，可以允许或者拒绝特定状态的数据流，从而实现基于数据包状态的堵通策略。</td>
</tr>
<tr>
<td>基于应用程序</td>
<td>iptables还可以根据应用程序来过滤数据流。通过设置规则，可以允许或者拒绝特定应用程序的数据流，从而实现基于应用程序的堵通策略。</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>拒绝所有传入和传出的数据包：这个策略可以通过设置默认策略为DROP来实现。这意味着除非有专门的规则来允许某些数据包通过，否则所有传入和传出的数据包都将被阻止。</p>
<p>允许某些IP地址或端口通过：可以使用iptables的规则来明确允许特定的IP地址或端口通过。例如，下面的命令将允许来自IP地址192.168.0.100的所有流量通过：</p>
<p><code>iptables -A INPUT -s 192.168.0.100 -j ACCEPT</code><br>屏蔽指定的IP地址或端口：可以使用iptables的规则来屏蔽特定的IP地址或端口。例如，下面的命令将拒绝来自IP地址192.168.0.100的所有流量：<br><code>iptables -A INPUT -s 192.168.0.100 -j DROP</code><br>过滤协议类型：可以使用iptables的规则来过滤不同的协议类型。例如，下面的命令将只允许HTTP和HTTPS流量通过：<br><code>iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT</code><br><code>iptables -A INPUT -p udp -j DROP</code><br>防止DDoS攻击：可以使用iptables的规则来防止DDoS攻击。例如，下面的命令将限制每个IP地址在60秒内只能发送100个包：<br><code>iptables -A INPUT -p tcp -m limit --limit 100/s --limit-burst 150 -j ACCEPT</code><br><code>iptables -A INPUT -j DROP</code></p>
<h1 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h1><p>iptables命令的基本语法格式为：</p>
<p><code>iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]</code></p>
<p>表名和链名: 用于指定iptables命令所操作的表和链。</p>
<p>命令选项: 用于指定管理iptables规则的方式，比如插入、增加、删除、查看等。</p>
<p>条件匹配: 用于指定对符合什么样条件的数据包进行处理。</p>
<p>目标动作或跳转: 用于决定经过这条规则后应该执行的动作。</p>
<p>iptables的规则执行顺序是<strong>从上至下依次匹配</strong>，如果匹配成功，则根据该规则的动作（如accept、reject、log等）来决定后续的处理方式。一般而言，iptables命令需要root权限才能操作。</p>
<h2 id="表明"><a href="#表明" class="headerlink" title="表明"></a>表明</h2><p>-t：指定操作的表名，可选值包括filter、nat、mangle、raw等。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>-A（append）：在指定链的末尾添加一条规则。</p>
<p>-I（insert）：在指定链的开头插入一条规则。</p>
<p>-D（delete）：删除指定链中匹配条件的规则。</p>
<p>-L（list）：列出指定链中的所有规则。</p>
<p>-P（policy）：设置指定链的默认策略。</p>
<p>-s（source）：指定源IP地址或网段。</p>
<p>-d（destination）：指定目标IP地址或网段。</p>
<p>-p（protocol）：指定要匹配的协议类型，比如TCP、UDP、ICMP等。</p>
<p>–sport（source port）：指定源端口号。</p>
<p>–dport（destination port）：指定目标端口号。</p>
<p>-j（jump）：指定目标动作或跳转。常用的跳转目标包括ACCEPT、REJECT、DROP、LOG等。</p>
<p>-m（match）：指定扩展模块，比如限速模块、状态模块等。</p>
<p>-i（in-interface）：指定数据包进入的网络接口。</p>
<p>-o（out-interface）：指定数据包输出的网络接口。</p>
<h2 id="匹配参数"><a href="#匹配参数" class="headerlink" title="匹配参数"></a>匹配参数</h2><p>–source（或 -s）：指定源IP地址或网段。</p>
<p>–destination（或 -d）：指定目标IP地址或网段。</p>
<p>–protocol（或 -p）：指定要匹配的协议类型，比如TCP、UDP、ICMP等。</p>
<p>–sport：指定源端口号。</p>
<p>–dport：指定目标端口号。</p>
<p>–state：指定连接状态，比如NEW、ESTABLISHED、RELATED等。</p>
<p>–icmp-type：指定ICMP报文类型。</p>
<p>–mac-source：指定源MAC地址。</p>
<p>–mac-destination：指定目标MAC地址。</p>
<h2 id="触发动作"><a href="#触发动作" class="headerlink" title="触发动作"></a>触发动作</h2><p>ACCEPT：接受数据包，允许其通过防火墙并到达目标主机。</p>
<p>DROP：丢弃数据包，不允许其通过防火墙并到达目标主机。</p>
<p>REJECT：拒绝数据包，向发送方发送一个错误信息，告知其无法到达目标主机。与DROP不同之处在于，DROP不向发送方发送任何信息。</p>
<p>LOG：记录日志信息，将匹配条件的数据包进行记录。</p>
<p>SNAT（Source Network Address Translation）：源地址转换，将数据包的源IP地址更改为指定的地址。常用于实现负载均衡和高可用性等功能。</p>
<p>DNAT（Destination Network Address Translation）：目标地址转换，将数据包的目标IP地址更改为指定的地址。常用于实现端口映射和虚拟主机等功能。</p>
<p>MASQUERADE：伪装，将数据包的源IP地址更改为防火墙的IP地址，常用于实现局域网访问外网等功能。</p>
<p>REDIRECT：将数据包重定向到本地主机上的另一个端口或者IP地址，常用于实现端口映射、网络转发等功能。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li>iptables -L：列出当前所有规则，包括INPUT、FORWARD和OUTPUT三个表的规则。</li>
<li>iptables -A：向指定链（如INPUT、FORWARD或OUTPUT）添加新规则，-A表示追加到链的末尾。</li>
<li>iptables -I：向指定链插入新规则，-I后面跟的数字表示插入规则的位置，例如-I INPUT 4表示在INPUT链的第4个位置插入新规则。</li>
<li>iptables -D：删除指定链中的规则，-D后面接要删除的规则编号。</li>
<li>iptables -P：设置指定链的默认策略，例如iptables -P FORWARD DROP表示将FORWARD链的默认策略设置为DROP。</li>
<li>iptables -s：指定源IP地址或网段，例如iptables -A INPUT -s 192.168.0.0&#x2F;24表示从192.168.0.0&#x2F;24网段发来的数据包都要进入INPUT链进行处理。</li>
<li>iptables -d：指定目标IP地址或网段，例如iptables -A OUTPUT -d 8.8.8.8表示将发送到8.8.8.8的数据包都从OUTPUT链出去。</li>
<li>iptables -p：指定协议类型，例如iptables -A INPUT -p tcp表示只对TCP数据包进行处理。</li>
<li>iptables -m：指定匹配模块，例如iptables -A INPUT -m state –state ESTABLISHED,RELATED表示对与已经建立的连接或者是由已建立连接所产生的包进行匹配。</li>
<li>iptables -j：指定动作，例如iptables -A INPUT -s 192.168.0.0&#x2F;24 -j DROP表示将来自192.168.0.0&#x2F;24网段的数据包都丢弃掉。常用的动作有ACCEPT、DROP、REJECT等。</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a class="link"   href="https://blog.csdn.net/weixin_48190891/article/details/107815698" >iptables：超详细Iptables防火墙基础规则（四个规则表，5个种规则链）与编写Iptables防火墙规则<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/Wu000999/article/details/98603285" >iptables中的默认规则<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/inmeditation/p/10764305.html" >iptables之语法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/1628661" >iptables系列教程（二）| iptables语法规则<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/yum777/articles/8514636.html" >iptables规则链执行顺序<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>journalctl-查看日志</title>
    <url>/2023/04c817baa.html</url>
    <content><![CDATA[<p>Systemd服务目前在较为流行的发行版中均统一管理了所有服务的启动日志,用户可以只用journalctl一个命令,查看到全部的日志信息。</p>
<span id="more"></span>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>journalctl [OPTIONS...] [MATCHES...]</code></p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>用于查询由 systemd- journald服务写入的的日志内容。</p>
<p>如果不带参数调用,它将会从最早的日志开始,显示日志的全部内容</p>
<p>如果传递了一个或多个匹配参数,则会相应地过滤输出。 匹配的格式为“FIELD&#x3D;VALUE”,例如 “_SYSTEMD_UNIT&#x3D;httpd.service”。 如果指定了多个匹配项来匹配不同的字段,则日志条目将被两者过滤,即结果输出将仅显示匹配所有此类指定匹配项的条目。 如果两个匹配项适用于同一个字段,那么它们将自动匹配为替代项,即结果输出将显示与同一字段的任何指定匹配项匹配的条目。 最后,字符“+”可能在命令行中作为其他术语之间的单独单词出现。 这会导致之前和之后的所有匹配项组合成析取(即逻辑或)。</p>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>journalctl 的功能比较强大,可选的参数有很多,其中最常见的选项如下表：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-f, –follow</strong></td>
<td>仅显示最近的日志条目,并在打印新增加的日志</td>
</tr>
<tr>
<td>-n, –lines&#x3D;</td>
<td>显示最近的日志事件并限制显示的事件数。 如果使用 –follow,则隐含此选项。 该参数是一个正整数或“全部”以禁用行限制。 如果没有给出参数,默认值为 10。</td>
</tr>
<tr>
<td><strong>-r, –reverse</strong></td>
<td>反转输出,最新的日志在最上方输出。</td>
</tr>
<tr>
<td>-o, –output&#x3D;</td>
<td>更改日志输出模式(short,short-full,short-iso,short-iso-precise,short-precise,short-monotonic,short-unix,verbose,export,json,json-pretty,json-sse,json-seq,cat,with-unit)</td>
</tr>
<tr>
<td>–list-boots</td>
<td>显示有关已记录引导的简洁信息</td>
</tr>
<tr>
<td><strong>-k, –dmesg</strong></td>
<td>仅显示内核消息。 这等同于 -b 选项并添加匹配项“_TRANSPORT&#x3D;kernel”</td>
</tr>
<tr>
<td><strong>-b, –boot[&#x3D;ID]</strong></td>
<td>显示当前启动或指定启动的日志</td>
</tr>
<tr>
<td><code>-u, --unit=UNIT|PATTERN</code></td>
<td>显示指定 systemd 单元 UNIT（例如服务单元）或与 PATTERN 匹配的任何单元的消息。 如果指定了模式，则将在日志中找到的单元名称列表与指定模式进行比较，并使用所有匹配项。 对于每个单元名称，为来自该单元的消息（“_SYSTEMD_UNIT&#x3D;UNIT”）添加一个匹配项，同时为来自 systemd 的消息和有关指定单元的核心转储的消息添加其他匹配项。<br>这个参数可以被指定很多次。</td>
</tr>
<tr>
<td>–user-unit&#x3D;</td>
<td>显示指定用户会话单元的消息。 这将为来自单元的消息（“_SYSTEMD_USER_UNIT&#x3D;”和“_UID&#x3D;”）添加匹配项</td>
</tr>
<tr>
<td><strong>-S, –since&#x3D;, -U, –until&#x3D;</strong></td>
<td>分别开始显示指定日期或晚于指定日期或指定日期或早于指定日期的条目。 日期规范应采用“2012-10-30 18:17:16”格式。 如果省略时间部分，则假定为“00:00:00”。 如果仅省略秒部分，则假定为“:00”。 如果省略日期部分，则假定为当前日期。 或者，也可以时刻使用字符串“yesterday”、“today”、“tomorrow”，它们分别指的是当天前一天、当天或当天后一天的00:00:00。 “now”是指当前时间。 最后，可以指定相对时间，前缀为“-”或“+”，分别表示当前时间之前或之后的时间。</td>
</tr>
<tr>
<td><strong>–system, –user</strong></td>
<td>显示来自系统服务和内核的消息（使用 –system）。 显示来自当前用户服务的消息（使用 –user）。 如果两者均未指定，则显示用户可以看到的所有消息。</td>
</tr>
<tr>
<td>–sync</td>
<td>要求日志守护进程将所有尚未写入的日志数据写入支持文件系统并同步所有日志。 在同步操作完成之前，此调用不会返回。 此命令保证在其调用之前写入的任何日志消息在其返回时安全地存储在磁盘上。</td>
</tr>
<tr>
<td>–flush</td>
<td>如果启用了持久存储，则要求日志守护进程将存储在 &#x2F;run&#x2F;log&#x2F;journal 中的所有日志数据刷新到 &#x2F;var&#x2F;log&#x2F;journal 中。 在操作完成之前，此调用不会返回。 请注意，此调用是幂等的：数据仅在系统运行时从 &#x2F;run&#x2F;log&#x2F;journal 刷新到 &#x2F;var&#x2F;log&#x2F;journal 一次，如果这已经发生，则此命令会干净地退出而不执行任何操作。 此命令有效地保证所有数据在返回时都刷新到 &#x2F;var&#x2F;log&#x2F;journal。</td>
</tr>
<tr>
<td>–rotate</td>
<td>要求日志守护程序滚动日志文件。 在旋转操作完成之前，此调用不会返回。 日志文件滚动的效果是，所有当前活动的日志文件都被标记为已归档并重命名，以便将来永远不会写入它们。 然后在它们的位置创建新的（空的）日志文件。 此操作可以与 –vacuum-size&#x3D;、–vacuum-time&#x3D; 和 –vacuum-file&#x3D; 组合成一个命令。</td>
</tr>
</tbody></table>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功返回0； 否则,返回一个非零失败代码</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>没有参数,所有收集的日志都显示为未过滤:</p>
<p><code>journalctl</code></p>
<p>指定一个匹配项后,将显示具有与表达式匹配的字段的所有日志：</p>
<p><code>journalctl _SYSTEMD_UNIT=avahi-daemon.service</code></p>
<p><code>journalctl _SYSTEMD_CGROUP=/user.slice/user-42.slice/session-c1.scope</code></p>
<p>如果匹配了两个不同的字段,则只显示同时匹配两个表达式的条目：</p>
<p><code>journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=28097</code></p>
<p>如果两个匹配项引用同一个字段,则显示与任一表达式匹配的所有条目：</p>
<p><code>journalctl _SYSTEMD_UNIT=avahi-daemon.service _SYSTEMD_UNIT=dbus.service</code></p>
<p>如果使用分隔符“+”,则两个表达式可以组合成逻辑或。 以下将显示来自 PID 为 28097 的 Avahi 服务进程的所有消息以及来自 D-Bus 服务(来自其任何进程)的所有消息：</p>
<p><code>journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=28097 + _SYSTEMD_UNIT=dbus.service</code></p>
<p>要显示一个单元发出的所有字段以及关于该单元的所有字段,应使用选项 -u&#x2F;–unit&#x3D;。 <strong>journalctl -u name</strong> 扩展为类似于以下的复杂过滤器：</p>
<p><code>_SYSTEMD_UNIT=name.service </code></p>
<p><code>+ UNIT=name.service _PID=1</code></p>
<p><code>+ OBJECT_SYSTEMD_UNIT=name.service _UID=0</code></p>
<p><code>+ COREDUMP_UNIT=name.service _UID=0 MESSAGE_ID=fc2e22bc6ee647b6b90729ab34a250b1</code></p>
<p>显示 D-Bus 可执行文件生成的所有日志：</p>
<p><code>journalctl /usr/bin/dbus-daemon</code></p>
<p>显示上次启动的所有内核日志：</p>
<p><code>journalctl -k -b -1</code></p>
<p>显示来自系统服务 apache.service 的实时日志显示：</p>
<p><code> journalctl -f -u apache</code></p>
<p>显示本次启动后的所有日志：</p>
<p><code>journalctl -b</code></p>
<p>显示上一次次启动后的所有日志：</p>
<p><code>journalctl -b -1</code></p>
<p>搜索从特定日期和时间之后的日志：</p>
<p><code>journalctl --since &quot;2023-11-03 12:00:00&quot;</code></p>
<p>搜索从相对时间之后的日志（例如，过去的1小时）：</p>
<p><code>journalctl --since &quot;1 hour ago&quot;</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>journalctl</tag>
      </tags>
  </entry>
  <entry>
    <title>makeself 的使用</title>
    <url>/2024/0717fd6bfe.html</url>
    <content><![CDATA[<p>在 Linux 中，创建自解压安装脚本是一种常见的方法，可以将多个文件打包成一个可执行文件，以便于分发和安装。这种方法通常使用 <code>shar</code>（Shell Archive）或者 <code>makeself</code> 工具来实现。</p>
<span id="more"></span>
<p>以下是使用 <code>makeself</code> 创建自解压安装脚本的步骤。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在大多数 Linux 发行版中，<code>makeself</code> 工具可以通过包管理器安装。以下是一些常见的安装方法：</p>
<ul>
<li><p><strong>Ubuntu&#x2F;Debian:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install makeself</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Fedora:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dnf install makeself</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arch Linux:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S makeself</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h3><p>假设你有一组文件或一个目录需要打包。在这个例子中，我们将使用一个目录 <code>my_app</code>。</p>
<h3 id="编写安装脚本"><a href="#编写安装脚本" class="headerlink" title="编写安装脚本"></a>编写安装脚本</h3><p>编写一个名为 <code>install.sh</code> 的脚本，定义如何安装和配置你的应用程序。以下是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;正在安装 My App...&quot;</span><br><span class="line"># 执行安装步骤，例如复制文件、设置权限等</span><br><span class="line">cp -r * /opt/my_app/</span><br><span class="line">echo &quot;安装完成！&quot;</span><br></pre></td></tr></table></figure>
<p>确保你的安装脚本是可执行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x install.sh</span><br></pre></td></tr></table></figure>
<h3 id="使用makeself创建自解压安装包"><a href="#使用makeself创建自解压安装包" class="headerlink" title="使用makeself创建自解压安装包"></a>使用makeself创建自解压安装包</h3><p>使用 <code>makeself</code> 工具创建自解压安装包。以下是一个示例命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makeself my_app my_app_installer.run &quot;My App Installer&quot; ./install.sh</span><br></pre></td></tr></table></figure>

<ul>
<li><code>my_app</code> 是包含你所有文件的目录。</li>
<li><code>my_app_installer.run</code> 是生成的自解压安装包的名称。</li>
<li><code>&quot;My App Installer&quot;</code> 是安装包的描述。</li>
<li><code>./install.sh</code> 是安装脚本的路径。</li>
</ul>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>假设你有以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_app/</span><br><span class="line">├── install.sh</span><br><span class="line">├── bin/</span><br><span class="line">│   └── my_app_executable</span><br><span class="line">└── lib/</span><br><span class="line">    └── my_app_library.so</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建 <code>install.sh</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;正在安装 My App...&quot;</span><br><span class="line"># 创建目标目录</span><br><span class="line">mkdir -p /opt/my_app</span><br><span class="line"># 复制文件</span><br><span class="line">cp -r * /opt/my_app/</span><br><span class="line">echo &quot;安装完成！&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保 <code>install.sh</code> 是可执行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x my_app/install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>makeself</code> 创建自解压安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makeself my_app my_app_installer.run &quot;My App Installer&quot; ./install.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="运行自解压安装包"><a href="#运行自解压安装包" class="headerlink" title="运行自解压安装包"></a>运行自解压安装包</h3><p>用户可以通过执行生成的 <code>.run</code> 文件来安装应用程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./my_app_installer.run</span><br></pre></td></tr></table></figure>
<p>这会解压文件并运行 <code>install.sh</code> 脚本，完成应用程序的安装。<br />通过这些步骤，你可以轻松创建一个自解压安装脚本，方便分发和安装你的 Linux 应用程序。</p>
<h3 id="解压为原始文件"><a href="#解压为原始文件" class="headerlink" title="解压为原始文件"></a>解压为原始文件</h3><p>通过 makeself 制作的自解压安装包同样支持解压为原始文件，您可以在修改后重新打包为 .run 格式的自解压安装包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./my_app_installer.run --noexec --targegt my_app_dir</span><br></pre></td></tr></table></figure>
<h3 id="查看压缩包内容"><a href="#查看压缩包内容" class="headerlink" title="查看压缩包内容"></a>查看压缩包内容</h3><p>压缩后的可执行文件可以通过 –list 参数查看文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./my_app_installer.run --list</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>makeself</tag>
      </tags>
  </entry>
  <entry>
    <title>ostree中GPG签名的使用方式</title>
    <url>/2024/0754520fd3.html</url>
    <content><![CDATA[<p>OSTree 是一个用于版本化文件系统树的工具，可以将其视为 Git 的文件系统版本。OSTree 不仅支持文件系统的版本管理，还支持使用 GPG 对其提交进行签名，以确保数据的完整性和来源的可信性。下面介绍 GPG 签名的原理和如何在 OSTree 中使用它。</p>
<span id="more"></span>
<h2 id="GPG签名简介"><a href="#GPG签名简介" class="headerlink" title="GPG签名简介"></a>GPG签名简介</h2><p>GPG（GNU Privacy Guard）签名是一种用于验证数字内容完整性和真实性的方法。GPG是一个开源的加密软件，广泛用于数据加密和数字签名。</p>
<h3 id="GPG签名的工作原理"><a href="#GPG签名的工作原理" class="headerlink" title="GPG签名的工作原理"></a>GPG签名的工作原理</h3><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><ul>
<li>用户生成一对密钥：一个私钥（private key）和一个公钥（public key）。</li>
<li>私钥用于创建签名，公钥用于验证签名。</li>
</ul>
<h4 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h4><ul>
<li>当用户想要对一段数据（如文件、电子邮件等）进行签名时，GPG使用用户的私钥对数据进行哈希运算，生成一个摘要（hash）。</li>
<li>这个摘要通过私钥加密后，形成签名附加在原始数据上。</li>
</ul>
<h4 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h4><ul>
<li>接收者使用签名者的公钥对签名进行解密，得到哈希值。</li>
<li>接收者对接收到的数据重新计算哈希值，并与解密得到的哈希值进行比较。</li>
<li>如果两个哈希值一致，说明数据没有被篡改，并且签名确实是由持有私钥的人生成的。</li>
</ul>
<h3 id="GPG签名的应用"><a href="#GPG签名的应用" class="headerlink" title="GPG签名的应用"></a>GPG签名的应用</h3><ul>
<li><strong>软件分发</strong>：开发者使用GPG签名他们发布的软件，用户可以通过验证签名确保下载的软件是原版且未被篡改。</li>
<li><strong>电子邮件</strong>：使用GPG对电子邮件进行签名，接收者可以确认邮件内容的完整性和发送者的身份。</li>
<li><strong>文档和合同</strong>：对重要的文件和合同进行数字签名，确保文件在传输过程中的完整性。</li>
</ul>
<h3 id="使用GPG签名的步骤"><a href="#使用GPG签名的步骤" class="headerlink" title="使用GPG签名的步骤"></a>使用GPG签名的步骤</h3><h4 id="安装-GPG"><a href="#安装-GPG" class="headerlink" title="安装 GPG"></a>安装 GPG</h4><p> 如果尚未安装 GPG，可以通过以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnupg</span><br></pre></td></tr></table></figure>
<h4 id="生成密钥对-1"><a href="#生成密钥对-1" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>如果尚未生成 GPG 密钥对，可以使用以下命令生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure>
<p>选择合适的选项并按照提示生成密钥对。</p>
<h4 id="签名文件"><a href="#签名文件" class="headerlink" title="签名文件"></a>签名文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --sign &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h4 id="验证签名-1"><a href="#验证签名-1" class="headerlink" title="验证签名"></a>验证签名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --verify &lt;file&gt;.gpg</span><br></pre></td></tr></table></figure>
<p>通过GPG签名，可以有效地保护数字内容的完整性和真实性，广泛应用于软件开发、安全通信和数据保护等领域。</p>
<h2 id="OSTree-GPG-签名的原理"><a href="#OSTree-GPG-签名的原理" class="headerlink" title="OSTree GPG 签名的原理"></a>OSTree GPG 签名的原理</h2><p>GPG 签名用于验证数据的完整性和来源。通过对 OSTree 提交进行 GPG 签名，可以确保文件系统树在传输和部署过程中没有被篡改，并且确实来自预期的签名者。</p>
<h2 id="配置和使用-OSTree-GPG-签名"><a href="#配置和使用-OSTree-GPG-签名" class="headerlink" title="配置和使用 OSTree GPG 签名"></a>配置和使用 OSTree GPG 签名</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="列出所有-GPG-密钥"><a href="#列出所有-GPG-密钥" class="headerlink" title="列出所有 GPG 密钥"></a>列出所有 GPG 密钥</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure>
<p>这将显示你密钥环中的所有公钥。输出类似于以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub   rsa2048 2021-01-01 [SC] [expires: 2023-01-01]</span><br><span class="line">      3AA5C34371567BD2</span><br><span class="line">uid           [ultimate] Your Name &lt;youremail@example.com&gt;</span><br><span class="line">sub   rsa2048 2021-01-01 [E] [expires: 2023-01-01]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="识别密钥-ID"><a href="#识别密钥-ID" class="headerlink" title="识别密钥 ID"></a>识别密钥 ID</h4><p>在输出中，pub 行包含公钥信息。下面是如何识别密钥 ID：</p>
<ul>
<li>公钥行的第二行显示密钥 ID。例如，上面的输出中，3AA5C34371567BD2 是密钥 ID。</li>
<li>uid 行显示用户名和电子邮件地址。你可以通过用户名或电子邮件地址识别你感兴趣的密钥。</li>
</ul>
<h4 id="导出-GPG-公钥"><a href="#导出-GPG-公钥" class="headerlink" title="导出 GPG 公钥"></a>导出 GPG 公钥</h4><p> 通过<strong>密钥</strong> ID 导出公钥以供其他人验证签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --armor --export &lt;your-key-id&gt; &gt; pubkey.asc</span><br></pre></td></tr></table></figure>
<h3 id="签名和验证-OSTree-提交"><a href="#签名和验证-OSTree-提交" class="headerlink" title="签名和验证 OSTree 提交"></a>签名和验证 OSTree 提交</h3><h4 id="初始化-OSTree-仓库"><a href="#初始化-OSTree-仓库" class="headerlink" title="初始化 OSTree 仓库"></a>初始化 OSTree 仓库</h4><p> 如果尚未初始化 OSTree 仓库，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree init --repo=repo --mode=archive-z2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在使用 OSTree 时，可以通过环境变量 OSTREE_REPO 指定仓库的地址。这个环境变量允许你在命令行中不必每次都指定 –repo 参数，而是通过设置环境变量来定义仓库的位置。<br>export OSTREE_REPO&#x3D;&#x2F;path&#x2F;to&#x2F;your&#x2F;repo</p>
</blockquote>
<h4 id="签名-OSTree-提交"><a href="#签名-OSTree-提交" class="headerlink" title="签名 OSTree 提交"></a>签名 OSTree 提交</h4><p>创建一个提交并进行签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree commit --repo=repo --branch=example-branch --gpg-sign=&lt;your-key-id&gt; --subject=&quot;Example Commit&quot; --body=&quot;This is an example commit&quot;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;your-key-id&gt;</code> 是你的 GPG 密钥 ID。</p>
<h4 id="验证-OSTree-提交"><a href="#验证-OSTree-提交" class="headerlink" title="验证 OSTree 提交"></a>验证 OSTree 提交</h4><p>在另一个系统上验证签名，需要首先导入公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import pubkey.asc</span><br></pre></td></tr></table></figure>
<p>然后验证签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree pull --repo=repo --gpg-verify=true &lt;remote-repo&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="发布和部署"><a href="#发布和部署" class="headerlink" title="发布和部署"></a>发布和部署</h3><ol>
<li><strong>发布签名的 OSTree 提交</strong></li>
</ol>
<p>将签名的提交推送到远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree --repo=repo remote add --gpg-import=pubkey.asc origin &lt;remote-url&gt;</span><br><span class="line">ostree --repo=repo push --remote=origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>部署签名的 OSTree 提交</strong></li>
</ol>
<p>在客户端系统上，拉取并部署签名的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree remote add --gpg-import=pubkey.asc origin &lt;remote-url&gt;</span><br><span class="line">ostree pull origin &lt;branch&gt;</span><br><span class="line">ostree admin deploy &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h3><p>以下是一个完整的示例，从签名到验证和部署：</p>
<h4 id="服务器端（签名和发布）"><a href="#服务器端（签名和发布）" class="headerlink" title="服务器端（签名和发布）"></a>服务器端（签名和发布）</h4><h5 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree init --repo=repo --mode=archive-z2</span><br></pre></td></tr></table></figure>
<h5 id="创建并签名提交"><a href="#创建并签名提交" class="headerlink" title="创建并签名提交"></a>创建并签名提交</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree commit --repo=repo --branch=example-branch --gpg-sign=&lt;your-key-id&gt; --subject=&quot;Initial Commit&quot; --body=&quot;Initial commit with GPG signature&quot;</span><br></pre></td></tr></table></figure>
<h5 id="推送提交"><a href="#推送提交" class="headerlink" title="推送提交"></a>推送提交</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree remote add --repo=repo --gpg-import=pubkey.asc origin &lt;remote-url&gt;</span><br><span class="line">ostree --repo=repo push --remote=origin example-branch</span><br></pre></td></tr></table></figure>
<h4 id="客户端（验证和部署）"><a href="#客户端（验证和部署）" class="headerlink" title="客户端（验证和部署）"></a>客户端（验证和部署）</h4><h5 id="导入公钥"><a href="#导入公钥" class="headerlink" title="导入公钥"></a>导入公钥</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import pubkey.asc</span><br></pre></td></tr></table></figure>
<h5 id="添加远程仓库并拉取提交"><a href="#添加远程仓库并拉取提交" class="headerlink" title="添加远程仓库并拉取提交"></a>添加远程仓库并拉取提交</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree remote add --gpg-import=pubkey.asc origin &lt;remote-url&gt;</span><br><span class="line">ostree pull origin example-branch</span><br></pre></td></tr></table></figure>
<h5 id="部署提交"><a href="#部署提交" class="headerlink" title="部署提交"></a>部署提交</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ostree admin deploy example-branch</span><br></pre></td></tr></table></figure>
<p>通过以上步骤，你可以实现 OSTree 提交的 GPG 签名和验证，从而确保文件系统树的安全性和完整性。</p>
]]></content>
      <categories>
        <category>ostree</category>
      </categories>
      <tags>
        <tag>ostree</tag>
        <tag>GPG</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>ostree命令的基础用法</title>
    <url>/2024/0633106365.html</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>sudo apt install ostree</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>cd ostree&#x2F;<br>ostree init –repo&#x3D;. init<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/1.png"
                       
                 ></p>
<p>Just make your own changes and continueostree…</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>将 tree&#x2F; 目录下的内容导入，提交信息未填写默认为空<br>ostree –repo&#x3D;. commit –branch&#x3D;foo tree&#x2F;<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/2.png"
                       
                 ></p>
<p>指定提交内容<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/3.png"
                       
                 ></p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>列出仓库分支<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/4.png"
                       
                 ></p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>查看文件系统树的内容<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/5.png"
                       
                 ></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看文件内容<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/6.png"
                       
                 ></p>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>检出<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/7.png"
                       
                 ></p>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>重置到某个提交，在此之后的提交全部丢弃<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/8.png"
                       
                 ></p>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>查看分支提交信息<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/9.png"
                       
                 ></p>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>查看最新一笔提交<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/10.png"
                       
                 ></p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>比较提交差异<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/11.png"
                       
                 ></p>
<h2 id="OSTREE-REPO"><a href="#OSTREE-REPO" class="headerlink" title="OSTREE_REPO"></a>OSTREE_REPO</h2><p>指定仓库地址，从而无需在命令中指定–repo<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0633106365/12.png"
                       
                 ></p>
<h2 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h2><p><a class="link"   href="https://ostreedev.github.io/ostree/man/" >https://ostreedev.github.io/ostree/man/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p><a class="link"   href="https://github.com/qt/qtotaupdate" >https://github.com/qt/qtotaupdate<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>ostree</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd 目录重定向</title>
    <url>/2024/0650acf1b8.html</url>
    <content><![CDATA[<p>在 <code>systemd</code> 中，可以使用 <code>BindPaths</code> 或 <code>BindReadOnlyPaths</code> 来重定向应用访问的目录。这些选项可以在 <code>.service</code> 单元文件中设置，用于将特定的目录绑定到不同的位置，从而实现目录的重定向。<code>systemd</code> 的这种机制，可以让我们更好的控制应用的行为，增强系统的安全性。</p>
<span id="more"></span>

<p><code>BindPaths</code> 是通过使用 Linux 内核的挂载命名空间（mount namespaces）和绑定挂载（bind mounts）来实现的。这些功能允许在特定进程的命名空间中修改文件系统的视图，而不会影响到其他进程或系统的全局视图。</p>
<p>挂载命名空间（mount namespaces）允许在特定进程的视图中隔离和重新配置挂载点。创建一个新的挂载命名空间后，进程可以在不影响其他进程的情况下修改其挂载点。<br>绑定挂载（bind mounts）是 Linux 文件系统功能的一部分，允许将一个目录或文件挂载到另一个目录。这使得同一目录或文件可以在多个位置同时出现。</p>
<p>以下是一个示例，展示如何配置一个 <code>systemd</code> 服务单元文件以重定向目录访问：</p>
<h2 id="服务单元"><a href="#服务单元" class="headerlink" title="服务单元"></a>服务单元</h2><p>假设你有一个名为 <code>example.service</code> 的服务单元文件，路径可能在 <code>/etc/systemd/system/example.service</code> 或 <code>/lib/systemd/system/example.service</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Example Service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/example-binary</span><br><span class="line">BindPaths=/path/to/redirected:/path/to/original</span><br><span class="line"><span class="comment"># 或者使用只读绑定</span></span><br><span class="line"><span class="comment"># BindReadOnlyPaths=/path/to/redirected:/path/to/original</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>/path/to/original</code> 是应用程序预期访问的目录，<code>/path/to/redirected</code> 是你希望应用程序实际访问的目录。</p>
<p>修改单元文件后，重新加载 <code>systemd</code> 配置以使更改生效，在 <code>example-binary</code> 中访问 <code>/path/to/original</code> 目录的内容时，此时均会重定向至 <code>/path/to/redirected</code> 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重新加载 systemd 配置</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 启动或重启服务</span><br><span class="line">sudo systemctl restart example.service</span><br></pre></td></tr></table></figure>

<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>除了 BindPaths ，systemd还提供了其他的选项，使用者可以根据自己的需求选择合适的配置。</p>
<h3 id="BindPaths"><a href="#BindPaths" class="headerlink" title="BindPaths"></a>BindPaths</h3><ul>
<li><code>BindPaths=/target:/source</code></li>
<li>将 <code>/source</code> 目录绑定到 <code>/target</code> 目录。服务访问 <code>/source</code> 目录时实际上会访问 <code>/target</code> 目录。</li>
</ul>
<h3 id="BindReadOnlyPaths"><a href="#BindReadOnlyPaths" class="headerlink" title="BindReadOnlyPaths"></a>BindReadOnlyPaths</h3><ul>
<li><code>BindReadOnlyPaths=/target:/source</code></li>
<li>与 <code>BindPaths</code> 类似，但绑定的目录为只读模式。服务只能读取 <code>/target</code> 目录，无法进行写操作。</li>
</ul>
<h3 id="ReadWritePaths"><a href="#ReadWritePaths" class="headerlink" title="ReadWritePaths"></a>ReadWritePaths</h3><ul>
<li><code>ReadWritePaths=/path/to/dir</code></li>
<li>指定服务可以读写访问的目录。这些目录将被临时挂载为读写，即使根文件系统是只读的。</li>
</ul>
<h3 id="ReadOnlyPaths"><a href="#ReadOnlyPaths" class="headerlink" title="ReadOnlyPaths"></a>ReadOnlyPaths</h3><ul>
<li><code>ReadOnlyPaths=/path/to/dir</code></li>
<li>指定服务可以只读访问的目录。这些目录将被临时挂载为只读。</li>
</ul>
<h3 id="InaccessiblePaths"><a href="#InaccessiblePaths" class="headerlink" title="InaccessiblePaths"></a>InaccessiblePaths</h3><ul>
<li><code>InaccessiblePaths=/path/to/dir</code></li>
<li>指定服务无法访问的目录。访问这些目录将导致权限错误。</li>
</ul>
<h3 id="TemporaryFileSystem"><a href="#TemporaryFileSystem" class="headerlink" title="TemporaryFileSystem"></a>TemporaryFileSystem</h3><ul>
<li><code>TemporaryFileSystem=/path/to/dir:mode=755,size=10M</code></li>
<li>将指定目录挂载为临时文件系统（tmpfs），类似于 mount -t tmpfs。可以用来提供服务的临时存储空间。</li>
</ul>
<h3 id="PrivateTmp"><a href="#PrivateTmp" class="headerlink" title="PrivateTmp"></a>PrivateTmp</h3><ul>
<li><code>PrivateTmp=yes</code></li>
<li>启用服务的私有 &#x2F;tmp 和 &#x2F;var&#x2F;tmp 目录，防止不同服务之间的临时文件相互影响。</li>
</ul>
<h3 id="ProtectSystem"><a href="#ProtectSystem" class="headerlink" title="ProtectSystem"></a>ProtectSystem</h3><ul>
<li><code>ProtectSystem=full</code></li>
<li>限制服务对系统文件和目录的写入访问。<ul>
<li>ProtectSystem&#x3D;yes：将 &#x2F;usr 和其他系统目录设置为只读。</li>
<li>ProtectSystem&#x3D;full：将 &#x2F;etc 也设置为只读。</li>
<li>ProtectSystem&#x3D;strict：将整个系统设置为只读，除了通过 ReadWritePaths 显式允许的目录。</li>
</ul>
</li>
</ul>
<h3 id="ProtectHome"><a href="#ProtectHome" class="headerlink" title="ProtectHome"></a>ProtectHome</h3><ul>
<li><code>ProtectHome=yes</code></li>
<li>限制服务对用户主目录的访问。<ul>
<li>ProtectHome&#x3D;yes：将用户主目录挂载为不可访问。</li>
<li>ProtectHome&#x3D;read-only：将用户主目录挂载为只读。</li>
<li>ProtectHome&#x3D;no：不限制用户主目录的访问。</li>
</ul>
</li>
</ul>
<h3 id="MountFlags"><a href="#MountFlags" class="headerlink" title="MountFlags"></a>MountFlags</h3><ul>
<li><code>MountFlags=slave</code></li>
<li>设置挂载点的标志。通常用来隔离服务的挂载命名空间。</li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>部分环境中设置后并不能生效，报错内容如下：<br><img  
                       lazyload
                       alt="image"
                       data-src="/2024/0650acf1b8/1.png"
                       
                 ><br>你需要升级systemd和内核。</p>
<p>systemd在 233 版本之后对这一特性添加了支持。见<a class="link"   href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#BindPaths=" >systemd-man-BindPaths<i class="fas fa-external-link-alt"></i></a>。<br>内核版本不确定，笔者在4.19的内核上测试失败但在6.1.32的内核验证成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux的使用</title>
    <url>/2023/0442695.html</url>
    <content><![CDATA[<p>tmux是一个终端复用软件，可以让你在一个终端窗口中运行多个终端会话。它有很多的命令和选项</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>sudo apt install tmux</code></p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>1、桌面标准终端不支持分屏</p>
<p>2、终端关闭后运行的命令想继续运行</p>
<p>3、远程操作时让对方看到自己的操作内容</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/0442695/1.png"
                       
                 ></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>启动tmux</td>
<td>在终端输入tmux即可启动，会在当前窗口创建一个新的会话</td>
</tr>
<tr>
<td>创建新会话</td>
<td>tmux new -s session_name，其中session_name是会话名称</td>
</tr>
<tr>
<td>分离当前会话</td>
<td>按下快捷键Ctrl-b d即可分离当前会话</td>
</tr>
<tr>
<td>列出所有会话</td>
<td>tmux ls</td>
</tr>
<tr>
<td>恢复会话</td>
<td>tmux attach -t session_name，其中session_name是要恢复的会话名称</td>
</tr>
<tr>
<td>切换会话</td>
<td>tmux switch -t session_name，其中session_name是要切换的会话名称</td>
</tr>
<tr>
<td>关闭会话</td>
<td>tmux kill-session -t session_name，其中session_name是要关闭的会话名称;或在当前会话中按下快捷键Ctrl-b x，然后输入y关闭</td>
</tr>
<tr>
<td>分割窗格</td>
<td>按下快捷键Ctrl-b %(或tmux split-window -v)即可将当前窗格垂直分割，按下Ctrl-b “即可将当前窗格水平分割(或tmux split-window -h)</td>
</tr>
<tr>
<td>切换窗格</td>
<td>按下快捷键Ctrl-b 方向键即可切换到相应的窗格</td>
</tr>
<tr>
<td>调整窗格大小</td>
<td>按下快捷键Ctrl-b :进入命令模式，输入resize-pane -U、resize-pane -D、resize-pane -L、resize-pane -R来调整上下左右窗格的大小(或Ctrl-b 长按方向键)</td>
</tr>
<tr>
<td>切换窗口</td>
<td>按下快捷键Ctrl-b n切换到下一个窗口，按下Ctrl-b p切换到上一个窗口</td>
</tr>
<tr>
<td>列出所有窗口</td>
<td>按下快捷键Ctrl-b w即可列出所有窗口</td>
</tr>
<tr>
<td>创建新窗口</td>
<td>按下快捷键Ctrl-b c即可创建一个新窗口</td>
</tr>
<tr>
<td>关闭窗口</td>
<td>按下快捷键Ctrl-b &amp;即可关闭当前窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>union的使用</title>
    <url>/2023/0682a7d966.html</url>
    <content><![CDATA[<p>union的常见用法…</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">var_struct</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">        Int,</span><br><span class="line">        Double,</span><br><span class="line">        CharArr</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> iv;</span><br><span class="line">        <span class="type">double</span> dv;</span><br><span class="line">        <span class="type">char</span> *arr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Type t;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">type</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var_struct</span>(<span class="type">const</span> <span class="type">int</span> &amp;v) :iv&#123; v &#125;, <span class="built_in">t</span>(Int) &#123;&#125;</span><br><span class="line">    <span class="built_in">var_struct</span>(<span class="type">const</span> <span class="type">double</span> &amp;v) :dv&#123; v &#125;, <span class="built_in">t</span>(Double) &#123;&#125;</span><br><span class="line">    <span class="built_in">var_struct</span>(<span class="type">const</span> <span class="type">char</span> *s) :<span class="built_in">t</span>(CharArr) &#123;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">char</span>[len +<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(arr, s, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">toInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">toDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">toCharArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="type">void</span>) argc;</span><br><span class="line">    (<span class="type">void</span>) argv;</span><br><span class="line"></span><br><span class="line">    <span class="function">var_struct <span class="title">v1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">var_struct <span class="title">v2</span><span class="params">(<span class="number">12.34</span>)</span></span>;</span><br><span class="line">    <span class="function">var_struct <span class="title">v3</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; v1.<span class="built_in">type</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v1.<span class="built_in">toInt</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v2.<span class="built_in">type</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2.<span class="built_in">toDouble</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v3.<span class="built_in">type</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v3.<span class="built_in">toCharArr</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 100</span><br><span class="line">1 12.34</span><br><span class="line">2 hello</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>任务管控终端的代码实现</title>
    <url>/2023/0978b93c1c.html</url>
    <content><![CDATA[<p>任务管控终端，允许从远程接收任务执行并反馈任务执行结果</p>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>任务状态周期性上报机制，避免网络环境恶劣导致服务端无法获取任务执行情况<br>限制单个任务执行时长为2h<br>支持日志分类<br>支持导出历史任务执行状况，最多支持最近的1000个任务<br>支持通过DBus监听任务执行的实时状态</p>
<h3 id="任务类型-TaskType"><a href="#任务类型-TaskType" class="headerlink" title="任务类型-TaskType"></a>任务类型-TaskType</h3><table>
<thead>
<tr>
<th>类型</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ping</td>
<td>1</td>
<td>检查客户端是否存活，收到后应直接以约定的方式响应服务端</td>
</tr>
<tr>
<td>Bash</td>
<td>2</td>
<td>命令的内容一般是bash语句</td>
</tr>
<tr>
<td>Settings</td>
<td>3</td>
<td>命令的内容和本地要执行的任务是提前有对应关系的</td>
</tr>
<tr>
<td>Strategy</td>
<td>4</td>
<td>策略型任务，一般是一系列任务的集合</td>
</tr>
</tbody></table>
<h3 id="任务结构-Task"><a href="#任务结构-Task" class="headerlink" title="任务结构-Task"></a>任务结构-Task</h3><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>任务类型，决定了如何执行task_command命令</td>
</tr>
<tr>
<td>id</td>
<td>唯一的身份ID，用于标识身份</td>
</tr>
<tr>
<td>name</td>
<td>任务名称，仅做标记使用</td>
</tr>
<tr>
<td>command</td>
<td>任务的具体命令</td>
</tr>
</tbody></table>
<h2 id="程序模块"><a href="#程序模块" class="headerlink" title="程序模块"></a>程序模块</h2><table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TaskCache</td>
<td>负责任务状态缓存</td>
</tr>
<tr>
<td>TaskHandler</td>
<td>执行任务</td>
</tr>
<tr>
<td>TaskDispatcher</td>
<td>任务的分发</td>
</tr>
<tr>
<td>TaskManager</td>
<td>整体的任务管理</td>
</tr>
<tr>
<td>TaskReporter</td>
<td>任务状态上传</td>
</tr>
</tbody></table>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暂时不考虑超大QPS任务请求执行的场景，目前已满足普通商用需求。</p>
<p>利用多线程，支持并发执行多条任务，任务的状态会实时同步到本地缓存，避免异常掉电、崩溃等情况导致的任务丢失问题。周期性的上传任务完成状态到服务端，针对网络环境不稳定情况也能很好的处理。且开了单独的线程(比执行任务的线程优先级要高)用于上传状态。</p>
<p>写这个的目的一是想把心中的任务管理写出来，二是以后万一用到了直接过来拷贝就好了。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>大批量任务瞬间到达，引发内存峰值的情况还在考虑要不要处理</li>
<li>部分任务很可能需要root权限，考虑子母进程的方式分别实现root级别配置和用户级别的配置</li>
</ul>
<p>源码地址：<a class="link"   href="https://github.com/ssk-wh/task_manager/tree/master" >https://github.com/ssk-wh/task_manager/tree/master<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
        <tag>任务管控</tag>
      </tags>
  </entry>
  <entry>
    <title>僵尸进程</title>
    <url>/2024/022a2a7853.html</url>
    <content><![CDATA[<p>僵尸进程是指一个子进程已经终止但其父进程尚未读取其终止状态的进程，导致其进程表项仍然保留在系统中。</p>
<span id="more"></span>

<h1 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h1><p>如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵尸进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -o zombie zombie.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process with PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 子进程立即退出</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process with PID: %d, Child PID: %d\n&quot;</span>, getpid(), pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程继续执行其他任务，例如睡眠一段时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent process continue do something\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端中输入 <code>gcc -o zombie zombie.c</code> 进行编译，之后运行 <code>./zombie</code> 进程。此时通过 <code>ps -ef | grep zombie</code> 可以看到 fork 后的子进程变为僵尸进程。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2024/022a2a7853/1.png"
                       
                 ></p>
<h1 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h1><p>结合其产生的原因，在父进程中使用 wait 回收子进程残留的进程资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -o zombie zombie.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process with PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 子进程立即退出</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process with PID: %d, Child PID: %d\n&quot;</span>, getpid(), pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> wpid = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查子进程的退出状态</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process exited with status %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程继续执行其他任务，例如睡眠一段时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent process continue do something\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2024/022a2a7853/2.png"
                       
                 ></p>
<p>当一个子进程结束时，内核会向其父进程发送SIGCHLD信号。父进程可以通过捕获这个信号并在信号处理函数中调用wait()或waitpid()来回收子进程的资源，从而避免僵尸进程的产生。<br>这种方式也优雅一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -o zombie zombie.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里可以添加一些日志记录或其他处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGCHLD signal received, cleaning up child processes.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 等待所有子进程结束</span></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>); <span class="comment">// WNOHANG选项使得waitpid不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    signal(SIGCHLD, sigchld_handler);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process with PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">5</span>); <span class="comment">// 模拟子进程执行操作</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process with PID: %d, Child PID: %d\n&quot;</span>, getpid(), pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程继续执行其他任务</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程结束前，子进程可能已经结束，信号处理函数会处理SIGCHLD信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>基于lightdm开发轻量版greeter</title>
    <url>/2023/04c447ae7.html</url>
    <content><![CDATA[<h1 id="lightdm是什么"><a href="#lightdm是什么" class="headerlink" title="lightdm是什么"></a>lightdm是什么</h1><p>lightdm&#x2F;LightDM，全称”Light Display Manager”。是 linux 操作系统中的一种轻量级显示管理器，用于显示登录屏幕并处理用户登录。适用于 gnome、kde、xfce  和l xde 等不同的桌面环境，并且相对于其他登录管理器来说，占用的系统资源较少，启动速度也较快。</p>
<p>常见的登录管理器包括：</p>
<p>GDM (GNOME Display Manager)<br>SDDM (Simple Desktop Display Manager)<br>LightDM<br>XDM (X Display Manager)<br>KDM (KDE Display Manager)</p>
<p>还有其他一些较少使用的登录管理器，如SLiM和Entrance等。</p>
<h1 id="greeter是什么"><a href="#greeter是什么" class="headerlink" title="greeter是什么"></a>greeter是什么</h1><p>greeter 是 LightDM 登录管理器的用户界面。它提供了一个简单而美观的图形化界面，用户可以使用该界面登录到他们的系统。</p>
<p>业界常见的 greeter 包括：</p>
<table>
<thead>
<tr>
<th>greeter名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>unity greeter</td>
<td>这是 ubuntu使用的默认greeter，具有现代化的外观和感觉。它支持用户切换、自定义背景和语言。</td>
</tr>
<tr>
<td>lightdm webkit2 greeter</td>
<td>这个greeter使用webkit2引擎，支持html5和css3，提供了更灵活的自定义选项。</td>
</tr>
<tr>
<td>slick greeter</td>
<td>这个greeter具有紧凑的设计和简单的配置。它支持用户切换、自定义背景和语言。</td>
</tr>
<tr>
<td>gtk+ greeter</td>
<td>这个greeter采用gtk +工具包，支持多种语言和主题。</td>
</tr>
<tr>
<td>lxde greeter</td>
<td>这个greeter轻量级、快速，并具有直观的用户界面。它支持自定义主题、多个用户和面孔浏览功能。</td>
</tr>
<tr>
<td>pantheon greeter</td>
<td>这个greeter是 elementary os 的默认greeter，具有干净的设计和响应式布局。它支持用户切换、自定义背景和语言。</td>
</tr>
</tbody></table>
<p>这只是其中的一些示例，还有其他许多基于 LightDM 的可用 greeter 。</p>
<h1 id="开发库"><a href="#开发库" class="headerlink" title="开发库"></a>开发库</h1><p>liblightdm-qt5-3-dev 是一个用于与lightdm显示管理器交互的qt应用程序开发包。它包含了 lightdm qt 库的头文件和静态库。开发人员可以使用该软件包创建自定义登录界面或在他们的应用程序中添加其他lightdm功能。</p>
<p>安装开发包<br><code>sudo apt install liblightdm-qt5-3-dev</code></p>
<p>在此软件包中，提供了以下四个类，这些类足以为您的greeter应用程序提供支持</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>greeter.h</td>
<td>提供认证、回填密码、错误提示、语言设置、会话同步等功能</td>
</tr>
<tr>
<td>power.h</td>
<td>判断是否支持待机、休眠、关机、重启等操作以及待机、休眠、关机、重启接口</td>
</tr>
<tr>
<td>sessionsmodel.h</td>
<td>继承自QAbstractListModel，封装了所有的会话列表，数据一般源自&#x2F;usr&#x2F;share&#x2F;xsessions目录中的配置文件</td>
</tr>
<tr>
<td>usersmodel.h</td>
<td>继承自QAbstractListModel，封装了所有的用户信息</td>
</tr>
</tbody></table>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;greeter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLightDM/Greeter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLightDM/SessionsModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLightDM/UsersModel&gt;</span></span></span><br><span class="line"></span><br><span class="line">Greeter::<span class="built_in">Greeter</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">m_layout</span>(<span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">passwordEdit</span>(<span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">m_userList</span>(<span class="keyword">new</span> <span class="built_in">QListView</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">m_sessionCbx</span>(<span class="keyword">new</span> <span class="built_in">QComboBox</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">m_loginBtn</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Login&quot;</span>, <span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">m_greeter</span>(<span class="keyword">new</span> QLightDM::<span class="built_in">Greeter</span>(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> QT_DEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (!m_greeter-&gt;<span class="built_in">connectSync</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;connect sync failed&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">initUI</span>();</span><br><span class="line">    <span class="built_in">initConnections</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::initUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_layout-&gt;<span class="built_in">addWidget</span>(m_userList);</span><br><span class="line">    m_layout-&gt;<span class="built_in">addWidget</span>(passwordEdit);</span><br><span class="line">    m_layout-&gt;<span class="built_in">addWidget</span>(m_sessionCbx);</span><br><span class="line">    m_layout-&gt;<span class="built_in">addWidget</span>(m_loginBtn);</span><br><span class="line"></span><br><span class="line">    m_userList-&gt;<span class="built_in">setModel</span>(<span class="keyword">new</span> QLightDM::<span class="built_in">UsersModel</span>(<span class="keyword">this</span>));</span><br><span class="line">    m_userList-&gt;<span class="built_in">setCurrentIndex</span>(<span class="built_in">QModelIndex</span>());</span><br><span class="line">    m_sessionCbx-&gt;<span class="built_in">setModel</span>(<span class="keyword">new</span> QLightDM::<span class="built_in">SessionsModel</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::initConnections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">connect</span>(m_loginBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Greeter::onLogin);</span><br><span class="line">    <span class="built_in">connect</span>(m_greeter, &amp;QLightDM::Greeter::authenticationComplete, <span class="keyword">this</span>, &amp;Greeter::onAuthenticationComplete);</span><br><span class="line">    <span class="built_in">connect</span>(m_greeter, &amp;QLightDM::Greeter::showPrompt, <span class="keyword">this</span>, &amp;Greeter::onShowPrompt);</span><br><span class="line">    <span class="built_in">connect</span>(m_greeter, &amp;QLightDM::Greeter::showMessage, <span class="keyword">this</span>, &amp;Greeter::onShowMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::onLogin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cancel authentication</span></span><br><span class="line">    <span class="keyword">if</span> (m_greeter-&gt;<span class="built_in">inAuthentication</span>()) &#123;</span><br><span class="line">        m_greeter-&gt;<span class="built_in">cancelAuthentication</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start authentication</span></span><br><span class="line">    QModelIndex currentIndex = m_userList-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">    <span class="keyword">if</span> (currentIndex.<span class="built_in">isValid</span>() &amp;&amp; !m_greeter-&gt;<span class="built_in">inAuthentication</span>()) &#123;</span><br><span class="line">        m_greeter-&gt;<span class="built_in">authenticate</span>(currentIndex.<span class="built_in">data</span>(QLightDM::UsersModel::NameRole).<span class="built_in">toString</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;user list index is invalid or greeter is in authentication&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::onAuthenticationComplete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_greeter-&gt;<span class="built_in">isAuthenticated</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> index = m_sessionCbx-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">        m_greeter-&gt;<span class="built_in">startSessionSync</span>(m_sessionCbx-&gt;<span class="built_in">itemData</span>(index, QLightDM::SessionsModel::IdRole).<span class="built_in">toString</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        passwordEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;Incorrect password, please try again&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::onShowPrompt</span><span class="params">(<span class="type">const</span> QString &amp;text, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; text &lt;&lt; <span class="built_in">static_cast</span>&lt;QLightDM::Greeter::PromptType&gt;(type);</span><br><span class="line">    m_greeter-&gt;<span class="built_in">respond</span>(passwordEdit-&gt;<span class="built_in">text</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Greeter::onShowMessage</span><span class="params">(QString text, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; text &lt;&lt; <span class="built_in">static_cast</span>&lt;QLightDM::Greeter::MessageType&gt;(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04c447ae7/2.png"
                       
                 ></p>
<p><code>Greeter</code>类实现了一个简单的登录界面，该界面包括以下几个要素：</p>
<p>账户列表：在该列表中列出了所有可用的用户账户，用户可以通过选中所需账户来进入其对应账户的登录页面。<br>密码输入框：在该输入框中，用户需要输入与所选账户对应的密码信息才能完成登录操作。<br>下拉列表：该下拉列表提供多个会话文件的选择，这些会话文件定义了一些桌面设置和应用程序的配置等信息，用户可以从中选择自己喜欢的会话选项。<br>登录按钮：当用户输入正确的密码并选择所需的会话后，可以点击此按钮以完成整个登录过程。</p>
<p>为用户提供了一个简易的登录界面，使得用户可以方便地完成登录操作，并在多个会话配置中选择最适合自己的会话选项。</p>
<p><strong>示例程序</strong></p>
<p><a class="link"   href="https://github.com/ssk-wh/ssk-wh.github.io/raw/master/files/lighter-greeter.zip" >完整demo<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h1><blockquote>
<p><span style="color:red">在您操作之前，请确保您拥有相关的领域知识，在碰到意外时能及时保存您的数据资产，否则请止步。</span></p>
</blockquote>
<p>在 <code>/usr/share/xgreeters</code> 目录中创建 lighter-greeter.desktop ,内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Name</span>=Lighter Greeter</span><br><span class="line"><span class="attr">Comment</span>=Lighter Greeter</span><br><span class="line"><span class="attr">Exec</span>=[修改为上面的demo编译出的二进制文件的具体路径]</span><br><span class="line"><span class="attr">Type</span>=Application</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改lightdm的配置文件，让 lightdm 在启动时拉起自定义的 greeter 启动文件</p>
<p><code>sudo vim /etc/lightdm/lightdm.conf</code></p>
<p>在<code>[Seat:*]</code>组中的修改以下两行信息(如果不存在需要手动添加)</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">greeter-session</span>=lighter-greeter</span><br><span class="line"><span class="attr">user-session</span>=deepin</span><br></pre></td></tr></table></figure>


<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04c447ae7/1.png"
                       
                 ></p>
<p>保存退出重启电脑即可。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a class="link"   href="https://launchpad.net/lightdm" >Light Display Manager<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://zh.wikipedia.org/wiki/LightDM" >LightDM<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/surlykke/qt-lightdm-greeter" >qt-lightdm-greeter<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>lightdm</tag>
        <tag>greeter</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程插件框架</title>
    <url>/2023/07c89d356.html</url>
    <content><![CDATA[<p>多进程的方式实现一份插件框架，优点是进程间隔离，接口统一，便于管控。且宿主进程不会受恶意插件的影响。<br>缺点就是系统中进程数量增加。</p>
<span id="more"></span>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/07c89d356/1.jpg"
                       
                 ></p>
<p><a class="link"   href="https://github.com/ssk-wh/ssk-wh.github.io/raw/master/files/dtraywatcher-master.zip" >代码示例<i class="fas fa-external-link-alt"></i></a> 或访问 <a class="link"   href="https://github.com/ssk-wh/dtraywatcher" >Github<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title>宏内核与微内核：深入理解计算机操作系统的核心</title>
    <url>/2024/072650bdc9.html</url>
    <content><![CDATA[<p>在计算机操作系统的设计中，内核（Kernel）是一个至关重要的组成部分。内核作为系统软件的核心，负责管理系统资源，协调硬件和软件之间的交互。根据设计思想的不同，内核可以分为两种主要类型：宏内核（Monolithic Kernel）和微内核（Microkernel）。本文将深入探讨这两种内核的区别、各自的优缺点以及一些实际的例子。</p>
<span id="more"></span>

<h4 id="什么是宏内核？"><a href="#什么是宏内核？" class="headerlink" title="什么是宏内核？"></a>什么是宏内核？</h4><p>宏内核是一种传统的操作系统内核设计，其特点是将操作系统的大部分功能都集成在一个大内核中。这个大内核直接运行在硬件之上，并且具有完整的系统功能，包括进程管理、内存管理、文件系统、设备驱动等。<br /><strong>优点：</strong></p>
<ol>
<li><strong>性能高：</strong> 由于大部分服务都在内核空间内运行，系统调用和进程间通信的开销较低。</li>
<li><strong>实现简单：</strong> 开发者可以直接在内核空间内实现大部分功能，减少了用户空间与内核空间之间的切换。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>稳定性差：</strong> 由于所有功能都在内核空间运行，一旦某个部分出现错误，可能导致整个系统崩溃。</li>
<li><strong>维护复杂：</strong> 宏内核代码量大，任何修改都需要对整个内核进行重新编译，测试和调试难度较大。</li>
</ol>
<p><strong>实际例子：</strong></p>
<ul>
<li><strong>Linux内核：</strong> Linux是最典型的宏内核操作系统，它将大部分功能集成在内核中。</li>
<li><strong>Windows NT内核：</strong> 尽管微软声称Windows NT内核是微内核架构，但实际上它更接近于宏内核设计，因为许多服务都在内核模式下运行。</li>
</ul>
<h4 id="什么是微内核？"><a href="#什么是微内核？" class="headerlink" title="什么是微内核？"></a>什么是微内核？</h4><p>微内核则采用了截然不同的设计思路。它将操作系统的核心功能精简到最小，仅保留最基础的部分，如进程间通信、基本的内存管理和简单的硬件驱动。其他系统服务则运行在用户空间，以减少内核的复杂度。<br /><strong>优点：</strong></p>
<ol>
<li><strong>稳定性高：</strong> 由于内核中只包含最基本的功能，即使某个用户空间服务崩溃，系统整体仍能保持稳定。</li>
<li><strong>安全性好：</strong> 用户空间服务与内核之间的隔离，减少了内核受到攻击的可能性。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>性能低：</strong> 由于系统服务运行在用户空间，频繁的系统调用和进程间通信会带来较大的性能开销。</li>
<li><strong>实现复杂：</strong> 需要设计高效的通信机制，以保证用户空间服务之间的交互顺畅。</li>
</ol>
<p><strong>实际例子：</strong></p>
<ul>
<li><strong>MINIX：</strong> MINIX是一个典型的微内核操作系统，因其简洁的设计而被广泛用于教学。</li>
<li><strong>QNX：</strong> QNX是一种商用实时操作系统，采用微内核设计，广泛应用于嵌入式系统中。</li>
</ul>
<h4 id="宏内核与微内核的比较"><a href="#宏内核与微内核的比较" class="headerlink" title="宏内核与微内核的比较"></a>宏内核与微内核的比较</h4><table>
<thead>
<tr>
<th>特点</th>
<th>宏内核</th>
<th>微内核</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>所有功能集成在内核中</td>
<td>只保留核心功能，其他服务运行在用户空间</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>较低</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定性差</td>
<td>稳定性高</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性一般</td>
<td>安全性好</td>
</tr>
<tr>
<td>维护和扩展</td>
<td>维护复杂，扩展困难</td>
<td>维护较简单，扩展性好</td>
</tr>
</tbody></table>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>宏内核和微内核各有优缺点，选择哪种内核架构取决于具体的应用场景和需求。对于需要高性能和快速响应的系统，如桌面操作系统和服务器操作系统，宏内核通常是首选。而对于需要高稳定性和安全性的系统，如嵌入式系统和实时操作系统，微内核则更具优势。通过理解这两种内核架构的特点和差异，开发者可以更好地设计和优化操作系统，以满足不同的应用需求。<br />希望这篇文章能帮助你更好地理解宏内核和微内核。如果你有任何疑问或需要进一步探讨，欢迎在评论区留言。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>性能分析-火焰图</title>
    <url>/2024/029209f875.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>火焰图是一种可视化工具，用于直观地展示程序的性能瓶颈和函数调用层次。它通过图形化展示函数调用栈，使得用户可以轻松地识别性能瓶颈和分析程序的性能特征。<br>在Linux系统中，使用火焰图通常需要使用工具如 FlameGraph 和 <strong>perf</strong> 来生成和分析火焰图。</p>
<blockquote>
<p>使用比较简单，按照下面的步骤固定操作即可</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 perf 和 FlameGraph 工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-base</span><br><span class="line"><span class="comment"># 因为我的内核版本是4.19，所以安装的是linux-perf-4.19</span></span><br><span class="line">sudo apt-get install linux-perf-4.19</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 FlameGraph，用于将 perf 采集的数据生成火焰图</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br></pre></td></tr></table></figure>
<h1 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h1><p><code>perf record -F 99 -g -p &lt;pid_or_command&gt;</code><br><code>perf record -F 99 -g &lt;command&gt;</code></p>
<p><code>perf script | ./FlameGraph/stackcollapse-perf.pl &gt; out.folded</code></p>
<p><code>./FlameGraph/flamegraph.pl out.folded &gt; output.svg</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>性能分析</tag>
        <tag>火焰图</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/10735e5788.html</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重复地遍历待排序的数列，每次比较相邻的两个元素，如果顺序错误就交换它们，直到没有相邻元素需要交换为止。在每一轮遍历中，都会将待排序序列中的最大元素移到序列的末尾。</p>
<p><strong>步骤</strong></p>
<p>具体实现过程如下：</p>
<p>从待排序序列的第一个元素开始，依次比较相邻的两个元素，如果顺序错误就交换它们。</p>
<p>继续向下遍历，比较相邻的两个元素，并进行交换。</p>
<p>重复上述步骤，直到没有相邻元素需要交换为止。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/bubbleSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="comment">// 遍历整个数组 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次遍历将最大值放在数组末尾，因此只需要遍历 n - i - 1 次</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果相邻的元素顺序错误，则交换它们的位置</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    bubble_sort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序将数组 {5, 3, 8, 4, 2} 进行冒泡排序，并输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原数组为：<span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> </span><br><span class="line">排序后的数组为：<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> </span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>它的基本思想是在待排序的序列中找到最小（或最大）的元素，将其放在序列的起始位置，然后再在剩余的元素中继续寻找最小（或最大）的元素，放在已排序的序列末尾。以此类推，直到所有元素都排序完成</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/selectionSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    selectionSort(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是一种简单的排序算法，它基于插入的思想。在插入排序中，将待排序的元素从未排序的序列中逐个取出，并将其插入到已排序的序列中的正确位置，直到所有元素都被插入到已排序的序列中为止。</p>
<p><strong>步骤</strong></p>
<p>具体来说，插入排序分为两个步骤：<br>（1）将待排序的第一个元素视为已排序的序列，然后将第二个元素插入到已排序的序列中的正确位置；<br>（2）重复执行上述步骤，直到所有元素都被插入到已排序的序列中。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/insertionSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_index, temp;</span><br><span class="line">    <span class="comment">// 遍历整个数组 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min_index = i;</span><br><span class="line">        <span class="comment">// 在剩余未排序的元素中寻找最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_index]) &#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小值与已排序序列末尾元素交换位置</span></span><br><span class="line">        temp = arr[min_index];</span><br><span class="line">        arr[min_index] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    selection_sort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序将数组 {5, 3, 8, 4, 2} 进行选择排序，并输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原数组为：<span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> </span><br><span class="line">排序后的数组为：<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有元素都比另外一部分的所有元素都小，然后分别对这两部分继续进行快速排序，直到整个序列有序。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/quickSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];  <span class="comment">// 选取第一个元素作为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotPos = partition(arr, low, high);  <span class="comment">// 将数组划分为两部分</span></span><br><span class="line">        quicksort(arr, low, pivotPos - <span class="number">1</span>);  <span class="comment">// 递归调用</span></span><br><span class="line">        quicksort(arr, pivotPos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    quicksort(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>步骤</strong></p>
<p>快速排序的具体实现过程如下：</p>
<p>从数列中挑出一个元素，称为基准（pivot）。<br>重新排序数列，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/mergeSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = right, pivot = arr[(left + right) / <span class="number">2</span>], temp;</span><br><span class="line">    <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; j) &#123;</span><br><span class="line">        quick_sort(arr, left, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">        quick_sort(arr, i, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序将数组 {5, 3, 8, 4, 2} 进行快速排序，并输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这个程序将数组 &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125; 进行快速排序，并输出结果：</span><br></pre></td></tr></table></figure>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是一种线性时间复杂度的排序算法，用于对整数序列进行排序。它的基本思想是统计每个元素出现的次数，然后按照元素的大小顺序将它们输出到结果数组中。</p>
<p><strong>步骤</strong></p>
<p>计数排序的实现步骤如下：</p>
<p>找出待排序的数组中最大和最小的元素。<br>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项。<br>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）。<br>反向填充目标数组：将每个元素 i 放在目标数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/countingSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counting_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 找出最大和最小元素</span></span><br><span class="line">    <span class="type">int</span> max_num = arr[<span class="number">0</span>], min_num = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_num) &#123;</span><br><span class="line">            max_num = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min_num) &#123;</span><br><span class="line">            min_num = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计元素出现次数</span></span><br><span class="line">    <span class="type">int</span> count_arr[max_num - min_num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=max_num-min_num; i++) &#123;</span><br><span class="line">        count_arr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        count_arr[arr[i]-min_num]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对所有计数累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=max_num-min_num; i++) &#123;</span><br><span class="line">        count_arr[i] += count_arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向填充目标数组</span></span><br><span class="line">    <span class="type">int</span> sorted_arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        sorted_arr[count_arr[arr[i]-min_num]<span class="number">-1</span>] = arr[i];</span><br><span class="line">        count_arr[arr[i]-min_num]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序后的数组复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        arr[i] = sorted_arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    counting_sort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出结果为：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序（Shell Sort）是一种基于插入排序的排序算法，它通过将原数组划分成多个子序列来改进插入排序，从而提高排序效率。希尔排序的基本思想是将相距某个“增量”的元素组成一个子序列进行插入排序，然后逐步缩小增量，直到增量为1，完成最后一次插入排序，最终达到整个序列有序的目的。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/Sorting_shellsort_anim.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> gap, i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    shell_sort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出结果为：输出结果为：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序（Bucket Sort）是一种基于计数排序的排序算法，它利用了映射函数将原数组中的元素映射到有限数量的桶（bucket）中，并在每个桶中分别进行排序，最终将所有桶中的元素合并成一个有序的数组。桶排序适用于待排序元素的范围比较小，且元素分布较为均匀的情况下，时间复杂度可以达到线性级别。</p>
<p>元素分布在桶中：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/Bucket_sort_1.svg_.png"
                       
                 ></p>
<p>然后，元素在每个桶中排序：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/Bucket_sort_2.svg_.png"
                       
                 ></p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKET_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucket_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> bucket[BUCKET_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ++bucket[arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; BUCKET_SIZE; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[i++] = j;</span><br><span class="line">            --bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[ARRAY_SIZE] = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before sorting: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_sort(arr, ARRAY_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nAfter sorting: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Before sorting: <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">9</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">0</span> </span><br><span class="line">After sorting: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heap Sort）是一种基于完全二叉树结构的排序算法，它利用堆这种数据结构来实现排序。堆可以看作是一种优先队列，它满足以下性质：</p>
<p>父节点的值大于或等于（小于或等于）其子节点的值，称为大根堆（小根堆）；<br>堆是一个完全二叉树，除了最后一层节点可能不满，其他层节点都是满的。<br>堆排序的基本思路是，首先将待排序数组构建成一个大根堆或小根堆，然后将堆顶元素与堆末元素交换，再重新调整堆结构，直到排序完成。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/heapSort.gif"
                         width = "" height = ""
                 ></center>

<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/Sorting_heapsort_anim.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> root, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent = root;</span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 如果右子节点存在且值大于左子节点，则选择右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点值大于等于子节点值，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (arr[parent] &gt;= arr[child]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则交换父子节点的值，并继续向下调整</span></span><br><span class="line">        <span class="type">int</span> temp = arr[parent];</span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        arr[child] = temp;</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 将待排序数组构建为一个大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不断将堆顶元素与堆末元素交换，并重新调整堆结构，直到排序完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">// 减小堆的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    heap_sort(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原数组为：<span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> </span><br><span class="line">排序后的数组为：<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序（Radix Sort）是一种非比较排序算法，它将待排序的元素拆分成若干个位数或字符，然后按照每个位数或字符分别进行排序。基数排序可以使用桶排序实现。</p>
<center><img    
                       lazyload
                       alt="image"
                       data-src="/2021/10735e5788/radixSort.gif"
                         width = "" height = ""
                 ></center>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对给定数字根据 exp 进行计数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">exp</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> output[n]; <span class="comment">// 存储 (arr 中元素根据 exp 计算出来的) 排序结果的辅助数组</span></span><br><span class="line">    <span class="type">int</span> i, buckets[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 创建包含 10 个桶的数组，并初始化每个桶的数量为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        buckets[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改桶，使每个桶存储该桶前面所有桶中元素的数量总和</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 exp 和已分配到的桶，将数据存储到 output 数组中</span></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        output[buckets[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        buckets[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 output 拷贝回 arr 数组，相当于更新原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>, max = getMax(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从个位数开始排到最高位，依次按照不同数位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)</span><br><span class="line">        countSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    radixSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sorted <span class="built_in">array</span>: </span><br><span class="line"><span class="number">2</span> <span class="number">24</span> <span class="number">45</span> <span class="number">66</span> <span class="number">75</span> <span class="number">90</span> <span class="number">170</span> <span class="number">802</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>在实现基数排序时，需要注意以下几点：</p>
<pre><code>获取数组中最大元素的位数：可以使用一个函数来获取数组中最大元素的位数，例如 get_max_digit 函数。

创建桶：因为每个桶都是一个数组，所以可以使用一个指向指针数组的指针来表示桶数组，例如 int *buckets[10]。

将元素放入桶中：对于每个元素，根据其当前位数上的数值将其放入对应的桶中。

将桶中的元素按顺序放回数组中：按照从小到大的顺序依次将桶中的元素放回数组中，这里可以使用一个计数器来记录放回数组的元素的位置。

清空桶：在每次使用完桶之后，需要将桶中的元素清空，以便下一次使用。
</code></pre>
<p>当待排序元素为整数类型时，基数排序可以比快速排序、归并排序等算法更快地完成排序。</p>
<p>同时需要注意，基数排序的实现比较复杂，尤其是在涉及到整数位数的时候，需要花费较多的时间进行调试。</p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>本文图片资源来自 <a class="link"   href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" >菜鸟教程<i class="fas fa-external-link-alt"></i></a> </p>
]]></content>
  </entry>
  <entry>
    <title>文件系统层次结构</title>
    <url>/2023/0647e0b1da.html</url>
    <content><![CDATA[<h1 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h1><table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>整个文件系统层次结构的根目录</td>
</tr>
<tr>
<td>&#x2F;bin&#x2F;</td>
<td>放置系统基本用户命令，所有用户可用</td>
</tr>
<tr>
<td>&#x2F;boot&#x2F;</td>
<td>放置内核及LILO、GRUB等引导程序的文件，用于系统启动</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;</td>
<td>放置硬盘、分区、键盘、鼠标、USB设备、tty等所有的系统设备文件</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;null</td>
<td>一个无限的数据源和数据接收设备，所有写至此设备的数据应被废弃，从此设备读应总是返回EOF</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;zero</td>
<td>此设备是零输出数据源，写至此设备的所有数据应被废弃，从该设备的一次读操作应总是返回请求的字节数，并且每个字节都被初始化为’\0’</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;tty</td>
<td>如果进程所属的进程组有相关联的控制终端，&#x2F;dev&#x2F;tty是该控制终端的同义词，所有对&#x2F;dev&#x2F;tty的读写行为应等同于对已打开的实际控制终端设备的相应操作</td>
</tr>
<tr>
<td>&#x2F;dev&#x2F;shm</td>
<td>放置POSIX共享内存段</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;</td>
<td>放置系统的所有配置文件</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;opt&#x2F;</td>
<td>&#x2F;opt下第三方应用程序的特定于主机的配置文件的存储目录</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;X11&#x2F;</td>
<td>X11的配置文件目录</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;default</td>
<td>一个包含系统部分服务默认参数配置文件的目录</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;timezone</td>
<td>一个系统时区配置文件。当系统采用世界标准时间(UTC)时区时，可以没有timezone文件。</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd</td>
<td>一个系统用户信息配置文件</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;group</td>
<td>一个系统组信息配置文件</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;systemd&#x2F;</td>
<td>一个包含systemd服务配置文件的目录</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;profile.d&#x2F;</td>
<td>一个包含shell脚本的目录。脚本名字应遵循cron jobs所指定的相同约定，但是应该有.sh后缀，也没有特别规定所安装在该目录下的脚本文件一定要具有此后缀。当sh工具被当作一个交互式登录shell被调用,或带有-l参数执行时，应从该目录中读取所有后缀为.sh的脚本中的命令，并在当前执行环境中执行</td>
</tr>
<tr>
<td>&#x2F;home&#x2F;</td>
<td>所有用户的个人目录，每个用户独立一个目录，存放用户个人的配置和文档</td>
</tr>
<tr>
<td>&#x2F;lib&#x2F;和lib64&#x2F;</td>
<td>系统共享库目录，存放系统最基本的动态连接共享库</td>
</tr>
<tr>
<td>&#x2F;media&#x2F;</td>
<td>挂接CD-ROM、移动硬盘等可移除设备的目录</td>
</tr>
<tr>
<td>&#x2F;mnt&#x2F;</td>
<td>用于临时挂载的目录</td>
</tr>
<tr>
<td>&#x2F;opt&#x2F;</td>
<td>放置第三方应用程序的目录</td>
</tr>
<tr>
<td>&#x2F;proc&#x2F;</td>
<td>系统运行时内存信息映射目录</td>
</tr>
<tr>
<td>&#x2F;proc&#x2F;sys&#x2F;</td>
<td>查看和修改内核的运行参数的目录</td>
</tr>
<tr>
<td>&#x2F;root&#x2F;</td>
<td>根用户主目录</td>
</tr>
<tr>
<td>&#x2F;run&#x2F;</td>
<td>放置应用程序运行期间需要的一些短暂存在的文件</td>
</tr>
<tr>
<td>&#x2F;run&#x2F;log&#x2F;</td>
<td>放置运行时日志的目录</td>
</tr>
<tr>
<td>&#x2F;sbin&#x2F;</td>
<td>放置超级用户使用的系统命令的目录</td>
</tr>
<tr>
<td>&#x2F;srv&#x2F;</td>
<td>放置系统服务进程所需数据文件的目录，例如ftp等</td>
</tr>
<tr>
<td>&#x2F;sys&#x2F;</td>
<td>存放内核和系统虚拟文件系统信息的目录</td>
</tr>
<tr>
<td>&#x2F;tmp&#x2F;</td>
<td>放置程序运行中生成的临时文件（系统重新启动目录下文件可能被清除）的目录，在系统重启时目录中文件不会被保留。</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;</td>
<td>放置默认软件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>放置应用程序的二进制文件和可执行文件的目录，所有用户可用</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;include&#x2F;</td>
<td>放置系统库的C和C++ API头文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;local&#x2F;</td>
<td>放置系统管理员在本地安装的应用软件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib和&#x2F;usr&#x2F;lib64</td>
<td>放置&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;sbin目录下程序使用的库文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;sbin&#x2F;</td>
<td>放置应用程序二进制文件和可执行文件的目录，需要超级用户权限</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;</td>
<td>放置与体系结构无关的可共享的数据文件的目录，包括文档、手册、时区信息、字体等</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man&#x2F;</td>
<td>存放在线手册的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;misc&#x2F;</td>
<td>存放与体系结构无关的文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;applications&#x2F;</td>
<td>放置系统启动选单或系统桌面的应用软件启动快捷方式.desktop文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>放置操作系统或系统包文档的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;</td>
<td>放置系统字体文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;locale</td>
<td>放置系统多语言支持文件的目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;src&#x2F;</td>
<td>放置源代码文件的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;</td>
<td>放置系统运行过程中不断改变的文件的目录，如日志文件</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run&#x2F;utmp和&#x2F;var&#x2F;log&#x2F;wtmp</td>
<td>用户登录信息日志文件，其中wtmp日志永久记录每个用户登录、注销及系统的启动等事件，utmp日志记录当前登录系统的每个用户的信息。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;cache&#x2F;</td>
<td>放置系统缓存数据的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lib&#x2F;</td>
<td>放置程序本身执行过程中需要使用到的数据文件放置的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lib&#x2F;misc&#x2F;</td>
<td>存放杂项可变数据的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;lock&#x2F;</td>
<td>放置锁文件目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;</td>
<td>放置系统日志和应用日志文件的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;mail&#x2F;</td>
<td>放置用户电子邮箱的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;opt&#x2F;</td>
<td>存放&#x2F;opt中的软件包的可变数据</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run&#x2F;</td>
<td>放置自系统启动以来描述系统信息的文件</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;spool&#x2F;</td>
<td>等待处理的任务的脱机文件。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;</td>
<td>放置cron和at程序的可变数据的目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;tmp&#x2F;</td>
<td>放置较大且持续的临时性文件</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run</td>
<td>为指向&#x2F;run的符号链接，系统兼容性用，应用开发不推荐使用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>标准</tag>
        <tag>文件目录</tag>
      </tags>
  </entry>
  <entry>
    <title>文章模板</title>
    <url>/2023/049f87bd8f.html</url>
    <content><![CDATA[<h1 id="标准MarkDown语法支持"><a href="#标准MarkDown语法支持" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h1><h2 id="标准MarkDown语法支持-1"><a href="#标准MarkDown语法支持-1" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h2><h3 id="标准MarkDown语法支持-2"><a href="#标准MarkDown语法支持-2" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h3><h4 id="标准MarkDown语法支持-3"><a href="#标准MarkDown语法支持-3" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h4><h5 id="标准MarkDown语法支持-4"><a href="#标准MarkDown语法支持-4" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h5><h6 id="标准MarkDown语法支持-5"><a href="#标准MarkDown语法支持-5" class="headerlink" title="标准MarkDown语法支持"></a>标准MarkDown语法支持</h6><p><code>标准MarkDown语法支持</code></p>
<br>

<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/049f87bd8f/1.png"
                       
                 ></p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/049f87bd8f/1.svg"
                       
                 ></p>
<h3 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h3><img    
                       lazyload
                       alt="image"
                       data-src="1.svg"
                         style="zoom: 25%;" 
                 >

<h1 id="Gif图片"><a href="#Gif图片" class="headerlink" title="Gif图片"></a>Gif图片</h1><center><img    
                       lazyload
                       alt="image"
                       data-src="/2023/049f87bd8f/1.gif"
                         width = "" height = ""
                 ></center>

<br>

<h1 id="Mp4视频"><a href="#Mp4视频" class="headerlink" title="Mp4视频"></a>Mp4视频</h1><p><video src="/2023/049f87bd8f/1.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p>
<br>

<h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><p><span style="color:red">红色</span><br><span style="color:green">绿色</span><br><span style="color:blue">蓝色</span><br><span style="color:gray">灰色</span></p>
<blockquote>
<p>提示文本</p>
</blockquote>
<blockquote>
<p><span style="color:pink">粉红色</span><br><kbd>键盘文本</kbd><br><mark>高亮文本</mark><br><u>划线文本</u></p>
</blockquote>
<p>😀 🤪 🤣 😄 🥳 🤔 🧐<br>🤨 😐 🙁 👉 👇 👍 👏<br>👀 💀 👻 🙈 🎅<br>🦆 🦢 🐧 🐤 🐌 🦀 🌱 🌴<br>💌 💘 🎈 🎉 📢 🎀 🔖 📒<br>🚗 🛹 ⚓ 🚢 🚀<br>⭐ 🔥 🌈 🪶 📌 ✅ 📝<br>🥝 🍎 🍉 🥑 🍕 🍖 🍡 🍬 🍭 🍰</p>
<p>更多 emoji 详见 <a class="link"   href="https://www.webfx.com/tools/emoji-cheat-sheet/" >Emoji Cheat Sheet<i class="fas fa-external-link-alt"></i></a></p>
<br>

<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内容折叠"><a href="#内容折叠" class="headerlink" title="内容折叠"></a>内容折叠</h1><details>
  <summary>内容折叠</summary>
    这是一段折叠的内容
</details>

<h1 id="支持滚动的内容区域"><a href="#支持滚动的内容区域" class="headerlink" title="支持滚动的内容区域"></a>支持滚动的内容区域</h1><pre><code>第一行
第二行
第三行
这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本
</code></pre>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针-QPointer</title>
    <url>/2022/1056575.html</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>QPointer<T>是一个受保护的指针 。它的行为类似于普通的 C++ 指针 T *，只是它会在被引用的对象被销毁时自动清除（与普通的 C++ 指针不同，在这种情况下会变成“悬空指针”）。 </p>
<span id="more"></span>

<p>注意：T 必须是 QObject 的子类。<br>当您需要存储指向其他人拥有的 QObject 的指针时，受保护的指针很有用。在您仍然持有对它的引用时，实际指向的内容可能已经被销毁。此时您可以通过QPointer安全地测试指针的有效性。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPointer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_STATIC_ASSERT_X</span>(!std::is_pointer&lt;T&gt;::value, <span class="string">&quot;QPointer&#x27;s template type must not be a pointer type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TypeSelector</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> QObject Type;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TypeSelector</span>&lt;<span class="type">const</span> U&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> QObject Type;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> TypeSelector&lt;T&gt;::Type QObjectType;</span><br><span class="line">    QWeakPointer&lt;QObjectType&gt; wp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QPointer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QPointer</span><span class="params">(T *p)</span> : wp(p, true) &#123;</span> &#125;</span><br><span class="line">    <span class="comment">// compiler-generated copy/move ctor/assignment operators are fine!</span></span><br><span class="line">    <span class="comment">// compiler-generated dtor is fine!</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造时可不传参数，这将会构造处一个空的智能指针。<br>或构造时传入T类型的指针p,传递到私有成员指针QWeakPointer wp.需要注意的是，类型T必须是QObject类型或其子类的指针（为什么这样设计，后面会介绍）。<br>这里Qt使用了std::is_pointer去检查传入的参数是否是一个指针类型。</p>
<p>同时，这里还限定了传入的指针类型必须是QObject类型或其子类。<br>观察QWeakPointer的实现可以看到，传入的T类型指针作为wp的构造参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(X *ptr, <span class="type">bool</span>)</span> : d(ptr ? Data::getAndRef(ptr) : nullptr), value(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终在QWeakPointer的成员变量d指针初始化时，将T类型的指针ptr传给了getAndRef函数，getAndRef函数的参数限定了为QObject，所以只能传QObject类型哦，否则在编译时一定会产生指针类型无法为QObject错误提示呢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">static</span> ExternalRefCountData *<span class="title">getAndRef</span><span class="params">(<span class="type">const</span> QObject *)</span></span>;</span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">void</span> <span class="title">setQObjectShared</span><span class="params">(<span class="type">const</span> QObject *, <span class="type">bool</span> enable)</span></span>;</span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">void</span> <span class="title">checkQObjectShared</span><span class="params">(<span class="type">const</span> QObject *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_QDOC</span></span><br><span class="line">    <span class="comment">// Stop qdoc from complaining about missing function</span></span><br><span class="line">    ~<span class="built_in">QPointer</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在实际编译过程中，Q_QDOC实际并没有定义，所以也就不会有析构函数。换言之，使用的是类的默认析构函数。毕竟构造函数下面也注释了<code>// compiler-generated dtor is fine!</code><br>（为什么这样写呢，在我之前写的一篇根因分析中其实介绍过，这里只是qt在使用qdoc工具生成帮助文档时，如果不写析构函数，会在生成过程中产生警告）</p>
<h1 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h1><p>QPointer的方法都比较简单，都是为了让QPointer使用起来就像是一个真正的指针一样，有疑惑的地方可以查阅_源码赏析_一节。</p>
<table>
<thead>
<tr>
<th>原型</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td>QPointer()</td>
<td>Constructs a guarded pointer that points to the same object that p points to.</td>
</tr>
<tr>
<td>QPointer(T *p)</td>
<td>Constructs a guarded pointer with value nullptr.</td>
</tr>
<tr>
<td>~QPointer()</td>
<td>Destroys the guarded pointer. Just like a normal pointer, destroying a guarded pointer does not destroy the object being pointed to.</td>
</tr>
<tr>
<td>void clear()</td>
<td>Clears this QPointer object. This function was introduced in Qt 5.0. See also isNull().</td>
</tr>
<tr>
<td>T *	data() const</td>
<td>Returns the pointer to the object being guarded.</td>
</tr>
<tr>
<td>T *	get() const</td>
<td>Same as data(). This function is provided for STL compatibility. This function was introduced in Qt 6.0.</td>
</tr>
<tr>
<td>bool isNull() const</td>
<td>Returns true if the referenced object has been destroyed or if there is no referenced object; otherwise returns false.</td>
</tr>
<tr>
<td>void	swap(QPointer<T> &amp;other)</td>
<td>Swaps the contents of this QPointer with the contents of other. This operation is very fast and never fails. This function was introduced in Qt 5.6.</td>
</tr>
<tr>
<td>T *	operator T *() const</td>
<td>Cast operator; implements pointer semantics. Because of this function you can pass a QPointer<T> to a function where a T* is required.</td>
</tr>
<tr>
<td>T &amp;	operator*() const</td>
<td>Dereference operator; implements pointer semantics. Just use this operator as you would with a normal C++ pointer.</td>
</tr>
<tr>
<td>T *	operator-&gt;() const</td>
<td>Overloaded arrow operator; implements pointer semantics. Just use this operator as you would with a normal C++ pointer.</td>
</tr>
<tr>
<td>QPointer<T> &amp;	operator&#x3D;(T *p)</td>
<td>Assignment operator. This guarded pointer will now point to the same object that p points to.</td>
</tr>
</tbody></table>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><p>当QPointer持有的指针销毁时，我们可以使用QPointer::isNull()来判断指针的情况，先看下isNull的实现。wp是一个QWeakPointer指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> wp.<span class="built_in">isNull</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>再来看下QWeakPointer的isNull的实现，当其内容成员d或value的指针为空或者d-&gt;strongref.load() &#x3D;&#x3D; 0时，isNull返回true.这里的d对应的结构为ExternalRefCountData</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWeakPointer</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW </span>&#123; <span class="keyword">return</span> d == <span class="literal">nullptr</span> || d-&gt;strongref.<span class="built_in">load</span>() == <span class="number">0</span> || value == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>在介绍QWeakPointer的时候，有说到QObject对象在析构时，其内部的强引用计数会置0,见《<a class="link"   href="https://www.yuque.com/docs/share/b1a5924e-5d7c-49ce-bf47-2ff3d347d20b#" >智能指针-QWeakPointer<i class="fas fa-external-link-alt"></i></a>》,满足这里isNull为true的条件。</p>
<h1 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&amp;Status:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> label;</span><br><span class="line">label = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (label)</span><br><span class="line">	label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>如果使用QPointer可以这样使用，差别就在于delete label后，并不用将其置为nullptr.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPointer&lt;QLabel&gt; label = <span class="keyword">new</span> QLabel;</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&amp;Status:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> label;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (label)</span><br><span class="line">	label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<h1 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Copyright (C) 2016 The Qt Company Ltd.</span></span><br><span class="line"><span class="comment">** Contact: https://www.qt.io/licensing/</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** This file is part of the QtCore module of the Qt Toolkit.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_BEGIN_LICENSE:LGPL$</span></span><br><span class="line"><span class="comment">** Commercial License Usage</span></span><br><span class="line"><span class="comment">** Licensees holding valid commercial Qt licenses may use this file in</span></span><br><span class="line"><span class="comment">** accordance with the commercial license agreement provided with the</span></span><br><span class="line"><span class="comment">** Software or, alternatively, in accordance with the terms contained in</span></span><br><span class="line"><span class="comment">** a written agreement between you and The Qt Company. For licensing terms</span></span><br><span class="line"><span class="comment">** and conditions see https://www.qt.io/terms-conditions. For further</span></span><br><span class="line"><span class="comment">** information use the contact form at https://www.qt.io/contact-us.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** GNU Lesser General Public License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, this file may be used under the terms of the GNU Lesser</span></span><br><span class="line"><span class="comment">** General Public License version 3 as published by the Free Software</span></span><br><span class="line"><span class="comment">** Foundation and appearing in the file LICENSE.LGPL3 included in the</span></span><br><span class="line"><span class="comment">** packaging of this file. Please review the following information to</span></span><br><span class="line"><span class="comment">** ensure the GNU Lesser General Public License version 3 requirements</span></span><br><span class="line"><span class="comment">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** GNU General Public License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, this file may be used under the terms of the GNU</span></span><br><span class="line"><span class="comment">** General Public License version 2.0 or (at your option) the GNU General</span></span><br><span class="line"><span class="comment">** Public license version 3 or any later version approved by the KDE Free</span></span><br><span class="line"><span class="comment">** Qt Foundation. The licenses are as published by the Free Software</span></span><br><span class="line"><span class="comment">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</span></span><br><span class="line"><span class="comment">** included in the packaging of this file. Please review the following</span></span><br><span class="line"><span class="comment">** information to ensure the GNU General Public License requirements will</span></span><br><span class="line"><span class="comment">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</span></span><br><span class="line"><span class="comment">** https://www.gnu.org/licenses/gpl-3.0.html.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_END_LICENSE$</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QPOINTER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QPOINTER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/qsharedpointer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/qtypeinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QVariant</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Q_STATIC_ASSERT_X</span>(!std::is_pointer&lt;T&gt;::value, <span class="string">&quot;QPointer&#x27;s template type must not be a pointer type&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeSelector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> QObject Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeSelector</span>&lt;<span class="type">const</span> U&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> QObject Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> TypeSelector&lt;T&gt;::Type QObjectType;</span><br><span class="line">QWeakPointer&lt;QObjectType&gt; wp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QPointer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QPointer</span><span class="params">(T *p)</span> : wp(p, true) &#123;</span> &#125;</span><br><span class="line"><span class="comment">// compiler-generated copy/move ctor/assignment operators are fine!</span></span><br><span class="line"><span class="comment">// compiler-generated dtor is fine!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_QDOC</span></span><br><span class="line"><span class="comment">// Stop qdoc from complaining about missing function</span></span><br><span class="line">~<span class="built_in">QPointer</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(QPointer &amp;other)</span> </span>&#123; wp.<span class="built_in">swap</span>(other.wp); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> QPointer&lt;T&gt; &amp;<span class="keyword">operator</span>=(T* p)</span><br><span class="line">    &#123; wp.<span class="built_in">assign</span>(<span class="built_in">static_cast</span>&lt;QObjectType*&gt;(p)); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T* <span class="title">data</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;( wp.<span class="built_in">data</span>()); &#125;</span><br><span class="line">    <span class="keyword">inline</span> T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">data</span>(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> *<span class="built_in">data</span>(); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">data</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> wp.<span class="built_in">isNull</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; wp.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="built_in">Q_DECLARE_TYPEINFO_BODY</span>(QPointer&lt;T&gt;, Q_MOVABLE_TYPE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T *o, <span class="type">const</span> QPointer&lt;T&gt; &amp;p)</span><br><span class="line">    &#123; <span class="keyword">return</span> o == p.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QPointer&lt;T&gt; &amp;p, <span class="type">const</span> T *o)</span><br><span class="line">    &#123; <span class="keyword">return</span> p.<span class="keyword">operator</span>-&gt;() == o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(T *o, <span class="type">const</span> QPointer&lt;T&gt; &amp;p)</span><br><span class="line">    &#123; <span class="keyword">return</span> o == p.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QPointer&lt;T&gt; &amp;p, T *o)</span><br><span class="line">    &#123; <span class="keyword">return</span> p.<span class="keyword">operator</span>-&gt;() == o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QPointer&lt;T&gt; &amp;p1, <span class="type">const</span> QPointer&lt;T&gt; &amp;p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> p1.<span class="keyword">operator</span>-&gt;() == p2.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T *o, <span class="type">const</span> QPointer&lt;T&gt; &amp;p)</span><br><span class="line">    &#123; <span class="keyword">return</span> o != p.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> QPointer&lt;T&gt; &amp;p, <span class="type">const</span> T *o)</span><br><span class="line">    &#123; <span class="keyword">return</span> p.<span class="keyword">operator</span>-&gt;() != o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(T *o, <span class="type">const</span> QPointer&lt;T&gt; &amp;p)</span><br><span class="line">    &#123; <span class="keyword">return</span> o != p.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> QPointer&lt;T&gt; &amp;p, T *o)</span><br><span class="line">    &#123; <span class="keyword">return</span> p.<span class="keyword">operator</span>-&gt;() != o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> QPointer&lt;T&gt; &amp;p1, <span class="type">const</span> QPointer&lt;T&gt; &amp;p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> p1.<span class="keyword">operator</span>-&gt;() != p2.<span class="keyword">operator</span>-&gt;() ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    QPointer&lt;T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">qPointerFromVariant</span><span class="params">(<span class="type">const</span> QVariant &amp;variant)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QPointer</span>&lt;T&gt;(<span class="built_in">qobject_cast</span>&lt;T*&gt;(QtSharedPointer::<span class="built_in">weakPointerFromVariant_internal</span>(variant).<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">// QT_NO_QOBJECT</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">// QPOINTER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享交流之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://doc.qt.io/qt-6/qpointer.html" >QPointer Class<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针-QScopedPointer</title>
    <url>/2022/0743023.html</url>
    <content><![CDATA[<h1 id="QScopedPointer"><a href="#QScopedPointer" class="headerlink" title="QScopedPointer"></a>QScopedPointer</h1><p>Scope:范围&#x2F;作用域</p>
<p>明确两个概念：</p>
<p>1、智能指针不是指针</p>
<p>2、智能指针持有实际指针</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>这个指针的作用如名字一般，在作用域内使用的指针.在变量超出作用域范围时自动调用指针类型的析构函数进行销毁.（实际就是<strong>利用栈的特性去管理堆上的内存</strong>）</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cleanup = QScopedPointerDeleter&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> QScopedPointer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T *QScopedPointer:: *RestrictedBool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QScopedPointer</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> Q_DECL_NOTHROW : d(p)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    T *d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Q_DISABLE_COPY</span>(QScopedPointer)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造时传入T类型的指针p,并通过成员变量d进行保存(还是不由自主地感叹了下模板真好用^_^)</p>
<p>构造函数比较简单,按照其实现,用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QScopedPointer&lt;MyClass&gt; <span class="title">mc</span><span class="params">(<span class="keyword">new</span> MyClass)</span></span>;</span><br><span class="line"><span class="comment">// 和上面的用法相同</span></span><br><span class="line"><span class="function">QScopedPointer&lt;MyClass, QScopedPointerDeleter&gt; <span class="title">mc</span><span class="params">(<span class="keyword">new</span> MyClass)</span></span>;</span><br></pre></td></tr></table></figure>

<p>模板参数中的Cleanup默认使用的是QScopedPointerDeleter，即默认使用delete对指向的内存进行销毁。详见删除器小节。</p>
<p>如果仔细一些，会发现构造函数中有如下一行代码，并进行了实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> T *QScopedPointer:: *RestrictedBool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_QDOC)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNull</span>() ? <span class="literal">nullptr</span> : &amp;QScopedPointer::d;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">RestrictedBool</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNull</span>() ? <span class="literal">nullptr</span> : &amp;QScopedPointer::d;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里其实是对隐式转换做了限制，避免用指针做比较时，除了转换成bool类型不能转换其他的类型,例如下面的代码会在编译期就提示你有错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QScopedPointer&lt;Foo&gt; <span class="title">foo</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (foo &lt; i)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>以下用法是支持的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QScopedPointer&lt;Foo&gt; <span class="title">foo</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (foo)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在QScopedPointer超出作用域后，智能指针本身(<strong>分配在栈上</strong>)会自动销毁，触发析构函数。在析构函数中，提供了统一的<code>**清理**</code>函数<strong>Cleanup::cleanup(oldD)</strong>,对oldD(<strong>智能指针指向的内存</strong>)进行销毁.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ~<span class="built_in">QScopedPointer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T *oldD = <span class="keyword">this</span>-&gt;d;</span><br><span class="line">    Cleanup::<span class="built_in">cleanup</span>(oldD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Cleanup的介绍见下一小节.</p>
<h2 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h2><p>QScopedPointer不仅适用于通过new操作符分配的单个内存和一组内存(数组),也可用于通过malloc进行分配的内存。同时，针对QObject的deleteLater特性，也有相关处理。这里要说一下他的Cleanup删除器(非专有名词，只有我这样称呼)的概念。<br>Cleanup用于超出作用域时自动销毁指针指向的内存，针对不同方式分配的内存，提供了不同的销毁方式：</p>
<table>
<thead>
<tr>
<th><strong>删除器种类</strong></th>
<th><strong>如何销毁</strong></th>
<th><strong>销毁内存的分配方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>QScopedPointerDeleter</td>
<td>delete</td>
<td>使用new分配的内存</td>
</tr>
<tr>
<td>QScopedPointerArrayDeleter</td>
<td>delet[]</td>
<td>使用new []分配内存</td>
</tr>
<tr>
<td>QScopedPointerPodDeleter</td>
<td>free</td>
<td>内存由malloc进行分配</td>
</tr>
<tr>
<td>QScopedPointerObjectDeleteLater</td>
<td>delateLater</td>
<td>当你的指针为QObject类型时，并且处于一个QEventLoop中</td>
</tr>
</tbody></table>
<p>你也可以实现自己的删除器，它们需要具有公共静态函数 void cleanup(T *pointer).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this QScopedPointer deletes its data using the delete[] operator:</span></span><br><span class="line">QScopedPointer&lt;<span class="type">int</span>, QScopedPointerArrayDeleter&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">arrayPointer</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this QScopedPointer frees its data using free():</span></span><br><span class="line"><span class="function">QScopedPointer&lt;<span class="type">int</span>, QScopedPointerPodDeleter&gt; <span class="title">podPointer</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt;(malloc(<span class="number">42</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this struct calls &quot;myCustomDeallocator&quot; to delete the pointer</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScopedPointerCustomDeleter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">(MyCustomClass *pointer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">myCustomDeallocator</span>(pointer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QScopedPointer using a custom deleter:</span></span><br><span class="line"><span class="function">QScopedPointer&lt;MyCustomClass, ScopedPointerCustomDeleter&gt; <span class="title">customPointer</span><span class="params">(<span class="keyword">new</span> MyCustomClass)</span></span>;</span><br></pre></td></tr></table></figure>


<h2 id="方法一览"><a href="#方法一览" class="headerlink" title="方法一览"></a>方法一览</h2><table>
<thead>
<tr>
<th>原型</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td>QScopedPointer(T *p &#x3D; …)</td>
<td>Constructs this QScopedPointer instance and sets its pointer to p.</td>
</tr>
<tr>
<td>~QScopedPointer()</td>
<td>Destroys this QScopedPointer object. Delete the object its pointer points to.</td>
</tr>
<tr>
<td>T * data() const</td>
<td>Returns the value of the pointer referenced by this object. QScopedPointer still owns the object pointed to.</td>
</tr>
<tr>
<td>T * get() const</td>
<td>Same as data().</td>
</tr>
<tr>
<td>bool isNull() const</td>
<td>Returns true if this object is holding a pointer that is null.</td>
</tr>
<tr>
<td>void reset(T *other &#x3D; …)</td>
<td>Deletes the existing object it is pointing to (if any), and sets its pointer to other. QScopedPointer now owns other and will delete it in its destructor. To clear the pointer held without deleting the object it points to (and hence take ownership of the object), use take() instead.</td>
</tr>
<tr>
<td>void swap(QScopedPointer&lt;T, Cleanup&gt; &amp;other)</td>
<td>Swap this pointer with <em>other</em>.</td>
</tr>
<tr>
<td>T * take()</td>
<td>Returns the value of the pointer referenced by this object. The pointer of this QScopedPointer object will be reset to null. Callers of this function take ownership of the pointer.</td>
</tr>
<tr>
<td>bool operator bool() const</td>
<td>Returns true if this object is not null. This function is suitable for use in if-constructs, like:if (scopedPointer) {…} See also isNull().</td>
</tr>
<tr>
<td>bool operator!() const</td>
<td>Returns true if the pointer referenced by this object is null, otherwise returns false.See also isNull().</td>
</tr>
<tr>
<td>T &amp; operator*() const</td>
<td>Provides access to the scoped pointer’s object.If the contained pointer is null, behavior is undefined.See also isNull().</td>
</tr>
<tr>
<td>T * operator-&gt;() const</td>
<td>Provides access to the scoped pointer’s object.If the contained pointer is null, behavior is undefined.See also isNull().</td>
</tr>
</tbody></table>
<h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">bool</span> useSubClass)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      MyClass *p = useSubClass ? <span class="keyword">new</span> <span class="built_in">MyClass</span>() : <span class="keyword">new</span> MySubClass;</span><br><span class="line">      QIODevice *device = <span class="built_in">handsOverOwnership</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (m_value &gt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">delete</span> p;</span><br><span class="line">          <span class="keyword">delete</span> device;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">process</span>(device);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">          <span class="keyword">delete</span> p;</span><br><span class="line">          <span class="keyword">delete</span> device;</span><br><span class="line">          <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">      <span class="keyword">delete</span> device;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果使用QScopedPointer,可以极大地较少代码量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">bool</span> useSubClass)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// assuming that MyClass has a virtual destructor</span></span><br><span class="line">     <span class="function">QScopedPointer&lt;MyClass&gt; <span class="title">p</span><span class="params">(useSubClass ? <span class="keyword">new</span> MyClass() : <span class="keyword">new</span> MySubClass)</span></span>;</span><br><span class="line">     <span class="function">QScopedPointer&lt;QIODevice&gt; <span class="title">device</span><span class="params">(handsOverOwnership())</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (m_value &gt; <span class="number">3</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">process</span>(device);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>QScopedPointer intentionally has no copy constructor or assignment operator, such that ownership and lifetime is clearly communicated.<br>QScopedPointer故意去除了拷贝构造和赋值构造函数，因此指针不能被传递和复制，这样关于指针的所有权和生命周期就很明确(跟随智能指针的销毁而销毁).</p>
<p>如果你的指针需要用const限定符去修饰，使用QScopedPointer后也是支持的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> QWidget *<span class="type">const</span> p = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line"><span class="comment">// is equivalent to:</span></span><br><span class="line"><span class="function"><span class="type">const</span> QScopedPointer&lt;<span class="type">const</span> QWidget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> QWidget())</span></span>;</span><br><span class="line"></span><br><span class="line">QWidget *<span class="type">const</span> p = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line"><span class="comment">// is equivalent to:</span></span><br><span class="line"><span class="function"><span class="type">const</span> QScopedPointer&lt;QWidget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> QWidget())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> QWidget *p = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line"><span class="comment">// is equivalent to:</span></span><br><span class="line"><span class="function">QScopedPointer&lt;<span class="type">const</span> QWidget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> QWidget())</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="QScopedArrayPointer"><a href="#QScopedArrayPointer" class="headerlink" title="QScopedArrayPointer"></a>QScopedArrayPointer</h2><p>和QScopedPointer不同的是，他的删除器默认是QScopedPointerArrayDeleter，其他都差不多，我们了解即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cleanup = QScopedPointerArrayDeleter&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> QScopedArrayPointer : <span class="keyword">public</span> QScopedPointer&lt;T, Cleanup&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line">    <span class="keyword">using</span> if_same_type = <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;<span class="keyword">typename</span> std::remove_cv&lt;T&gt;::type, Ptr&gt;::value, <span class="type">bool</span>&gt;::type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QScopedArrayPointer</span><span class="params">()</span> : QScopedPointer&lt;T, Cleanup&gt;(nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, if_same_type&lt;D&gt; = <span class="literal">true</span>&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">QScopedArrayPointer</span>(D *p)</span><br><span class="line">        : <span class="built_in">QScopedPointer</span>&lt;T, Cleanup&gt;(p)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Copyright (C) 2016 The Qt Company Ltd.</span></span><br><span class="line"><span class="comment">** Contact: https://www.qt.io/licensing/</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** This file is part of the QtCore module of the Qt Toolkit.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_BEGIN_LICENSE:LGPL$</span></span><br><span class="line"><span class="comment">** Commercial License Usage</span></span><br><span class="line"><span class="comment">** Licensees holding valid commercial Qt licenses may use this file in</span></span><br><span class="line"><span class="comment">** accordance with the commercial license agreement provided with the</span></span><br><span class="line"><span class="comment">** Software or, alternatively, in accordance with the terms contained in</span></span><br><span class="line"><span class="comment">** a written agreement between you and The Qt Company. For licensing terms</span></span><br><span class="line"><span class="comment">** and conditions see https://www.qt.io/terms-conditions. For further</span></span><br><span class="line"><span class="comment">** information use the contact form at https://www.qt.io/contact-us.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** GNU Lesser General Public License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, this file may be used under the terms of the GNU Lesser</span></span><br><span class="line"><span class="comment">** General Public License version 3 as published by the Free Software</span></span><br><span class="line"><span class="comment">** Foundation and appearing in the file LICENSE.LGPL3 included in the</span></span><br><span class="line"><span class="comment">** packaging of this file. Please review the following information to</span></span><br><span class="line"><span class="comment">** ensure the GNU Lesser General Public License version 3 requirements</span></span><br><span class="line"><span class="comment">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** GNU General Public License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, this file may be used under the terms of the GNU</span></span><br><span class="line"><span class="comment">** General Public License version 2.0 or (at your option) the GNU General</span></span><br><span class="line"><span class="comment">** Public license version 3 or any later version approved by the KDE Free</span></span><br><span class="line"><span class="comment">** Qt Foundation. The licenses are as published by the Free Software</span></span><br><span class="line"><span class="comment">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</span></span><br><span class="line"><span class="comment">** included in the packaging of this file. Please review the following</span></span><br><span class="line"><span class="comment">** information to ensure the GNU General Public License requirements will</span></span><br><span class="line"><span class="comment">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</span></span><br><span class="line"><span class="comment">** https://www.gnu.org/licenses/gpl-3.0.html.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_END_LICENSE$</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QSCOPEDPOINTER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QSCOPEDPOINTER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/qglobal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QScopedPointerDeleter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">(T *pointer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Enforce a complete type.</span></span><br><span class="line">            <span class="comment">// If you get a compile error here, read the section on forward declared</span></span><br><span class="line">            <span class="comment">// classes in the QScopedPointer documentation.</span></span><br><span class="line">            <span class="keyword">typedef</span> <span class="type">char</span> IsIncompleteType[ <span class="built_in">sizeof</span>(T) ? <span class="number">1</span> : <span class="number">-1</span> ];</span><br><span class="line">            (<span class="type">void</span>) <span class="built_in">sizeof</span>(IsIncompleteType);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">delete</span> pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QScopedPointerArrayDeleter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">(T *pointer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Enforce a complete type.</span></span><br><span class="line">        <span class="comment">// If you get a compile error here, read the section on forward declared</span></span><br><span class="line">        <span class="comment">// classes in the QScopedPointer documentation.</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">char</span> IsIncompleteType[ <span class="built_in">sizeof</span>(T) ? <span class="number">1</span> : <span class="number">-1</span> ];</span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">sizeof</span>(IsIncompleteType);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> [] pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QScopedPointerPodDeleter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">(<span class="type">void</span> *pointer)</span> </span>&#123; <span class="keyword">if</span> (pointer) <span class="built_in">free</span>(pointer); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QScopedPointerObjectDeleteLater</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">(T *pointer)</span> </span>&#123; <span class="keyword">if</span> (pointer) pointer-&gt;<span class="built_in">deleteLater</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QObject</span>;</span><br><span class="line"><span class="keyword">typedef</span> QScopedPointerObjectDeleteLater&lt;QObject&gt; QScopedPointerDeleteLater;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cleanup = QScopedPointerDeleter&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> QScopedPointer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T *QScopedPointer:: *RestrictedBool;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QScopedPointer</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> Q_DECL_NOTHROW : d(p)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> ~<span class="built_in">QScopedPointer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        T *oldD = <span class="keyword">this</span>-&gt;d;</span><br><span class="line">        Cleanup::<span class="built_in">cleanup</span>(oldD);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> T &amp;<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Q_ASSERT</span>(d);</span><br><span class="line">        <span class="keyword">return</span> *d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(Q_QDOC)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNull</span>() ? <span class="literal">nullptr</span> : &amp;QScopedPointer::d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">RestrictedBool</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNull</span>() ? <span class="literal">nullptr</span> : &amp;QScopedPointer::d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function">T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *other = <span class="literal">nullptr</span>)</span> <span class="title">Q_DECL_NOEXCEPT_EXPR</span><span class="params">(<span class="keyword">noexcept</span>(Cleanup::cleanup(std::declval&lt;T *&gt;())))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == other)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        T *oldD = d;</span><br><span class="line">        d = other;</span><br><span class="line">        Cleanup::<span class="built_in">cleanup</span>(oldD);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T *<span class="title">take</span><span class="params">()</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *oldD = d;</span><br><span class="line">        d = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> oldD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QScopedPointer&lt;T, Cleanup&gt; &amp;other)</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qSwap</span>(d, other.d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> T *pointer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    T *d;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Q_DISABLE_COPY</span>(QScopedPointer)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;lhs, <span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;rhs) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.<span class="built_in">data</span>() == rhs.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;lhs, <span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;rhs) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.<span class="built_in">data</span>() != rhs.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;lhs, std::<span class="type">nullptr_t</span>) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.<span class="built_in">isNull</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(std::<span class="type">nullptr_t</span>, <span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;rhs) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rhs.<span class="built_in">isNull</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;lhs, std::<span class="type">nullptr_t</span>) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !lhs.<span class="built_in">isNull</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(std::<span class="type">nullptr_t</span>, <span class="type">const</span> QScopedPointer&lt;T, Cleanup&gt; &amp;rhs) Q_DECL_NOTHROW</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !rhs.<span class="built_in">isNull</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Cleanup</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(QScopedPointer&lt;T, Cleanup&gt; &amp;p1, QScopedPointer&lt;T, Cleanup&gt; &amp;p2)</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function"></span>&#123; p1.<span class="built_in">swap</span>(p2); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cleanup = QScopedPointerArrayDeleter&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> QScopedArrayPointer : <span class="keyword">public</span> QScopedPointer&lt;T, Cleanup&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">using</span> if_same_type = <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;<span class="keyword">typename</span> std::remove_cv&lt;T&gt;::type, Ptr&gt;::value, <span class="type">bool</span>&gt;::type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QScopedArrayPointer</span><span class="params">()</span> : QScopedPointer&lt;T, Cleanup&gt;(nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, if_same_type&lt;D&gt; = <span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">QScopedArrayPointer</span>(D *p)</span><br><span class="line">: <span class="built_in">QScopedPointer</span>&lt;T, Cleanup&gt;(p)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> T &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QScopedArrayPointer &amp;other)</span> Q_DECL_NOTHROW <span class="comment">// prevent QScopedPointer &lt;-&gt;QScopedArrayPointer swaps</span></span></span><br><span class="line"><span class="function"></span>&#123; QScopedPointer&lt;T, Cleanup&gt;::<span class="built_in">swap</span>(other); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">inline</span> <span class="title">QScopedArrayPointer</span><span class="params">(<span class="type">void</span> *)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Enforce the same type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If you get a compile error here, make sure you declare</span></span><br><span class="line"><span class="comment">// QScopedArrayPointer with the same template type as you pass to the</span></span><br><span class="line"><span class="comment">// constructor. See also the QScopedPointer documentation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Storing a scalar array as a pointer to a different type is not</span></span><br><span class="line"><span class="comment">// allowed and results in undefined behavior.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DISABLE_COPY</span>(QScopedArrayPointer)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cleanup&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(QScopedArrayPointer&lt;T, Cleanup&gt; &amp;lhs, QScopedArrayPointer&lt;T, Cleanup&gt; &amp;rhs)</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function"></span>&#123; lhs.<span class="built_in">swap</span>(rhs); &#125;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QSCOPEDPOINTER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://doc.qt.io/qt-6/qscopedpointer.html" >QScopedPointer Class<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针-QWeakPointer</title>
    <url>/2022/0926779.html</url>
    <content><![CDATA[<h1 id="QWeakPointer"><a href="#QWeakPointer" class="headerlink" title="QWeakPointer"></a>QWeakPointer</h1><p>先介绍QWeakPointer，是因为QPointer和QSharedPointer的实现都依赖于QWeakPointer</p>
<span id="more"></span>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>1、为QPointer和QSharedPointer提供了弱引用计数的功能.</strong><br><strong>2、解除循环引用</strong></p>
<p>QWeakPointer 类持有对共享指针的弱引用。<br>QWeakPointer 是对 C++ 中指针的自动弱引用。<strong>它不能用于直接取消引用指针，但可以用于验证指针是否已在另一个上下文中被删除</strong>。<br>QWeakPointer 对象<strong>只能通过 QSharedPointer 的赋值来创建</strong>(因为没有重载operator*和-&gt;)。<br>需要注意的是，QWeakPointer 没有提供自动转换操作符来防止错误发生。即使 QWeakPointer 跟踪一个指针，它本身也不应该被认为是一个指针，因为它不能保证指向的对象保持有效。<br>因此，要访问 QWeakPointer 正在跟踪的指针，您必须首先将其提升为 QSharedPointer 并验证结果对象是否为空。 QSharedPointer 保证对象不被删除，所以如果你得到一个非空对象，你可以使用指针。有关示例，请参见 QWeakPointer::toStrongRef()。<br>QWeakPointer 还提供了 QWeakPointer::data() 方法，该方法返回跟踪的指针而不确保它保持有效。如果您可以通过外部方式保证对象不会被删除（或者如果您只需要指针值）那你就可以使用它。友情提示：使用 toStrongRef() 创建 QSharedPointer 的成本较高。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>观察QWeakPointer的构造函数部分，处于public部分的构造函数有如下几个，可以看出都是不允许带参构造或者参数并不是我们期望的指针类型.(所以，QWeakPointer从设计上就不是直接提供给我们使用的)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">()</span> Q_DECL_NOTHROW : d(nullptr), value(nullptr) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造,弱引用计数+1</span></span><br><span class="line"><span class="built_in">QWeakPointer</span>(<span class="type">const</span> QWeakPointer &amp;other) Q_DECL_NOTHROW : <span class="built_in">d</span>(other.d), <span class="built_in">value</span>(other.value)</span><br><span class="line">    &#123; <span class="keyword">if</span> (d) d-&gt;weakref.<span class="built_in">ref</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造,弱引用计数+1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QSharedPointer&lt;T&gt; &amp;o)</span> : d(o.d), value(o.data())</span></span><br><span class="line"><span class="function">    &#123;</span> <span class="keyword">if</span> (d) d-&gt;weakref.<span class="built_in">ref</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QWeakPointer&lt;X&gt; &amp;o)</span> : d(nullptr), value(nullptr)</span></span><br><span class="line"><span class="function">    &#123;</span> *<span class="keyword">this</span> = o; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QSharedPointer&lt;X&gt; &amp;o)</span> : d(nullptr), value(nullptr)</span></span><br><span class="line"><span class="function">    &#123;</span> *<span class="keyword">this</span> = o; &#125;</span><br></pre></td></tr></table></figure>

<p>唯一的可用的构造函数处于private部分，好处是这里添加了两个友元类型QPointer和QSharedPointer，关于友元我们应该不用多做介绍(我是你的朋友，你的就是我的，但你不是我的朋友，所以我的还是我的^_^)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_NO_TEMPLATE_FRIENDS)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">QSharedPointer</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">QPointer</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QWeakPointer &amp;<span class="title">assign</span><span class="params">(X *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = <span class="built_in">QWeakPointer</span>&lt;X&gt;(ptr, <span class="literal">true</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(X *ptr, <span class="type">bool</span>)</span> : d(ptr ? Data::getAndRef(ptr) : nullptr), value(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">internalSet</span><span class="params">(Data *o, T *actual)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == o) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o)</span><br><span class="line">            o-&gt;weakref.<span class="built_in">ref</span>();</span><br><span class="line">        <span class="keyword">if</span> (d &amp;&amp; !d-&gt;weakref.<span class="built_in">deref</span>())</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">        d = o;</span><br><span class="line">        value = actual;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯二的成员变量</span></span><br><span class="line">    Data *d;</span><br><span class="line">    T *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>QWeakPointer的数据成员只有两个，分别用于在私有构造函数中，ptr为模板参数类型的指针，d&#x3D;ptr ? Data::getAndRef(ptr) : nullptr;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> QtSharedPointer::ExternalRefCountData Data;</span><br></pre></td></tr></table></figure>

<p>看下ExternalRefCountData的定义，从名字大概看出来这是一个关于引用计数的结构，用于保存引用计数相关的数据。<br>注意下这里的weakref和strongref都是QBasicAtomicInt类型的，关于<strong>QAtom系列</strong>的几个类，有时间会单独列一章。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">ExternalRefCountData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DestroyerFn)</span><span class="params">(ExternalRefCountData *)</span></span>;</span><br><span class="line">        QBasicAtomicInt weakref;</span><br><span class="line">        QBasicAtomicInt strongref;</span><br><span class="line">        DestroyerFn destroyer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="title">ExternalRefCountData</span><span class="params">(DestroyerFn d)</span></span></span><br><span class="line"><span class="function">            : destroyer(d)</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">            strongref.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">            weakref.<span class="built_in">store</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="title">ExternalRefCountData</span><span class="params">(Qt::Initialization)</span> </span>&#123; &#125;</span><br><span class="line">        ~<span class="built_in">ExternalRefCountData</span>() &#123; <span class="built_in">Q_ASSERT</span>(!weakref.<span class="built_in">load</span>()); <span class="built_in">Q_ASSERT</span>(strongref.<span class="built_in">load</span>() &lt;= <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; <span class="built_in">destroyer</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">static</span> ExternalRefCountData *<span class="title">getAndRef</span><span class="params">(<span class="type">const</span> QObject *)</span></span>;</span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">void</span> <span class="title">setQObjectShared</span><span class="params">(<span class="type">const</span> QObject *, <span class="type">bool</span> enable)</span></span>;</span><br><span class="line">        <span class="function">Q_CORE_EXPORT <span class="type">void</span> <span class="title">checkQObjectShared</span><span class="params">(<span class="type">const</span> QObject *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">checkQObjectShared</span><span class="params">(...)</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setQObjectShared</span><span class="params">(...)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">void</span> *)</span> </span>&#123; &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>QWeakPointer的带参构造函数是私有的，引用计数结构体使用getAndRef方法获取，value保存ptr。getAndRef只接受QObject*作为参数，因此就限制了QWeakPointer私有构造时，传入的指针类型必须为QObject.<br>从下面的代码我们不难发现QObjectPrivate中保存了一个ExternalRefCountData的指针，此指针存在时，引用计数+1。不存在时，创建一个新的指针，并赋值引用计数(强引用为-1,弱引用为2,这个数字回头再说)后，返回此指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QtSharedPointer::ExternalRefCountData *QtSharedPointer::ExternalRefCountData::<span class="built_in">getAndRef</span>(<span class="type">const</span> QObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(obj);</span><br><span class="line">    QObjectPrivate *d = QObjectPrivate::<span class="built_in">get</span>(<span class="built_in">const_cast</span>&lt;QObject *&gt;(obj));</span><br><span class="line">    <span class="built_in">Q_ASSERT_X</span>(!d-&gt;wasDeleted, <span class="string">&quot;QWeakPointer&quot;</span>, <span class="string">&quot;Detected QWeakPointer creation in a QObject being deleted&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ExternalRefCountData *that = d-&gt;sharedRefcount.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">if</span> (that) &#123;</span><br><span class="line">        that-&gt;weakref.<span class="built_in">ref</span>();</span><br><span class="line">        <span class="keyword">return</span> that;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can create the refcount data because it doesn&#x27;t exist</span></span><br><span class="line">    ExternalRefCountData *x = <span class="keyword">new</span> <span class="built_in">ExternalRefCountData</span>(Qt::Uninitialized);</span><br><span class="line">    x-&gt;strongref.<span class="built_in">store</span>(<span class="number">-1</span>);</span><br><span class="line">    x-&gt;weakref.<span class="built_in">store</span>(<span class="number">2</span>);  <span class="comment">// the QWeakPointer that called us plus the QObject itself</span></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;sharedRefcount.<span class="built_in">testAndSetRelease</span>(<span class="number">0</span>, x)) &#123;</span><br><span class="line">        <span class="comment">// ~ExternalRefCountData has a Q_ASSERT, so we use this trick to</span></span><br><span class="line">        <span class="comment">// only execute this if Q_ASSERTs are enabled</span></span><br><span class="line">        <span class="built_in">Q_ASSERT</span>((x-&gt;weakref.<span class="built_in">store</span>(<span class="number">0</span>), <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">delete</span> x;</span><br><span class="line">        x = d-&gt;sharedRefcount.<span class="built_in">loadAcquire</span>();</span><br><span class="line">        x-&gt;weakref.<span class="built_in">ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们看一下QObject析构时候的处理，强引用计数置0，弱引用计数-1，如果减为0则delete掉ExternalRefCountData</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QObject::~<span class="built_in">QObject</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QObject);</span><br><span class="line">    d-&gt;wasDeleted = <span class="literal">true</span>;</span><br><span class="line">    d-&gt;blockSig = <span class="number">0</span>; <span class="comment">// unblock signals so we always emit destroyed()</span></span><br><span class="line"></span><br><span class="line">    QtSharedPointer::ExternalRefCountData *sharedRefcount = d-&gt;sharedRefcount.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">if</span> (sharedRefcount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedRefcount-&gt;strongref.<span class="built_in">load</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">qWarning</span>(<span class="string">&quot;QObject: shared QObject was deleted directly. The program is malformed and may crash.&quot;</span>);</span><br><span class="line">            <span class="comment">// but continue deleting, it&#x27;s too late to stop anyway</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// indicate to all QWeakPointers that this QObject has now been deleted</span></span><br><span class="line">        sharedRefcount-&gt;strongref.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!sharedRefcount-&gt;weakref.<span class="built_in">deref</span>())</span><br><span class="line">            <span class="keyword">delete</span> sharedRefcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>弱引用计数-1，如果减为0则delete掉d ，但是不会delete掉value</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ~<span class="built_in">QWeakPointer</span>() &#123; <span class="keyword">if</span> (d &amp;&amp; !d-&gt;weakref.<span class="built_in">deref</span>()) <span class="keyword">delete</span> d; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解除循环引用"><a href="#解除循环引用" class="headerlink" title="解除循环引用"></a>解除循环引用</h2><p>下面的例子，按照我们对智能指针的理解，在运行后Parent和Children指针均应被释放，但实际结果会告诉我们并没有</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScopedPointer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __FUNCTION__ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QSharedPointer&lt;Children&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Children</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Children</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __FUNCTION__ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QSharedPointer&lt;Parent&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个作用域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QSharedPointer&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent())</span></span>;</span><br><span class="line">        <span class="function">QSharedPointer&lt;Children&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Children())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; c)&#123;</span><br><span class="line">            p-&gt;ptr = c;</span><br><span class="line">            c-&gt;ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出了作用域，此时指针内容销毁，猜想一下输出内容是什么</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对上面的代码稍作改动，将Parent和Children中的成员变量指针改成QWeakPointer，此时Parent和Children均被析构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScopedPointer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __FUNCTION__ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将QSharedPointer改为QWeakPointer</span></span><br><span class="line">    QWeakPointer&lt;Children&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Children</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Children</span>() &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __FUNCTION__ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将QSharedPointer改为QWeakPointer</span></span><br><span class="line">    QWeakPointer&lt;Parent&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个作用域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QSharedPointer&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent())</span></span>;</span><br><span class="line">        <span class="function">QSharedPointer&lt;Children&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Children())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; c)&#123;</span><br><span class="line">            p-&gt;ptr = c;</span><br><span class="line">            c-&gt;ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再猜测一下输出内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个对象互相使用一个 QSharedPointer成员变量指向对方（你中有我，我中有你）。由于QSharedPointer是一个强引用的计数型指针，只有当引用数为0时，就会自动删除指针释放内存，但是如果循环引用，就会导致QSharedPointer指针的引用永远都不能为0，这时候就会导致内存无法释放。<br>所以QWeakPointer诞生了，它就是为了打破这种循环的。并且，在需要的时候变成QSharedPointer，在其他时候不干扰QSharedPointer的引用计数。它没有重载 * 和 -&gt; 运算符，因此不可以直接通过 QWeakPointer 访问对象，典型的用法是通过 lock() 成员函数来获得 QSharedPointer，进而使用对象。</p>
<h2 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWeakPointer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T *QWeakPointer:: *RestrictedBool;</span><br><span class="line">    <span class="keyword">typedef</span> QtSharedPointer::ExternalRefCountData Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type *const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type &amp;reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type &amp;const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> qptrdiff difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW </span>&#123; <span class="keyword">return</span> d == <span class="literal">nullptr</span> || d-&gt;strongref.<span class="built_in">load</span>() == <span class="number">0</span> || value == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">RestrictedBool</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW </span>&#123; <span class="keyword">return</span> <span class="built_in">isNull</span>() ? <span class="literal">nullptr</span> : &amp;QWeakPointer::value; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> !() <span class="type">const</span> Q_DECL_NOTHROW &#123; <span class="keyword">return</span> <span class="built_in">isNull</span>(); &#125;</span><br><span class="line">    <span class="function">T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> Q_DECL_NOTHROW </span>&#123; <span class="keyword">return</span> d == <span class="literal">nullptr</span> || d-&gt;strongref.<span class="built_in">load</span>() == <span class="number">0</span> ? <span class="literal">nullptr</span> : value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">()</span> Q_DECL_NOTHROW : d(nullptr), value(nullptr) &#123;</span> &#125;</span><br><span class="line">    <span class="keyword">inline</span> ~<span class="built_in">QWeakPointer</span>() &#123; <span class="keyword">if</span> (d &amp;&amp; !d-&gt;weakref.<span class="built_in">deref</span>()) <span class="keyword">delete</span> d; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">    <span class="comment">// special constructor that is enabled only if X derives from QObject</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_DEPRECATED_SINCE(5, 0)</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function">QT_DEPRECATED <span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(X *ptr)</span> : d(ptr ? Data::getAndRef(ptr) : nullptr), value(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_DEPRECATED_SINCE(5, 0)</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    QT_DEPRECATED <span class="keyword">inline</span> QWeakPointer &amp;<span class="keyword">operator</span>=(X *ptr)</span><br><span class="line">    &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = <span class="built_in">QWeakPointer</span>(ptr); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">QWeakPointer</span>(<span class="type">const</span> QWeakPointer &amp;other) Q_DECL_NOTHROW : <span class="built_in">d</span>(other.d), <span class="built_in">value</span>(other.value)</span><br><span class="line">    &#123; <span class="keyword">if</span> (d) d-&gt;weakref.<span class="built_in">ref</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_COMPILER_RVALUE_REFS</span></span><br><span class="line">    <span class="built_in">QWeakPointer</span>(QWeakPointer &amp;&amp;other) Q_DECL_NOTHROW</span><br><span class="line">        : <span class="built_in">d</span>(other.d), <span class="built_in">value</span>(other.value)</span><br><span class="line">    &#123;</span><br><span class="line">        other.d = <span class="literal">nullptr</span>;</span><br><span class="line">        other.value = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QWeakPointer &amp;<span class="keyword">operator</span>=(QWeakPointer &amp;&amp;other) Q_DECL_NOTHROW</span><br><span class="line">    &#123; QWeakPointer <span class="built_in">moved</span>(std::<span class="built_in">move</span>(other)); <span class="built_in">swap</span>(moved); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    QWeakPointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> QWeakPointer &amp;other) Q_DECL_NOTHROW</span><br><span class="line">    &#123;</span><br><span class="line">        QWeakPointer <span class="built_in">copy</span>(other);</span><br><span class="line">        <span class="built_in">swap</span>(copy);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QWeakPointer &amp;other)</span> Q_DECL_NOTHROW</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qSwap</span>(<span class="keyword">this</span>-&gt;d, other.d);</span><br><span class="line">        <span class="built_in">qSwap</span>(<span class="keyword">this</span>-&gt;value, other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QSharedPointer&lt;T&gt; &amp;o)</span> : d(o.d), value(o.data())</span></span><br><span class="line"><span class="function">    &#123;</span> <span class="keyword">if</span> (d) d-&gt;weakref.<span class="built_in">ref</span>();&#125;</span><br><span class="line">    <span class="keyword">inline</span> QWeakPointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> QSharedPointer&lt;T&gt; &amp;o)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">internalSet</span>(o.d, o.value);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QWeakPointer&lt;X&gt; &amp;o)</span> : d(nullptr), value(nullptr)</span></span><br><span class="line"><span class="function">    &#123;</span> *<span class="keyword">this</span> = o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> QWeakPointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> QWeakPointer&lt;X&gt; &amp;o)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// conversion between X and T could require access to the virtual table</span></span><br><span class="line">        <span class="comment">// so force the operation to go through QSharedPointer</span></span><br><span class="line">        *<span class="keyword">this</span> = o.<span class="built_in">toStrongRef</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QWeakPointer&lt;X&gt; &amp;o) <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123; <span class="keyword">return</span> d == o.d &amp;&amp; value == <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T *&gt;(o.value); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QWeakPointer&lt;X&gt; &amp;o) <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(<span class="type">const</span> QSharedPointer&lt;X&gt; &amp;o)</span> : d(nullptr), value(nullptr)</span></span><br><span class="line"><span class="function">    &#123;</span> *<span class="keyword">this</span> = o; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> QWeakPointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> QSharedPointer&lt;X&gt; &amp;o)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">QSHAREDPOINTER_VERIFY_AUTO_CAST</span>(T, X); <span class="comment">// if you get an error in this line, the cast is invalid</span></span><br><span class="line">        <span class="built_in">internalSet</span>(o.d, o.<span class="built_in">data</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QSharedPointer&lt;X&gt; &amp;o) <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123; <span class="keyword">return</span> d == o.d; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QSharedPointer&lt;X&gt; &amp;o) <span class="type">const</span> Q_DECL_NOTHROW</span><br><span class="line">    &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; *<span class="keyword">this</span> = <span class="built_in">QWeakPointer</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QSharedPointer&lt;T&gt; <span class="title">toStrongRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">QSharedPointer</span>&lt;T&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// std::weak_ptr compatibility:</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QSharedPointer&lt;T&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">toStrongRef</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(QWEAKPOINTER_ENABLE_ARROW)</span></span><br><span class="line">    <span class="keyword">inline</span> T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">data</span>(); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_NO_TEMPLATE_FRIENDS)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">QSharedPointer</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">QPointer</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QWeakPointer &amp;<span class="title">assign</span><span class="params">(X *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = <span class="built_in">QWeakPointer</span>&lt;X&gt;(ptr, <span class="literal">true</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_QOBJECT</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">QWeakPointer</span><span class="params">(X *ptr, <span class="type">bool</span>)</span> : d(ptr ? Data::getAndRef(ptr) : nullptr), value(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">internalSet</span><span class="params">(Data *o, T *actual)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == o) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o)</span><br><span class="line">            o-&gt;weakref.<span class="built_in">ref</span>();</span><br><span class="line">        <span class="keyword">if</span> (d &amp;&amp; !d-&gt;weakref.<span class="built_in">deref</span>())</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">        d = o;</span><br><span class="line">        value = actual;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data *d;</span><br><span class="line">    T *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://blog.csdn.net/GG_SiMiDa/article/details/78667416" >Qt–智能指针<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/luoyayun361/article/details/90286005" >Qt智能指针–QWeakPointer<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://doc.qt.io/qt-6/qweakpointer.html" >QWeakPointer Class<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针简介</title>
    <url>/2022/0729301.html</url>
    <content><![CDATA[<p>C++不像Java那样拥有垃圾自动回收机制，需要程序员手动分配和销毁对应内存，这其实是一种更加高效且灵活的方式，但同时也可能受限于人为的操作，导致内存泄露等风险。</p>
<p>C++程序员通常采用<strong>RAII</strong>(Resource Acquisition Is Initialization)机制来管理内存资源：在类的构造函数中申请资源，在析构函数中释放资源。我们必须保证malloc分配的内存最终能被free，new创建的对象能在正确的时机被delete，并且时刻警惕使用野指针导致的崩溃。相信所有C&#x2F;C++的coder都被内存泄漏和野指针崩溃问题折磨过。</p>
<p>Qt中提供了QPointer、QScopedPointer、QSharedPointer、QWeakPointer等几种基本智能指针帮助我们规避内存泄漏和野指针的问题。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>段页式内存管理</title>
    <url>/2024/07eadf9fd1.html</url>
    <content><![CDATA[<p>段页式内存管理是一种结合了分段和分页两种内存管理技术的机制，它旨在充分利用这两者的优点，减少它们各自的缺点。这种混合策略广泛应用于现代操作系统中，以实现灵活高效的内存管理。</p>
<span id="more"></span>
<h2 id="段页式内存管理的基本概念"><a href="#段页式内存管理的基本概念" class="headerlink" title="段页式内存管理的基本概念"></a>段页式内存管理的基本概念</h2><h3 id="段（Segment）"><a href="#段（Segment）" class="headerlink" title="段（Segment）"></a>段（Segment）</h3><ul>
<li><strong>分段</strong>：内存被划分为不同的段，每个段代表一个逻辑单位，比如代码段、数据段、堆栈段等。每个段有一个段基址和段长度。</li>
<li><strong>段表（Segment Table）</strong>：操作系统为每个进程维护一个段表，段表条目包含段基址和段长度，用于将逻辑地址转换为段内的偏移地址。</li>
</ul>
<h3 id="页（Page）"><a href="#页（Page）" class="headerlink" title="页（Page）"></a>页（Page）</h3><ul>
<li><strong>分页</strong>：每个段进一步划分为固定大小的页，内存被划分成大小相等的页框（Page Frame）。</li>
<li><strong>页表（Page Table）</strong>：每个段对应一个页表，页表条目包含页框号，用于将段内的偏移地址转换为物理地址。</li>
</ul>
<h2 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h2><p>段页式内存管理将逻辑地址转换为物理地址的过程涉及两个步骤：</p>
<ol>
<li><strong>段选择</strong>：首先根据段号查找段表，获取段基址和段长度。如果逻辑地址中的偏移量超过了段长度，触发段错误（Segment Fault）。</li>
<li><strong>页选择</strong>：其次在段内进行分页，根据段内的页号查找页表，获取对应的页框号，将页内偏移量加到页框基址上，形成最终的物理地址。</li>
</ol>
<p>具体步骤如下：</p>
<ul>
<li><strong>逻辑地址（段号：段内偏移）</strong>：逻辑地址由段号（Segment Number）和段内偏移（Offset within Segment）组成。</li>
<li><strong>段表查找</strong>：使用段号在段表中查找，获取段基址和段长度。</li>
<li><strong>页表查找</strong>：将段内偏移分为页号（Page Number）和页内偏移（Offset within Page），使用页号在页表中查找，获取页框号。</li>
<li><strong>物理地址计算</strong>：将页框号和页内偏移组合，形成最终的物理地址。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><strong>灵活性</strong>：结合了分段和分页的优点，既支持逻辑分段，又能够有效利用内存碎片。</li>
<li><strong>保护和共享</strong>：通过段表和页表的多级映射，可以实现内存保护和进程间的内存共享。</li>
<li><strong>减少外部碎片</strong>：分页的引入减少了分段带来的外部碎片问题。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设一个逻辑地址由段号、页号和页内偏移组成，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">逻辑地址格式： 段号（S） 页号（P） 页内偏移（D）</span><br></pre></td></tr></table></figure>
<p>具体转换过程如下：</p>
<ol>
<li>使用段号S在段表中查找，得到段基址和段长度。</li>
<li>将逻辑地址中的页号P和页内偏移D分离，计算段内偏移。</li>
<li>使用页号P在对应段的页表中查找，得到页框号。</li>
<li>将页框号和页内偏移D组合，形成物理地址。</li>
</ol>
<h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h3><p>假设段表和页表如下：<br />段表：</p>
<table>
<thead>
<tr>
<th>段号</th>
<th>段基址</th>
<th>段长度</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1000</td>
<td>400</td>
</tr>
<tr>
<td>1</td>
<td>2000</td>
<td>800</td>
</tr>
</tbody></table>
<p>页表（段0）：</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页框号</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>8</td>
</tr>
</tbody></table>
<p>页表（段1）：</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页框号</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>假设逻辑地址为：(1, 1, 50) ，表示段1，页1，页内偏移50：</p>
<ol>
<li>在段表中查找段1，得到段基址2000。</li>
<li>使用页号1在段1的页表中查找，得到页框号10。</li>
<li>将页框号10转换为物理地址，假设每页大小为100：<ul>
<li>物理地址 &#x3D; 页框号 * 页大小 + 页内偏移</li>
<li>物理地址 &#x3D; 10 * 100 + 50 &#x3D; 1050</li>
</ul>
</li>
</ol>
<p>最终物理地址为1050。</p>
<h2 id="段页式内存管理的应用"><a href="#段页式内存管理的应用" class="headerlink" title="段页式内存管理的应用"></a>段页式内存管理的应用</h2><p>段页式内存管理广泛应用于现代操作系统，如Windows和Unix&#x2F;Linux，这些系统通过段页式内存管理实现内存保护、多任务处理和虚拟内存管理。通过段页式管理，操作系统可以灵活地分配和管理内存，提高系统的可靠性和效率。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量</title>
    <url>/2022/1131372.html</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/images/env/image.png"
                        alt="image.png"
                 ></p>
<p>在 Linux 系统中，环境变量用于定义系统运行环境的一些参数。例如，家目录的位置一般存放在 <code>HOME</code> 环境变量中，可以通过执行 <code>echo $HOME</code> 命令来查看。</p>
<h1 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h1><p>我们可以使用 <code>env</code> 命令来查看 Linux 系统中所有的环境变量。执行该命令的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[11:01:53] uos :: uos-PC  ➜  ~ » <span class="built_in">env</span></span><br><span class="line">CLUTTER_IM_MODULE=fcitx</span><br><span class="line">COLORTERM=truecolor</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus</span><br><span class="line">DESKTOP_SESSION=deepin</span><br><span class="line">DISPLAY=:0</span><br><span class="line">D_DISABLE_RT_SCREEN_SCALE=1</span><br><span class="line">D_DXCB_FORCE_OVERRIDE_HIDPI=1</span><br><span class="line">GDK_BACKEND=x11</span><br><span class="line">GDMSESSION=Wayland</span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE=/usr/share/applications/deepin-terminal.desktop</span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE_PID=11851</span><br><span class="line">GNOME_DESKTOP_SESSION_ID=this-is-deprecated</span><br><span class="line">GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">GTK_MODULES=gail:atk-bridge</span><br><span class="line">HOME=/home/uos</span><br><span class="line">IM_CONFIG_CHECK_ENV=1</span><br><span class="line">IM_CONFIG_PHASE=1</span><br><span class="line">INPUT_METHOD=fcitx</span><br><span class="line">KWIN_USE_BUFFER_AGE=1</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LANGUAGE=zh_CN</span><br><span class="line">LOGNAME=uos</span><br><span class="line">PATH=/home/uos/.autojump/bin:/home/uos/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin</span><br><span class="line">PWD=/home/uos</span><br><span class="line">QT_ACCESSIBILITY=1</span><br><span class="line">QT_DBL_CLICK_DIST=15</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1</span><br><span class="line">QT_LOGGING_RULES=kwin*=<span class="literal">true</span>;kwin_libinput=<span class="literal">false</span>;</span><br><span class="line">QT_PLUGIN_PATH=/usr/lib/aarch64-linux-gnu/qt5/plugins</span><br><span class="line">QT_QPA_PLATFORM=</span><br><span class="line">QT_SCALE_FACTOR_ROUNDING_POLICY=PassThrough</span><br><span class="line">QT_WAYLAND_FORCE_DPI=96</span><br><span class="line">QT_WAYLAND_SHELL_INTEGRATION=kwayland-shell</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SHLVL=1</span><br><span class="line">SSH_AUTH_SOCK=/run/user/1000/keyring/ssh</span><br><span class="line">SYS_PRODUCT_NAME=</span><br><span class="line">TERM=xterm-256color</span><br><span class="line">USER=uos</span><br><span class="line">WAYLAND_DISPLAY=wayland-0</span><br><span class="line">WINDOWID=0</span><br><span class="line">XCURSOR_SIZE=24</span><br><span class="line">XDG_CURRENT_DESKTOP=Deepin</span><br><span class="line">XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/uos</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/1000</span><br><span class="line">XDG_SEAT=seat0</span><br><span class="line">XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0</span><br><span class="line">XDG_SESSION_CLASS=user</span><br><span class="line">XDG_SESSION_DESKTOP=Wayland</span><br><span class="line">XDG_SESSION_ID=2</span><br><span class="line">XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0</span><br><span class="line">XDG_SESSION_TYPE=wayland</span><br><span class="line">XDG_VTNR=1</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">auto_proxy=https://it.uniontech.com/proxy/proxy.pac</span><br><span class="line">OLDPWD=/home/uos</span><br><span class="line">ZSH=/home/uos/.oh-my-zsh</span><br><span class="line">PAGER=less</span><br><span class="line">LESS=-R</span><br><span class="line">LSCOLORS=Gxfxcxdxbxegedabagacad</span><br><span class="line">LS_COLORS=rs=0:di=01;34:<span class="built_in">ln</span>=01;36:mh=00:pi=40;33:so=01;35:<span class="keyword">do</span>=01;35:bd=40;33;01:<span class="built_in">cd</span>=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.<span class="built_in">rm</span>=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:</span><br><span class="line">AUTOJUMP_SOURCED=1</span><br><span class="line">AUTOJUMP_ERROR_PATH=/home/uos/.local/share/autojump/errors.log</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">[11:01:56] uos :: uos-PC  ➜  ~ » </span><br></pre></td></tr></table></figure>
<p>为了使Linux系统能够正常运行并为用户提供服务，需要数百个环境变量协同工作。然而，我们并不需要逐一学习每个变量。下表列出了 10 个非常重要的环境变量，详见表1</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HOME</td>
<td>用户的主目录（也称家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody></table>
<p>请注意：上述变量的名称并不固定。例如，在某些Linux系统中，<code>HOSTNAME</code> 可能被设置为 <code>HOST</code>。</p>
<h1 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h1><p>按照生命周期来分，Linux环境变量可以分为两类：</p>
<ol>
<li>永久的：需要用户修改相关的配置文件，变量将永久生效。</li>
<li>临时的：用户利用 <code>export</code> 命令在当前终端下声明环境变量，关闭Shell终端后该变量将失效。</li>
</ol>
<p>按照作用域来分，Linux环境变量可以分为：</p>
<ol>
<li>系统环境变量：系统环境变量对该系统中所有用户都有效。</li>
<li>用户环境变量：这种类型的环境变量只对特定的用户有效。</li>
</ol>
<h1 id="设置环境变量的方法"><a href="#设置环境变量的方法" class="headerlink" title="设置环境变量的方法"></a>设置环境变量的方法</h1><p>(1). 在&#x2F;etc&#x2F;profile文件中添加环境变量（对所有用户生效）</p>
<p>要在 <code>/etc/profile</code> 文件中添加一个变量，使其对所有用户生效并且是“永久的”，可以按照以下步骤进行：</p>
<ol>
<li><p>打开终端并以管理员身份登录。</p>
</li>
<li><p>使用文本编辑器（例如vim）打开 <code>/etc/profile</code> 文件。例如，执行以下命令打开文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文件末尾添加所需的变量，例如 <code>CLASSPATH</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLASSPATH=/usr/local/lib</span><br></pre></td></tr></table></figure>

<p>这将在每次系统启动时为所有用户设置 <code>CLASSPATH</code> 环境变量。</p>
</li>
<li><p>保存并关闭文件。</p>
</li>
</ol>
<p>现在，新添加的环境变量将对所有用户生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[10:55:16] uos :: uos-PC  ➜  ~ » <span class="built_in">cat</span> /etc/profile                </span><br><span class="line"><span class="comment"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))</span></span><br><span class="line"><span class="comment"># and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;`id -u`&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  PATH=<span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  PATH=<span class="string">&quot;/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PS1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BASH</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$BASH</span>&quot;</span> != <span class="string">&quot;/bin/sh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># The file bash.bashrc already sets the default PS1.</span></span><br><span class="line">    <span class="comment"># PS1=&#x27;\h:\w\$ &#x27;</span></span><br><span class="line">    <span class="keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="keyword">then</span></span><br><span class="line">      . /etc/bash.bashrc</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;`id -u`&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">      PS1=<span class="string">&#x27;# &#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      PS1=<span class="string">&#x27;$ &#x27;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d /etc/profile.d ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="variable">$i</span> ]; <span class="keyword">then</span></span><br><span class="line">      . <span class="variable">$i</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">unset</span> i</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">tty</span> | egrep -q <span class="built_in">tty</span>[1-6] &amp;&amp; <span class="built_in">export</span> LC_ALL=C</span><br><span class="line"></span><br><span class="line"><span class="built_in">tty</span> | egrep -q <span class="built_in">tty</span>[1-6] &amp;&amp; <span class="built_in">export</span> TMOUT=900</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>


<p>(2). 添加环境变量到单个用户的.bash_profile文件中（对单一用户生效）</p>
<p>要将一个变量添加到单个用户的 <code>.bash_profile</code> 文件中，使其仅对该用户有效并且是“永久的”，可以按照以下步骤进行：</p>
<ol>
<li><p>打开终端并以所需用户的身份登录。</p>
</li>
<li><p>使用文本编辑器（例如vim）打开 <code>~/.bash_profile</code> 文件。例如，执行以下命令打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文件末尾添加所需的变量，例如 <code>CLASSPATH</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">export CLASSPATH=/usr/local/lib</span><br></pre></td></tr></table></figure>

<p>这将在用户登录时为该用户设置 <code>CLASSPATH</code> 环境变量。</p>
</li>
<li><p>保存并关闭文件。</p>
</li>
</ol>
<p>现在，新添加的环境变量将仅对该用户生效。注意：修改文件后需要重新登录该用户才能使更改生效。</p>
<p>(3). 直接使用export命令定义环境变量（只对当前shell有效）</p>
<p>要在当前shell（BASH）中定义一个临时的环境变量，可以按照以下步骤进行：</p>
<ol>
<li><p>打开终端并启动所需shell（BASH）。</p>
</li>
<li><p>在命令行中使用 <code>export</code> 命令定义所需变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">export CLASSPATH=/usr/local/lib</span><br></pre></td></tr></table></figure>

<p>这将在当前shell中定义 <code>CLASSPATH</code> 环境变量。</p>
</li>
<li><p>在需要使用该变量的命令中使用该变量。</p>
</li>
</ol>
<p>请注意，当当前shell（BASH）关闭时，该环境变量也将被销毁。要使该变量永久生效，您需要将其添加到适当的配置文件中（如 <code>/etc/profile</code> 或 <code>~/.bash_profile</code>）。</p>
<h1 id="修改和查看环境变量"><a href="#修改和查看环境变量" class="headerlink" title="修改和查看环境变量"></a>修改和查看环境变量</h1><p>以下是一些在 Linux 中修改和查看环境变量的常用命令：</p>
<ul>
<li><code>echo</code>：显示某个环境变量的值。例如，可以通过执行 <code>echo $PATH</code> 命令来查看 <code>$PATH</code> 变量的值。</li>
<li><code>export</code>：设置一个新的环境变量。例如，可以通过执行 <code>export HELLO=&quot;hello&quot;</code> 命令来定义一个名为 <code>HELLO</code> 的环境变量并将其值设置为 “hello”。</li>
<li><code>env</code>：显示所有环境变量。执行 <code>env</code> 命令可以列出当前环境中的所有环境变量及其值。</li>
<li><code>set</code>：显示本地定义的 shell 变量。执行 <code>set</code> 命令可以查看当前 shell 中定义的所有变量，包括环境变量和本地变量。</li>
<li><code>unset</code>：清除环境变量。例如，可以通过执行 <code>unset HELLO</code> 命令来清除名为 <code>HELLO</code> 的环境变量。</li>
<li><code>readonly</code>：设置只读环境变量。例如，可以通过执行 <code>readonly HELLO</code> 命令将名为 <code>HELLO</code> 的环境变量设置为只读，以防止其被修改。</li>
</ul>
<h1 id="Systemd服务环境变量设置"><a href="#Systemd服务环境变量设置" class="headerlink" title="Systemd服务环境变量设置"></a>Systemd服务环境变量设置</h1><p>systemd服务创建的dbus服务，提供了一些方法用于设置派生进程的环境变：</p>
<ul>
<li>Service:org.freedesktop.systemd1</li>
<li>Path:&#x2F;org&#x2F;freedesktop&#x2F;systemd1</li>
<li>Interface:org.freedesktop.systemd1.Manager</li>
</ul>
<p>这些方法可以用来管理systemd服务以及它们所创建的派生进程的环境变量。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
</thead>
<tbody><tr>
<td>SetEnvironment (Array of [String] arg_0) ↦ ()</td>
<td>SetEnvironment() may be used to alter the environment block that is passed to all spawned processes. It takes a string array of environment variable assignments. Any previously set environment variables will be overridden.</td>
</tr>
<tr>
<td>UnsetEnvironment (Array of [String] arg_0) ↦ ()</td>
<td>UnsetEnvironment() may be used to unset environment variables. It takes a string array of environment variable names. All variables specified will be unset (if they have been set previously) and no longer be passed to all spawned processes. This method has no effect for variables that were previously not set, but will not fail in that case.</td>
</tr>
<tr>
<td>UnsetAndSetEnvironment (Array of [String] arg_0, Array of [String] arg_1) ↦ ()</td>
<td>UnsetAndSetEnvironment() is a combination of UnsetEnvironment() and SetEnvironment(). It takes two lists. The first list contains variables to unset, the second one contains assignments to set. If a variable is listed in both, the variable is set after this method returns, i.e. the set list overrides the unset list.</td>
</tr>
</tbody></table>
<p>注：事实上提供的服务中还允许我们调用接口实现systemctl的一些功能，提供启动或停止服务，对应的接口分别为StartUnit和StopUnit</p>
<h1 id="DBus服务环境变量设置"><a href="#DBus服务环境变量设置" class="headerlink" title="DBus服务环境变量设置"></a>DBus服务环境变量设置</h1><p>类似于systemd，dbus的服务中也提供了相应的方法来管理环境变量：<br>Service:org.freedesktop.DBus<br>Path:&#x2F;org&#x2F;freedesktop&#x2F;DBus<br>Interface:org.freedesktop.DBus</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
</thead>
<tbody><tr>
<td>UpdateActivationEnvironment (Dict of {String, String} arg_0) ↦ ()</td>
<td>…</td>
</tr>
</tbody></table>
<p>这个服务中提供了许多方法来控制进程环境变量的设置，例如 GetEnvironment() 方法可以获取当前进程的所有环境变量，SetEnv() 方法可以设置指定的环境变量，UnsetEnv() 方法可以取消指定的环境变量等等。通过这些方法，我们可以在DBus服务中方便地设置和管理进程环境变量。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote>
<p>本文资料为以下链接的总结，可能大量借鉴其中内容，仅做分享之用，如有侵权，告知必删。</p>
</blockquote>
<p><a class="link"   href="https://www.jianshu.com/p/ac2bc0ad3d74" >Linux环境变量总结<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="http://c.biancheng.net/view/5970.html" >什么是环境变量，Linux环境变量及作用<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.freedesktop.org/software/systemd/man/org.freedesktop.systemd1.html" >org.freedesktop.systemd1<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://wiki.archlinux.org/title/environment_variables" >环境变量<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>理解CPU的主频、倍频和外频</title>
    <url>/2024/07e7dec690.html</url>
    <content><![CDATA[<p>在计算机的世界里，CPU（中央处理器）作为计算机的大脑，其性能决定了整机的速度和效率。而CPU的主频、倍频和外频则是衡量其性能的重要参数。本文将为您深入浅出地介绍这三个概念，帮助您更好地理解它们之间的关系及其对CPU性能的影响。</p>
<span id="more"></span>

<h2 id="CPU的主频"><a href="#CPU的主频" class="headerlink" title="CPU的主频"></a>CPU的主频</h2><p>主频（Clock Speed）是指CPU的工作频率，通常以GHz（千兆赫兹）为单位。它表示CPU每秒钟能够执行的指令周期数。例如，一个主频为3.5GHz的CPU，每秒钟可以进行35亿个指令周期。</p>
<h3 id="为什么主频重要？"><a href="#为什么主频重要？" class="headerlink" title="为什么主频重要？"></a>为什么主频重要？</h3><ol>
<li><strong>执行速度</strong>：主频越高，CPU在单位时间内能够执行的指令就越多，处理速度也就越快。</li>
<li><strong>响应时间</strong>：高主频的CPU可以更快速地响应系统和应用程序的需求，提高计算机的整体性能。</li>
</ol>
<h2 id="CPU的外频"><a href="#CPU的外频" class="headerlink" title="CPU的外频"></a>CPU的外频</h2><p>外频（External Clock）是指主板与CPU之间的基准时钟频率。它通常由主板上的时钟发生器提供。外频的单位同样是Hz（赫兹）。</p>
<h3 id="外频的作用"><a href="#外频的作用" class="headerlink" title="外频的作用"></a>外频的作用</h3><p>外频是决定CPU最终工作频率（即主频）的基础参数。外频与倍频相结合，确定了CPU的主频。例如，如果外频为100MHz，而倍频为35，那么CPU的主频就是100MHz × 35 &#x3D; 3500MHz（即3.5GHz）。</p>
<h2 id="CPU的倍频"><a href="#CPU的倍频" class="headerlink" title="CPU的倍频"></a>CPU的倍频</h2><p>倍频（Multiplier）是一个无量纲的系数，它将外频放大，从而得到CPU的主频。倍频由CPU内部的倍频器决定，一般由CPU的设计厂商设定。</p>
<h3 id="倍频的特点"><a href="#倍频的特点" class="headerlink" title="倍频的特点"></a>倍频的特点</h3><ol>
<li><strong>可调节性</strong>：许多高端CPU支持倍频调节，允许用户在一定范围内调整倍频，从而超频或降频，以满足不同的性能需求和节能要求。</li>
<li><strong>灵活性</strong>：通过调整倍频，用户可以在不改变外频的情况下，灵活调整CPU的工作频率，提供更好的系统稳定性和性能优化。</li>
</ol>
<h2 id="主频、倍频与外频的关系"><a href="#主频、倍频与外频的关系" class="headerlink" title="主频、倍频与外频的关系"></a>主频、倍频与外频的关系</h2><p>简单来说，CPU的主频由外频和倍频共同决定，公式为： 主频&#x3D;外频×倍频\text{主频} &#x3D; \text{外频} \times \text{倍频}</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设一款CPU的外频为100MHz，倍频为35，那么它的主频就是：<br><code>主频=100MHz×35=3500MHz=3.5GHz</code></p>
<p>通过调整外频和倍频的组合，可以实现对CPU主频的精确控制。例如，通过将外频提升到105MHz，倍频保持35不变，新的主频就是：<br><code>主频=105MHz×35=3675MHz=3.675GHz</code></p>
<h2 id="如何调节外频和倍频"><a href="#如何调节外频和倍频" class="headerlink" title="如何调节外频和倍频"></a>如何调节外频和倍频</h2><p>现代计算机主板和CPU通常允许用户在BIOS&#x2F;UEFI设置中调整外频和倍频。这一过程称为“超频”（Overclocking）或“降频”（Underclocking）。不过，超频可能会带来系统不稳定和过热的问题，需要谨慎操作并确保良好的散热条件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解CPU的主频、倍频和外频是提升计算机性能的重要一步。主频是CPU性能的直接表现，而外频和倍频则共同决定了这一表现。通过合理调整这两个参数，用户可以在一定范围内优化CPU的工作频率，从而满足不同的计算需求。<br>希望通过本文，您对CPU的主频、倍频和外频有了更清晰的认识。如果有任何疑问或需要进一步的探讨，欢迎在评论区留言，我会尽力解答您的问题。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>窗口属性</title>
    <url>/2022/0948202.html</url>
    <content><![CDATA[<h1 id="窗口属性说明"><a href="#窗口属性说明" class="headerlink" title="窗口属性说明"></a>窗口属性说明</h1><p>当你使用 xprop 命令获取一个窗口的属性时，你会在终端中看到很多窗口相关的内容。这些属性分别有着不同的作用.</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/0948202/image.png"
                       
                 ></p>
<h3 id="应用窗口属性"><a href="#应用窗口属性" class="headerlink" title="应用窗口属性"></a>应用窗口属性</h3><h4 id="NET-WM-NAME"><a href="#NET-WM-NAME" class="headerlink" title="_NET_WM_NAME"></a>_NET_WM_NAME</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_NAME、UTF8_STRING</span><br></pre></td></tr></table></figure>

<p>客户端应该将其设置为 UTF-8 编码的窗口标题。如果设置，窗口管理器应该优先于 WM_NAME 使用它。</p>
<h4 id="NET-WM-VISIBLE-NAME"><a href="#NET-WM-VISIBLE-NAME" class="headerlink" title="_NET_WM_VISIBLE_NAME"></a>_NET_WM_VISIBLE_NAME</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_VISIBLE_NAME、UTF8_STRING</span><br></pre></td></tr></table></figure>

<p>如果窗口管理器显示的窗口名称不是 _NET_WM_NAME，则窗口管理器必须将其设置为以 UTF-8 编码显示的标题。</p>
<p>原理：此属性适用于显示与窗口的 _NET_WM_NAME 或 WM_NAME 不同的标题的窗口管理器（即显示了 xterm &lt;1&gt;、xterm &lt;2&gt;、…，但每个窗口的 _NET_WM_NAME &#x2F; WM_NAME 仍然是 xterm）从而允许寻呼机显示与窗口管理器相同的标题。</p>
<h4 id="NET-WM-ICON-NAME"><a href="#NET-WM-ICON-NAME" class="headerlink" title="_NET_WM_ICON_NAME"></a>_NET_WM_ICON_NAME</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ICON_NAME、UTF8_STRING</span><br></pre></td></tr></table></figure>

<p>客户端应该将其设置为 UTF-8 编码的此窗口图标的标题。如果设置，窗口管理器应该优先于 WM_ICON_NAME 使用它。</p>
<h4 id="NET-WM-VISIBLE-ICON-NAME"><a href="#NET-WM-VISIBLE-ICON-NAME" class="headerlink" title="_NET_WM_VISIBLE_ICON_NAME"></a>_NET_WM_VISIBLE_ICON_NAME</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_VISIBLE_ICON_NAME，UTF8_STRING</span><br></pre></td></tr></table></figure>

<p>如果窗口管理器显示的图标名称不是 _NET_WM_ICON_NAME，则窗口管理器必须将其设置为以 UTF-8 编码显示的标题。</p>
<h4 id="NET-WM-DESKTOP"><a href="#NET-WM-DESKTOP" class="headerlink" title="_NET_WM_DESKTOP"></a>_NET_WM_DESKTOP</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_DESKTOP desktop, CARDINAL/32</span><br></pre></td></tr></table></figure>

<p>Cardinal 确定窗口所在（或希望所在）的桌面，第一个桌面从 0 开始。客户端可以选择不设置这个属性，在这种情况下，窗口管理器应该按照它的意愿放置它。0xFFFFFFFF 表示该窗口应该出现在所有桌面上。</p>
<p>每当撤回的窗口请求映射时，窗口管理器都应遵守 _NET_WM_DESKTOP。</p>
<p>窗口管理器应在窗口退出时移除该属性，但在关闭时应保留该属性，例如响应丢失 WM_Sn 管理器选择的所有权。</p>
<p>基本原理：在窗口撤销时删除该属性有助于想要重用已撤销窗口的遗留应用程序。关闭时不删除该属性允许下一个窗口管理器将窗口恢复到以前的桌面。</p>
<p>客户端可以通过向根窗口发送 _NET_WM_DESKTOP 客户端消息来请求更改未撤消窗口的桌面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_DESKTOP</span><br><span class="line">  window  = the respective client window</span><br><span class="line">  message_type = _NET_WM_DESKTOP</span><br><span class="line">  format = 32</span><br><span class="line">  data.l[0] = new_desktop</span><br><span class="line">  data.l[1] = source indication</span><br><span class="line">  other data.l[] elements = 0</span><br></pre></td></tr></table></figure>

<p>有关<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#sourceindication" >源指示<i class="fas fa-external-link-alt"></i></a>的详细信息，请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#sourceindication" >“请求中<i class="fas fa-external-link-alt"></i></a>的源指示”一节。窗口管理器必须在所有窗口上更新此属性。</p>
<h4 id="NET-WM-WINDOW-TYPE"><a href="#NET-WM-WINDOW-TYPE" class="headerlink" title="_NET_WM_WINDOW_TYPE"></a>_NET_WM_WINDOW_TYPE</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_WINDOW_TYPE, ATOM[]/32</span><br></pre></td></tr></table></figure>

<p>这应该在映射到指示窗口功能类型的原子列表之前由客户端设置。窗口管理器应该使用此属性来确定窗口的装饰、堆叠位置和其他行为。客户端应该按优先级顺序指定窗口类型（第一个是最可取的），但必须包括以下列表中的至少一个基本窗口类型原子。这是为了允许扩展类型列表，同时为无法识别扩展的窗口管理器提供默认行为。</p>
<p>此提示也应该为覆盖重定向窗口设置，以允许合成管理器将一致的装饰应用于菜单、工具提示等。</p>
<p>基本原理：此提示旨在替换 MOTIF 提示。对 MOTIF 提示的反对意见之一是它们纯粹是对窗户装饰的视觉描述。通过描述窗口的功能，窗口管理器可以对相同类型的窗口应用一致的装饰和行为。可能的行为示例包括将停靠栏&#x2F;面板保持在顶部或仅在另一个窗口具有焦点时才隐藏可固定菜单&#x2F;工具栏（NextStep 样式）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_WINDOW_TYPE_DESKTOP，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_DOCK，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_TOOLBAR，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_MENU，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_UTILITY，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_SPLASH，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_DIALOG，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_DROPDOWN_MENU，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_POPUP_MENU，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_TOOLTIP，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_NOTIFICATION，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_COMBO，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_DND，ATOM </span><br><span class="line">_NET_WM_WINDOW_TYPE_NORMAL，ATOM</span><br></pre></td></tr></table></figure>

<p>_NET_WM_WINDOW_TYPE_DESKTOP 表示桌面功能。这可以包括一个包含与屏幕尺寸相同的桌面图标的单个窗口，允许桌面环境完全控制桌面，而无需代理根窗口点击。</p>
<p>_NET_WM_WINDOW_TYPE_DOCK 表示停靠或面板功能。通常，窗口管理器会将此类窗口保留在所有其他窗口之上。</p>
<p>_NET_WM_WINDOW_TYPE_TOOLBAR 和 _NET_WM_WINDOW_TYPE_MENU 分别表示工具栏和可固定菜单窗口（即从主应用程序“撕下”的工具栏和菜单）。这种类型的窗口可以设置 WM_TRANSIENT_FOR 提示，指示主应用程序窗口。请注意，_NET_WM_WINDOW_TYPE_MENU 应设置在撕下的托管窗口上，其中 _NET_WM_WINDOW_TYPE_DROPDOWN_MENU 和 _NET_WM_WINDOW_TYPE_POPUP_MENU 通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_UTILITY 表示小的持久实用程序窗口，例如调色板或工具箱。它不同于 TOOLBAR 类型，因为它不对应于从主应用程序中撕下的工具栏。它与 DIALOG 类型不同，因为它不是临时对话框，用户可能会在他们工作时保持打开状态。这种类型的窗口可以设置 WM_TRANSIENT_FOR 提示，指示主应用程序窗口。</p>
<p>_NET_WM_WINDOW_TYPE_SPLASH 表示该窗口是应用程序启动时显示的启动画面。</p>
<p>_NET_WM_WINDOW_TYPE_DIALOG 表示这是一个对话窗口。如果未设置 _NET_WM_WINDOW_TYPE，则必须将设置了 WM_TRANSIENT_FOR 的托管窗口视为这种类型。使用 WM_TRANSIENT_FOR 覆盖重定向窗口，但没有 _NET_WM_WINDOW_TYPE 必须被视为 _NET_WM_WINDOW_TYPE_NORMAL。</p>
<p>_NET_WM_WINDOW_TYPE_DROPDOWN_MENU 表示所讨论的窗口是下拉菜单，即通常在用户单击菜单栏时出现的那种菜单，而不是通常在用户右键单击对象时出现的弹出菜单。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_POPUP_MENU 表示有问题的窗口是一个弹出菜单，即当用户右键单击一个对象时通常会出现的那种菜单，而不是通常在用户单击菜单栏时出现的下拉菜单。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_TOOLTIP 表示有问题的窗口是工具提示，即通常在鼠标光标悬停在对象上一段时间后出现的一小段解释性文本。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_NOTIFICATION 表示通知。通知的一个示例是出现带有信息文本的气泡，例如“您的笔记本电脑电量不足”等。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_COMBO 应该用在组合框弹出的窗口上。一个示例是出现在文本字段下方的窗口，其中包含建议完成的列表。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_DND 表示正在拖动窗口。当有问题的窗口包含一个对象从一个地方拖到另一个地方的表示时，客户应该设置这个提示。一个例子是一个包含从一个文件管理器窗口拖到另一个文件管理器窗口的图标的窗口。此属性通常用于覆盖重定向窗口。</p>
<p>_NET_WM_WINDOW_TYPE_NORMAL 表示这是一个普通的顶级窗口，无论是托管还是覆盖重定向。必须将既没有 _NET_WM_WINDOW_TYPE 也没有设置 WM_TRANSIENT_FOR 的托管窗口视为这种类型。没有 _NET_WM_WINDOW_TYPE 的覆盖重定向窗口必须被视为这种类型，无论它们是否设置了 WM_TRANSIENT_FOR。</p>
<h4 id="NET-WM-STATE"><a href="#NET-WM-STATE" class="headerlink" title="_NET_WM_STATE"></a>_NET_WM_STATE</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_STATE, ATOM[]</span><br></pre></td></tr></table></figure>

<p>描述窗口状态的提示列表。列表中存在的原子必须被视为已设置，列表中不存在的原子必须被视为未设置。每当撤回的窗口请求映射时，窗口管理器都应该遵守 _NET_WM_STATE。希望更改窗口状态的客户端必须向根窗口发送 _NET_WM_STATE 客户端消息（见下文）。窗口管理器必须保持此属性更新以反映窗口的当前状态。</p>
<p>窗口管理器应在窗口退出时删除该属性，但在关闭时应保留该属性，例如响应失去 WM_Sn 管理器选择的所有权。</p>
<p>基本原理：在窗口撤销时删除该属性有助于想要重用已撤销窗口的遗留应用程序。关闭时不删除该属性允许下一个窗口管理器将窗口恢复到以前的状态。</p>
<p>可能的原子是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_STATE_MODAL，ATOM </span><br><span class="line">_NET_WM_STATE_STICKY，ATOM </span><br><span class="line">_NET_WM_STATE_MAXIMIZED_VERT，ATOM </span><br><span class="line">_NET_WM_STATE_MAXIMIZED_HORZ，ATOM </span><br><span class="line">_NET_WM_STATE_SHADED，ATOM </span><br><span class="line">_NET_WM_STATE_SKIP_TASKBAR，ATOM </span><br><span class="line">_NET_WM_STATE_SKIP_PAGER，ATOM </span><br><span class="line">_NET_WM_STATE_HIDDEN，ATOM </span><br><span class="line">_NET_WM_STATE_FULLSCREEN，ATOM </span><br><span class="line">_NET_WM_STATE_ABOVE，ATOM </span><br><span class="line">_NET_WM_STATE_BELOW，ATOM </span><br><span class="line">_NET_WM_STATE_DEMANDS_ATTENTION，ATOM</span><br></pre></td></tr></table></figure>

<p>一个实现可以向这个列表添加新的原子。没有扩展的实现必须忽略任何未知原子，有效地将它们从列表中删除。这些扩展原子不能以前缀 _NET 开头。</p>
<p>_NET_WM_STATE_MODAL 表示这是一个模式对话框。如果 WM_TRANSIENT_FOR 提示设置为另一个顶级窗口，则该对话框是该窗口的模态对话框；如果 WM_TRANSIENT_FOR 未设置或设置为根窗口，则对话框是其窗口组的模态对话框。</p>
<p>_NET_WM_STATE_STICKY 表示窗口管理器应该保持窗口在屏幕上的位置固定，即使虚拟桌面滚动时也是如此。</p>
<p><em>NET_WM_STATE_MAXIMIZED</em>{VERT,HORZ} 表示窗口{vertically,horizontally}最大化。</p>
<p>_NET_WM_STATE_SHADED 表示窗口是阴影的。</p>
<p>_NET_WM_STATE_SKIP_TASKBAR 指示窗口不应包含在任务栏上。该提示应由应用程序请求，即它表明该窗口本质上从不在任务栏中。如果 _NET_WM_WINDOW_TYPE 已经传达了窗口的确切性质，则应用程序不应设置此提示。</p>
<p>_NET_WM_STATE_SKIP_PAGER 表示该窗口不应包含在寻呼机中。这个提示应该由应用程序请求，即它表明窗口本质上从不在寻呼机中。如果 _NET_WM_WINDOW_TYPE 已经传达了窗口的确切性质，则应用程序不应设置此提示。</p>
<p>_NET_WM_STATE_HIDDEN 应由窗口管理器设置，以指示如果窗口的桌面&#x2F;视口处于活动状态且其坐标在屏幕边界内，则该窗口在屏幕上不可见。典型的例子是最小化的窗口应该处于 _NET_WM_STATE_HIDDEN 状态。寻呼机和类似的应用程序应该使用 _NET_WM_STATE_HIDDEN 而不是 WM_STATE 来决定是否以桌面上窗口的微型表示形式显示窗口。</p>
<p>实现说明：如果应用程序要求切换 _NET_WM_STATE_HIDDEN，则窗口管理器可能应该忽略该请求，因为 _NET_WM_STATE_HIDDEN 是窗口其他方面的函数，例如最小化，而不是独立状态。</p>
<p>_NET_WM_STATE_FULLSCREEN 表示窗口应该填满整个屏幕并且没有窗口装饰。此外，窗口管理器负责在从全屏切换回普通窗口后恢复原始几何图形。例如，演示程序将使用此提示。</p>
<p>_NET_WM_STATE_ABOVE 表示窗口应该在大多数窗口的顶部（有关详细信息，请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#STACKINGORDER" >“堆叠顺序”一节<i class="fas fa-external-link-alt"></i></a>）。</p>
<p>_NET_WM_STATE_BELOW 表示该窗口应位于大多数窗口下方（有关详细信息，请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#STACKINGORDER" >“堆叠顺序”部分<i class="fas fa-external-link-alt"></i></a>）。</p>
<p>_NET_WM_STATE_ABOVE 和 _NET_WM_STATE_BELOW 主要用于用户首选项，不应由应用程序使用，例如用于引起对其对话框的注意（在这种情况下应使用紧急提示，请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#URGENCY" >名为“紧急”的部分<i class="fas fa-external-link-alt"></i></a>）。</p>
<p>_NET_WM_STATE_DEMANDS_ATTENTION 表示在窗口内或窗口中发生了某些操作。例如，如果窗口请求激活但窗口管理器拒绝它，则它可能由窗口管理器设置，或者如果应用程序完成了某些工作，则它可以设置它。这种状态可以由客户端和窗口管理器设置。当窗口管理器决定窗口得到所需的关注（通常，它被激活）时，它应该被取消设置。</p>
<p>要更改映射窗口的状态，客户端必须向根窗口发送 _NET_WM_STATE 客户端消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window  = the respective client window</span><br><span class="line">message_type = _NET_WM_STATE</span><br><span class="line">format = 32</span><br><span class="line">data.l[0] = the action, as listed below</span><br><span class="line">data.l[1] = first property to alter</span><br><span class="line">data.l[2] = second property to alter</span><br><span class="line">data.l[3] = source indication</span><br><span class="line">other data.l[] elements = 0</span><br></pre></td></tr></table></figure>

<p>此消息允许同时更改两个属性，特别是允许同时更改水平和垂直最大化。如果仅更改一个属性，则 l[2] 必须设置为零。有关<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#sourceindication" >源指示<i class="fas fa-external-link-alt"></i></a>的详细信息，请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#sourceindication" >“请求中<i class="fas fa-external-link-alt"></i></a>的源指示”一节。l[0]，动作，必须是以下之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_STATE_REMOVE        0    /* remove/unset property */</span><br><span class="line">_NET_WM_STATE_ADD           1    /* add/set property */</span><br><span class="line">_NET_WM_STATE_TOGGLE        2    /* toggle property  */</span><br></pre></td></tr></table></figure>

<p>另请参阅有关<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#URGENCY" >紧急<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#NORESIZE" >固定大小窗口<i class="fas fa-external-link-alt"></i></a>的实施说明。</p>
<h4 id="NET-WM-ALLOWED-ACTIONS"><a href="#NET-WM-ALLOWED-ACTIONS" class="headerlink" title="_NET_WM_ALLOWED_ACTIONS"></a>_NET_WM_ALLOWED_ACTIONS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ALLOWED_ACTIONS, ATOM[]</span><br></pre></td></tr></table></figure>

<p>指示窗口管理器支持此窗口的用户操作的原子列表。列表中存在的原子表示允许的操作，列表中不存在的原子表示此窗口不支持的操作。窗口管理器必须保持该属性更新以反映当前对窗口“活动”或“敏感”的操作。任务栏、寻呼机和其他工具使用 _NET_WM_ALLOWED_ACTIONS 来决定应向用户提供哪些操作。</p>
<p>可能的原子是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ACTION_MOVE，ATOM </span><br><span class="line">_NET_WM_ACTION_RESIZE，ATOM </span><br><span class="line">_NET_WM_ACTION_MINIMIZE，ATOM </span><br><span class="line">_NET_WM_ACTION_SHADE，ATOM </span><br><span class="line">_NET_WM_ACTION_STICK，ATOM </span><br><span class="line">_NET_WM_ACTION_MAXIMIZE_HORZ，ATOM </span><br><span class="line">_NET_WM_ACTION_MAXIMIZE_VERT，ATOM </span><br><span class="line">_NET_WM_ACTION_FULLSCREEN，ATOM </span><br><span class="line">_NET_WM_ACTION_CHANGE_DESKTOP，ATOM </span><br><span class="line">_NET_WM_ACTION_CLOSE，ATOM </span><br><span class="line">_NET_WM_ACTION_ABOVE，ATOM </span><br><span class="line">_NET_WM_ACTION_BELOW，ATOM</span><br></pre></td></tr></table></figure>

<p>一个实现可以向这个列表添加新的原子。没有扩展的实现必须忽略任何未知原子，有效地将它们从列表中删除。这些扩展原子不能以前缀 _NET 开头。</p>
<p>请注意，此处列出的操作是_窗口管理器_将为此窗口执行的操作。仍然必须通过本规范中概述的正常机制来请求操作。例如，_NET_WM_ACTION_CLOSE 并不意味着客户端可以向该窗口发送 WM_DELETE_WINDOW 消息；这意味着客户端可以使用 _NET_CLOSE_WINDOW 消息来要求窗口管理器这样做。</p>
<p>窗口管理器在最初管理窗口时应该忽略 _NET_WM_ALLOWED_ACTIONS 的值。这个值可能是以前的具有不同策略的窗口管理器遗留下来的。</p>
<p>_NET_WM_ACTION_MOVE 表示窗口可以在屏幕上移动。</p>
<p>_NET_WM_ACTION_RESIZE 表示可以调整窗口大小。（实施说明：窗口管理器可以识别不可调整大小的窗口，因为它在 WM_NORMAL_HINTS 中的最小和最大大小将相同。）</p>
<p>_NET_WM_ACTION_MINIMIZE 表示窗口可以被图标化。</p>
<p>_NET_WM_ACTION_SHADE 表示窗口可能有阴影。</p>
<p>_NET_WM_ACTION_STICK 表示窗口可能会切换其粘性状态（如 _NET_WM_STATE_STICKY）。请注意，此状态与视口有关，而不是桌面。</p>
<p>_NET_WM_ACTION_MAXIMIZE_HORZ 表示窗口可以水平最大化。</p>
<p>_NET_WM_ACTION_MAXIMIZE_VERT 表示窗口可以垂直最大化。</p>
<p>_NET_WM_ACTION_FULLSCREEN 表示窗口可以进入全屏状态。</p>
<p>_NET_WM_ACTION_CHANGE_DESKTOP 表示窗口可以在桌面之间移动。</p>
<p>_NET_WM_ACTION_CLOSE 表示窗口可以关闭（即可以发送_NET_CLOSE_WINDOW 消息）。</p>
<p>_NET_WM_ACTION_ABOVE 表示窗口可以放置在窗口的“above”层（即会响应_NET_WM_STATE_ABOVE 的变化；详见<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#STACKINGORDER" >“堆叠顺序”一节<i class="fas fa-external-link-alt"></i></a>）。</p>
<p>_NET_WM_ACTION_BELOW 表示窗口可以放置在窗口的“下”层（即将响应 _NET_WM_STATE_BELOW 更改；有关详细信息，另请参阅<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#STACKINGORDER" >“堆叠顺序”部分<i class="fas fa-external-link-alt"></i></a>））。</p>
<h4 id="NET-WM-STRUT"><a href="#NET-WM-STRUT" class="headerlink" title="_NET_WM_STRUT"></a>_NET_WM_STRUT</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_STRUT, left, right, top, bottom, CARDINAL[4]/32</span><br></pre></td></tr></table></figure>

<p>此属性等效于 _NET_WM_STRUT_PARTIAL 属性，其中所有起始值为 0，所有结束值为逻辑屏幕的高度或宽度。_NET_WM_STRUT_PARTIAL 是在 _NET_WM_STRUT 之后引入的，因此，除了 _NET_WM_STRUT_PARTIAL 之外，客户端还可以设置此属性，以确保与支持旧版本规范的窗口管理器向后兼容。</p>
<h4 id="NET-WM-STRUT-PARTIAL"><a href="#NET-WM-STRUT-PARTIAL" class="headerlink" title="_NET_WM_STRUT_PARTIAL"></a>_NET_WM_STRUT_PARTIAL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_STRUT_PARTIAL, left, right, top, bottom, left_start_y, left_end_y,</span><br><span class="line">right_start_y, right_end_y, top_start_x, top_end_x, bottom_start_x,</span><br><span class="line">bottom_end_x,CARDINAL[12]/32</span><br></pre></td></tr></table></figure>

<p>如果窗口要在屏幕边缘保留空间，则该属性必须由客户端设置。该属性包含 4 个基数，指定屏幕每个边框处保留区域的宽度，另外 8 个基数指定与四个支柱中的每一个相对应的开始和结束。值的顺序是左、右、上、下、left_start_y、left_end_y、right_start_y、right_end_y、top_start_x、top_end_x、bottom_start_x、bottom_end_x。所有坐标都是根窗口坐标。客户端可以随时更改此属性，因此如果窗口管理器使用此属性为窗口分配特殊语义，则窗口管理器必须监视属性通知事件。</p>
<p>如果此属性和 _NET_WM_STRUT 属性都设置，则窗口管理器必须忽略 _NET_WM_STRUT 属性值并使用 _NET_WM_STRUT_PARTIAL 的值。这将确保客户端可以安全地设置这两个属性，而不会放弃新属性的改进语义。</p>
<p>struts 的目的是在桌面边界保留空间。例如，这对于停靠区域、任务栏或面板非常有用。窗口管理器在限制窗口位置时应该考虑这个保留区域——例如，最大化的窗口不应覆盖该区域。</p>
<p>与每个支柱相关联的开始和结束值允许保留不跨越整个屏幕宽度或高度的区域。Struts 必须在根窗口坐标中指定，也就是说，它们 _不_相对于任何视口或 Xinerama 监视器的边缘。</p>
<p>例如，对于出现在屏幕底部的面板样式的客户端，高 50 像素，占据屏幕边缘左侧 200-600 像素的空间，将底部支柱设置为 50，并将 bottom_start_x 设置为 200和bottom_end_x 到600。另一个例子是使用Xinerama 扩展的屏幕面板。假设设置使用两台显示器，一台以 1280x1024 运行，另一台以 1024x768 运行在右侧，两个物理显示器的顶部边缘对齐。如果面板想要用 50 像素高的面板填充较小显示器的整个底部边缘，则应设置底部支柱为 306，bottom_start_x 为 1280，bottom_end_x 为 2303。请注意，支柱是相对于屏幕边缘的，而不是 xinerama 显示器的边缘。</p>
<p>基本原理：简单的“不要覆盖”提示不足以处理例如自动隐藏面板。</p>
<p>注意：自动隐藏面板应该将支柱设置为其最小的隐藏尺寸。没有延伸到屏幕边框全长的“角”面板应该只设置一个支柱。</p>
<h4 id="NET-WM-ICON-GEOMETRY"><a href="#NET-WM-ICON-GEOMETRY" class="headerlink" title="_NET_WM_ICON_GEOMETRY"></a>_NET_WM_ICON_GEOMETRY</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ICON_GEOMETRY, x, y, width, height, CARDINAL[4]/32</span><br></pre></td></tr></table></figure>

<p>这个可选属性可以由独立的工具设置，比如任务栏或图标框。它指定了可能图标的几何形状，以防窗口被图标化。</p>
<p>基本原理：这使得窗口管理器可以显示漂亮的动画，例如将窗口变形为其图标。</p>
<p>Tips:控制中心个性化中设置窗口的最小化效果，就是依赖的这个属性</p>
<h4 id="NET-WM-ICON"><a href="#NET-WM-ICON" class="headerlink" title="_NET_WM_ICON"></a>_NET_WM_ICON</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ICON CARDINAL[][2+n]/32</span><br></pre></td></tr></table></figure>

<p>这是客户端可能的图标数组。本规范没有规定这些图标的大小，但个别桌面环境或工具包可能会这样做。窗口管理器可以将这些图标中的任何一个缩放到适当的大小。</p>
<p>这是一个 32 位封装的 CARDINAL ARGB 数组，高字节为 A，低字节为 B。前两个基数是宽度，高度。数据按行，从左到右，从上到下。</p>
<h4 id="NET-WM-PID"><a href="#NET-WM-PID" class="headerlink" title="_NET_WM_PID"></a>_NET_WM_PID</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_PID CARDINAL/32</span><br></pre></td></tr></table></figure>

<p>如果设置，此属性必须包含拥有此窗口的客户端的进程 ID。这可以被窗口管理器用来杀死不响应 _NET_WM_PING 协议的窗口。</p>
<p>如果设置了 _NET_WM_PID，则还必须设置 ICCCM 指定的属性 WM_CLIENT_MACHINE。虽然 ICCCM 仅要求将 WM_CLIENT_MACHINE 设置为 “从运行服务器的机器上看到的形成运行客户端的机器名称的字符串”，但符合此规范要求将 WM_CLIENT_MACHINE 设置为完全限定域名客户的主机。</p>
<p>另请参阅有关<a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s09.html#KILLINGWINDOWS" >终止挂起进程<i class="fas fa-external-link-alt"></i></a>的实施说明。</p>
<h4 id="NET-WM-HANDLED-ICONS"><a href="#NET-WM-HANDLED-ICONS" class="headerlink" title="_NET_WM_HANDLED_ICONS"></a>_NET_WM_HANDLED_ICONS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_HANDLED_ICONS</span><br></pre></td></tr></table></figure>

<p>该属性可由寻呼机在其自己的顶级窗口之一上设置，以指示窗口管理器不需要为图标化窗口提供图标，例如，如果它是任务栏并为图标化窗口提供按钮。</p>
<h4 id="NET-WM-USER-TIME"><a href="#NET-WM-USER-TIME" class="headerlink" title="_NET_WM_USER_TIME"></a>_NET_WM_USER_TIME</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_USER_TIME CARDINAL/32</span><br></pre></td></tr></table></figure>

<p>此属性包含此窗口中最后一次用户活动发生的 XServer 时间。</p>
<p>在映射窗口之前，客户端应在每个新的顶级窗口（或由 _NET_WM_USER_TIME_WINDOW 属性指出的窗口）上将此属性设置为导致窗口出现的用户交互的时间戳。例如，仅处理核心事件的客户端可能会使用最后一个 KeyPress 或 ButtonPress 事件的时间戳。ButtonRelease 和 KeyRelease 事件通常不应被视为用户交互，因为应用程序可能会从全局键绑定接收 KeyRelease 事件，并且通常释放事件的时间戳可能晚于匹配按下事件触发的操作。如果应用程序是通过启动通知启动的，客户端可以从 DESKTOP_STARTUP_ID 环境变量中获取导致其第一个窗口出现的时间戳。如果客户端不知道导致第一个窗口出现的用户交互的时间戳（例如，因为它没有通过启动通知启动），那么它不应为该窗口设置属性。新映射窗口上的特殊值零可用于请求该窗口在映射时最初不被聚焦。</p>
<p>如果客户端有活动窗口，它也应该在有用户活动时更新窗口上的这个属性。</p>
<p>基本原理：此属性允许窗口管理器在映射时更改窗口的焦点、堆叠和&#x2F;或放置行为，具体取决于新窗口是由用户操作创建的还是由用户操作激活的“弹出”窗口。计时器或其他一些事件。</p>
<h4 id="NET-WM-USER-TIME-WINDOW"><a href="#NET-WM-USER-TIME-WINDOW" class="headerlink" title="_NET_WM_USER_TIME_WINDOW"></a>_NET_WM_USER_TIME_WINDOW</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_USER_TIME_WINDOW WINDOW/32</span><br></pre></td></tr></table></figure>

<p>此属性包含客户端在其上设置 _NET_WM_USER_TIME 属性的窗口的 XID。客户端应检查窗口管理器是否支持 _NET_WM_USER_TIME_WINDOW，如果不支持，则回退到在顶层窗口上设置 _NET_WM_USER_TIME 属性。</p>
<p>原理：在顶层窗口本身存储频繁变化的 _NET_WM_USER_TIME 属性会导致每个对该窗口的任何属性感兴趣的应用程序在每次按键时都被唤醒，这对于使用电池供电的笔记本电脑尤其不利。</p>
<h4 id="NET-FRAME-EXTENTS"><a href="#NET-FRAME-EXTENTS" class="headerlink" title="_NET_FRAME_EXTENTS"></a>_NET_FRAME_EXTENTS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_FRAME_EXTENTS, left, right, top, bottom, CARDINAL[4]/32</span><br></pre></td></tr></table></figure>

<p>窗口管理器必须将 _NET_FRAME_EXTENTS 设置为窗口框架的范围。left、right、top 和 bottom 是窗口管理器添加的相应边框的宽度。</p>
<h3 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h3><p>打开visual studio code.运行xprop命令后点击vscode页面，属性内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NET_WM_ICON_GEOMETRY(CARDINAL) = 322, 1040, 41, 41   #应用图标在桌面上的位置，一般由任务栏或者图标框设置</span><br><span class="line">_VARIABLE_REFRESH(CARDINAL) = 1 						#TODO</span><br><span class="line">_NET_WM_ALLOWED_ACTIONS(ATOM) = _NET_WM_ACTION_MOVE, _NET_WM_ACTION_RESIZE, _NET_WM_ACTION_MINIMIZE, _NET_WM_ACTION_SHADE, _NET_WM_ACTION_MAXIMIZE_VERT, _NET_WM_ACTION_MAXIMIZE_HORZ, _NET_WM_ACTION_FULLSCREEN, _NET_WM_ACTION_CHANGE_DESKTOP, _NET_WM_ACTION_CLOSE 									# 窗口支持的操作</span><br><span class="line">_KDE_NET_WM_FRAME_STRUT(CARDINAL) = 0, 0, 40, 0 # TODO</span><br><span class="line">_NET_FRAME_EXTENTS(CARDINAL) = 0, 0, 40, 0 				# 窗管为应用添加的边框，一般都是顶部减去标题栏所占的高度</span><br><span class="line">_NET_WM_DESKTOP(CARDINAL) = 0 							# 用于区分窗口当前在哪个工作区显示</span><br><span class="line">WM_STATE(WM_STATE): # TODO</span><br><span class="line">                window state: Normal</span><br><span class="line">                icon window: 0x0</span><br><span class="line">_NET_WM_STATE(ATOM) = _NET_WM_STATE_MAXIMIZED_VERT, _NET_WM_STATE_MAXIMIZED_HORZ # 表示当前窗口水平和垂直方向都已最大化</span><br><span class="line">_NET_WM_USER_TIME(CARDINAL) = 16531347 					# 此应用的最后一次鼠标点击发生在开机后的第16531347毫秒时</span><br><span class="line">WM_NORMAL_HINTS(WM_SIZE_HINTS): 						# 告诉窗管应用的位置以及大小</span><br><span class="line">                program specified location: 0, 40</span><br><span class="line">                program specified minimum size: 400 by 270</span><br><span class="line">                program specified maximum size: 2147483647 by 2147483647</span><br><span class="line">_NET_WM_ICON(CARDINAL) = 								# 窗口的图标数组，一般会有不同的大小</span><br><span class="line">WM_NAME(UTF8_STRING) = &quot;init.go - dde-daemon - Visual Studio Code&quot; 				# 窗口标题，比_NET_WM_NAME优先级低</span><br><span class="line">_NET_WM_NAME(UTF8_STRING) = &quot;init.go - dde-daemon - Visual Studio Code&quot; 		# 窗口标题，比_WM_NAME优先级高</span><br><span class="line">_MOTIF_WM_HINTS(_MOTIF_WM_HINTS) = 0x2, 0x0, 0x1, 0x0, 0x0						# TODO</span><br><span class="line">XdndAware(ATOM) = BITMAP</span><br><span class="line">_NET_WM_BYPASS_COMPOSITOR(CARDINAL) = 2</span><br><span class="line">WM_WINDOW_ROLE(STRING) = &quot;browser-window&quot;</span><br><span class="line">WM_CLASS(STRING) = &quot;code&quot;, &quot;Code&quot;						# 窗管可利用此属性通过X资源系统去查找程序的设置和首选项，不过目前没看出怎么使用的</span><br><span class="line">_NET_WM_WINDOW_TYPE(ATOM) = _NET_WM_WINDOW_TYPE_NORMAL	# 窗口类型为普通的顶级窗口</span><br><span class="line">_NET_WM_PID(CARDINAL) = 8313							# 此窗口对应进程的ID</span><br><span class="line">WM_CLIENT_MACHINE(STRING) = &quot;fpc-PC&quot;					# 一般为对应的主机名</span><br><span class="line">WM_PROTOCOLS(ATOM): protocols  WM_DELETE_WINDOW, _NET_WM_PING, _NET_WM_SYNC_REQUEST		# _NET_WM_PING允许窗管检查无法正常关闭窗口是何种原因；_NET_WM_SYNC_REQUEST允许客户端和窗管之间同步重绘的操作</span><br><span class="line">_KDE_NET_WM_USER_CREATION_TIME(CARDINAL) = 2118513		# 窗口被创建出来的时间，开机后的第2118513毫秒时创建</span><br></pre></td></tr></table></figure>

<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><strong><a class="link"   href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s05.html" >Application Window Properties<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><a href="https://specifications.freedesktop.org/wm-spec/1.4/ar01s06.html"><strong>Window Manager Protocols</strong></a></p>
<p><strong><a class="link"   href="https://metacpan.org/pod/X11::Protocol::WM" >X11::Protocol::WM<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><strong><a class="link"   href="https://specifications.freedesktop.org/wm-spec/wm-spec-latest.html" >Extended Window Manager Hints<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><strong><a class="link"   href="https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html" >Inter-Client Communication Conventions Manual<i class="fas fa-external-link-alt"></i></a></strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>X</tag>
        <tag>窗口属性</tag>
      </tags>
  </entry>
  <entry>
    <title>简易结构体的设计思路</title>
    <url>/2023/06e0886c2a.html</url>
    <content><![CDATA[<p>编程小记—应对一般的组合结构</p>
<span id="more"></span>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyValue</span> &#123;</span><br><span class="line">    QString key;</span><br><span class="line">    QString value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;KeyValue&gt; KeyValues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FStruct</span>;</span><br><span class="line"><span class="keyword">typedef</span> QList&lt;FStruct *&gt; Childs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 承载普通的json数据</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FStruct</span> &#123;</span><br><span class="line">    KeyValues list;</span><br><span class="line">    QMap&lt;QString, Childs&gt; childMap;</span><br><span class="line"></span><br><span class="line">    ~ <span class="built_in">FStruct</span>() &#123;</span><br><span class="line">        list.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (!childMap.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> clist : childMap.<span class="built_in">values</span>())</span><br><span class="line">                <span class="built_in">qDeleteAll</span>(clist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dumpFStruct(FStruct *fs, QString node, <span class="type">int</span> depth) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;dump&quot;</span> &lt;&lt; node &lt;&lt; <span class="string">&quot;, depth : &quot;</span> &lt;&lt; depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : fs-&gt;list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; kv.key &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; kv.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;childMap.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = fs-&gt;childMap.<span class="built_in">begin</span>(); it != fs-&gt;childMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tag = it.<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">auto</span> childs = it.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : childs) &#123;</span><br><span class="line">            _dumpFStruct(child, tag, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dumpFStruct</span><span class="params">(FStruct *fs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;dump:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : fs-&gt;list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; kv.key &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; kv.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;childMap.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = fs-&gt;childMap.<span class="built_in">begin</span>(); it != fs-&gt;childMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tag = it.<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">auto</span> childs = it.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : childs) &#123;</span><br><span class="line">            _dumpFStruct(child, tag, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QJsonValue <span class="title">convertToJson</span><span class="params">(FStruct *fs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Q_ASSERT</span>(fs);</span><br><span class="line"></span><br><span class="line">    QJsonObject kvObj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : fs-&gt;list) &#123;</span><br><span class="line">        kvObj.<span class="built_in">insert</span>(kv.key, kv.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = fs-&gt;childMap.<span class="built_in">begin</span>(); it != fs-&gt;childMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tag = it.<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">auto</span> childs = it.<span class="built_in">value</span>();</span><br><span class="line"></span><br><span class="line">        QJsonArray arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : childs) &#123;</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">convertToJson</span>(c);</span><br><span class="line">            arr.<span class="built_in">append</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        kvObj[tag] = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="type">void</span>) argc;</span><br><span class="line">    (<span class="type">void</span>) argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一份FStruct结构的数据</span></span><br><span class="line">    FStruct *root = <span class="keyword">new</span> FStruct;</span><br><span class="line">    root-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;);</span><br><span class="line">    &#123;</span><br><span class="line">        FStruct *node1 = <span class="keyword">new</span> FStruct;</span><br><span class="line">        node1-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>&#125;);</span><br><span class="line">        &#123;</span><br><span class="line">            FStruct *node2 = <span class="keyword">new</span> FStruct;</span><br><span class="line">            node2-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>&#125;);</span><br><span class="line">            node2-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>&#125;);</span><br><span class="line">            node1-&gt;childMap[<span class="string">&quot;node2&quot;</span>].<span class="built_in">push_back</span>(node2);</span><br><span class="line"></span><br><span class="line">            FStruct *node3 = <span class="keyword">new</span> FStruct;</span><br><span class="line">            node3-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>&#125;);</span><br><span class="line">            node3-&gt;list.<span class="built_in">push_back</span>(&#123;<span class="string">&quot;11&quot;</span>, <span class="string">&quot;12&quot;</span>&#125;);</span><br><span class="line">            node1-&gt;childMap[<span class="string">&quot;node2&quot;</span>].<span class="built_in">push_back</span>(node3);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;childMap.<span class="built_in">insert</span>(<span class="string">&quot;node1&quot;</span>, <span class="built_in">Childs</span>() &lt;&lt; node1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dumpFStruct</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成QJsonObject</span></span><br><span class="line">    <span class="keyword">auto</span> obj = <span class="built_in">convertToJson</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="built_in">isObject</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; obj.<span class="built_in">toObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>精确定位进程启动时间</title>
    <url>/2023/038289.html</url>
    <content><![CDATA[<p>在工作中分析系统启动时间分布时，需要精确到具体的进程在何时启动已经运行了多长时间，需要精确到秒甚至毫秒。</p>
<h1 id="通过ps查看精确时间"><a href="#通过ps查看精确时间" class="headerlink" title="通过ps查看精确时间"></a>通过ps查看精确时间</h1><p>熟悉 Linux 的同学都知道可以使用 <code>ps</code> 命令查看进程的基本信息。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/038289/1.png"
                       
                 ></p>
<p>然而，<code>ps</code> 命令默认只能精确到分钟级别，不能满足用户对进程信息输出更精细化的需求。不过，通过查看 <code>ps</code> 的 man 手册，可以发现它支持自定义输出格式，从而满足用户的需求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">o format</span><br><span class="line">              Specify user-defined format.  Identical to -o and --format.</span><br></pre></td></tr></table></figure>



<p><code>ps</code> 支持的自定义格式非常丰富，包括进程的 PID、PPID、CPU 占用率、内存占用率、启动时间、命令名称等等。虽然看起来有些复杂，但是实际上我们只需要掌握其中的几种格式即可满足大多数需求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">STANDARD FORMAT SPECIFIERS</span><br><span class="line">       Here are the different keywords that may be used to control the output format (e.g. with option -o) or to <span class="built_in">sort</span> the selected</span><br><span class="line">       processes with the GNU-style --<span class="built_in">sort</span> option.</span><br><span class="line"></span><br><span class="line">       For example: ps -eo pid,user,args --<span class="built_in">sort</span> user</span><br><span class="line"></span><br><span class="line">       This version of ps tries to recognize most of the keywords used <span class="keyword">in</span> other implementations of ps.</span><br><span class="line"></span><br><span class="line">       The following user-defined format specifiers may contain spaces: args, cmd, <span class="built_in">comm</span>, <span class="built_in">command</span>, fname, ucmd, ucomm,</span><br><span class="line">       lstart, bsdstart, start.</span><br><span class="line"></span><br><span class="line">       Some keywords may not be available <span class="keyword">for</span> sorting.</span><br><span class="line"></span><br><span class="line">       CODE        HEADER    DESCRIPTION</span><br><span class="line"></span><br><span class="line">       %cpu        %CPU      cpu utilization of the process <span class="keyword">in</span> <span class="string">&quot;##.#&quot;</span> format.  Currently, it is the CPU time used divided by the time</span><br><span class="line">                             the process has been running (cputime/realtime ratio), expressed as a percentage.  It will not add up to</span><br><span class="line">                             100% unless you are lucky.  (<span class="built_in">alias</span> pcpu).</span><br><span class="line"></span><br><span class="line">       %mem        %MEM      ratio of the process<span class="string">&#x27;s resident set size  to the physical memory on the machine, expressed as a</span></span><br><span class="line"><span class="string">                             percentage.  (alias pmem).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       args        COMMAND   command with all its arguments as a string. Modifications to the arguments may be shown.  The output in</span></span><br><span class="line"><span class="string">                             this column may contain spaces.  A process marked &lt;defunct&gt; is partly dead, waiting to be fully destroyed</span></span><br><span class="line"><span class="string">                             by its parent.  Sometimes the process args will be unavailable; when this happens, ps will instead print</span></span><br><span class="line"><span class="string">                             the executable name in brackets.  (alias cmd, command).  See also the comm format keyword, the -f option,</span></span><br><span class="line"><span class="string">                             and the c option.</span></span><br><span class="line"><span class="string">                             When specified last, this column will extend to the edge of the display.  If ps can not determine display</span></span><br><span class="line"><span class="string">                             width, as when output is redirected (piped) into a file or another command, the output width is undefined</span></span><br><span class="line"><span class="string">                             (it may be 80, unlimited, determined by the TERM variable, and so on).  The COLUMNS environment variable</span></span><br><span class="line"><span class="string">                             or --cols option may be used to exactly determine the width in this case.  The w or -w option may be also</span></span><br><span class="line"><span class="string">                             be used to adjust width.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       blocked     BLOCKED   mask of the blocked signals, see signal(7).  According to the width of the field, a 32 or 64-bit mask in</span></span><br><span class="line"><span class="string">                             hexadecimal format is displayed.  (alias sig_block, sigmask).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       bsdstart    START     time the command started.  If the process was started less than 24 hours ago, the output format is</span></span><br><span class="line"><span class="string">                             &quot; HH:MM&quot;, else it is &quot; Mmm:SS&quot; (where Mmm is the three letters of the month).  See also</span></span><br><span class="line"><span class="string">                             lstart, start, start_time, and stime.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       bsdtime     TIME      accumulated cpu time, user + system.  The display format is usually &quot;MMM:SS&quot;, but can be shifted to the</span></span><br><span class="line"><span class="string">                             right if the process used more than 999 minutes of cpu time.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       c           C         processor utilization. Currently, this is the integer value of the percent usage over the lifetime of the</span></span><br><span class="line"><span class="string">                             process.  (see %cpu).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       caught      CAUGHT    mask of the caught signals, see signal(7).  According to the width of the field, a 32 or 64 bits mask in</span></span><br><span class="line"><span class="string">                             hexadecimal format is displayed.  (alias sig_catch, sigcatch).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cgname      CGNAME    display name of control groups to which the process belongs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cgroup      CGROUP    display control groups to which the process belongs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       class       CLS       scheduling class of the process.  (alias policy, cls).  Field&#x27;</span>s possible values are:</span><br><span class="line"></span><br><span class="line">                                      -   not reported</span><br><span class="line">                                      TS  SCHED_OTHER</span><br><span class="line">                                      FF  SCHED_FIFO</span><br><span class="line">                                      RR  SCHED_RR</span><br><span class="line">                                      B   SCHED_BATCH</span><br><span class="line">                                      ISO SCHED_ISO</span><br><span class="line">                                      IDL SCHED_IDLE</span><br><span class="line">                                      DLN SCHED_DEADLINE</span><br><span class="line">                                      ?   unknown value</span><br><span class="line"></span><br><span class="line">       cls         CLS       scheduling class of the process.  (<span class="built_in">alias</span> policy, cls).  Field<span class="string">&#x27;s possible values are:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                      -   not reported</span></span><br><span class="line"><span class="string">                                      TS  SCHED_OTHER</span></span><br><span class="line"><span class="string">                                      FF  SCHED_FIFO</span></span><br><span class="line"><span class="string">                                      RR  SCHED_RR</span></span><br><span class="line"><span class="string">                                      B   SCHED_BATCH</span></span><br><span class="line"><span class="string">                                      ISO SCHED_ISO</span></span><br><span class="line"><span class="string">                                      IDL SCHED_IDLE</span></span><br><span class="line"><span class="string">                                      DLN SCHED_DEADLINE</span></span><br><span class="line"><span class="string">                                      ?   unknown value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cmd         CMD       see args.  (alias args, command).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       comm        COMMAND   command name (only the executable name).  Modifications to the command name will not be shown.  A process</span></span><br><span class="line"><span class="string">                             marked &lt;defunct&gt; is partly dead, waiting to be fully destroyed by its parent.  The output in this column</span></span><br><span class="line"><span class="string">                             may contain spaces.  (alias ucmd, ucomm).  See also the args format keyword, the -f option, and the c</span></span><br><span class="line"><span class="string">                             option.</span></span><br><span class="line"><span class="string">                             When specified last, this column will extend to the edge of the display.  If ps can not determine display</span></span><br><span class="line"><span class="string">                             width, as when output is redirected (piped) into a file or another command, the output width is undefined</span></span><br><span class="line"><span class="string">                             (it may be 80, unlimited, determined by the TERM variable, and so on).  The COLUMNS environment variable</span></span><br><span class="line"><span class="string">                             or --cols option may be used to exactly determine the width in this case.  The w or -w option may be also</span></span><br><span class="line"><span class="string">                             be used to adjust width.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       command     COMMAND   See args.  (alias args, command).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cp          CP        per-mill (tenths of a percent) CPU usage.  (see %cpu).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cputime     TIME      cumulative CPU time, &quot;[DD-]hh:mm:ss&quot; format.  (alias time).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       cputimes    TIME      cumulative CPU time in seconds (alias times).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       drs         DRS       data resident set size, the amount of physical memory devoted to other than executable code.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       egid        EGID      effective group ID number of the process as a decimal integer.  (alias gid).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       egroup      EGROUP    effective group ID of the process.  This will be the textual group ID, if it can be obtained and the</span></span><br><span class="line"><span class="string">                             field width permits, or a decimal representation otherwise.  (alias group).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       eip         EIP       instruction pointer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       esp         ESP       stack pointer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       etime       ELAPSED   elapsed time since the process was started, in the form [[DD-]hh:]mm:ss.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       etimes      ELAPSED   elapsed time since the process was started, in seconds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       euid        EUID      effective user ID (alias uid).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       euser       EUSER     effective user name.  This will be the textual user ID, if it can be obtained and the field width</span></span><br><span class="line"><span class="string">                             permits, or a decimal representation otherwise.  The n option can be used to force the decimal</span></span><br><span class="line"><span class="string">                             representation.  (alias uname, user).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       f           F         flags associated with the process, see the PROCESS FLAGS section.  (alias flag, flags).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       fgid        FGID      filesystem access group ID.  (alias fsgid).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       fgroup      FGROUP    filesystem access group ID.  This will be the textual group ID, if it can be obtained and the field width</span></span><br><span class="line"><span class="string">                             permits, or a decimal representation otherwise.  (alias fsgroup).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       flag        F         see f.  (alias f, flags).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       flags       F         see f.  (alias f, flag).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       fname       COMMAND   first 8 bytes of the base name of the process&#x27;</span>s executable file.  The output <span class="keyword">in</span> this column may contain</span><br><span class="line">                             spaces.</span><br><span class="line"></span><br><span class="line">       fuid        FUID      filesystem access user ID.  (<span class="built_in">alias</span> fsuid).</span><br><span class="line"></span><br><span class="line">       fuser       FUSER     filesystem access user ID.  This will be the textual user ID, <span class="keyword">if</span> it can be obtained and the field width</span><br><span class="line">                             permits, or a decimal representation otherwise.</span><br><span class="line"></span><br><span class="line">       gid         GID       see egid.  (<span class="built_in">alias</span> egid).</span><br><span class="line"></span><br><span class="line">       group       GROUP     see egroup.  (<span class="built_in">alias</span> egroup).</span><br><span class="line"></span><br><span class="line">       ignored     IGNORED   mask of the ignored signals, see signal(7).  According to the width of the field, a 32 or 64 bits mask <span class="keyword">in</span></span><br><span class="line">                             hexadecimal format is displayed.  (<span class="built_in">alias</span> sig_ignore, sigignore).</span><br><span class="line"></span><br><span class="line">       ipcns       IPCNS     Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       label       LABEL     security label, most commonly used <span class="keyword">for</span> SELinux context data.  This is <span class="keyword">for</span> the Mandatory Access Control</span><br><span class="line">                             (<span class="string">&quot;MAC&quot;</span>) found on high-security systems.</span><br><span class="line"></span><br><span class="line">       lstart      STARTED   time the <span class="built_in">command</span> started.  See also bsdstart, start, start_time, and stime.</span><br><span class="line"></span><br><span class="line">       lsession    SESSION   displays the login session identifier of a process, <span class="keyword">if</span> systemd support has been included.</span><br><span class="line"></span><br><span class="line">       luid        LUID      displays Login ID associated with a process.</span><br><span class="line"></span><br><span class="line">       lwp         LWP       light weight process (thread) ID of the dispatchable entity (<span class="built_in">alias</span> spid, tid).  See tid <span class="keyword">for</span> additional</span><br><span class="line">                             information.</span><br><span class="line"></span><br><span class="line">       lxc         LXC       The name of the lxc container within <span class="built_in">which</span> a task is running.  If a process is not running inside a</span><br><span class="line">                             container, a dash (<span class="string">&#x27;-&#x27;</span>) will be shown.</span><br><span class="line"></span><br><span class="line">       machine     MACHINE   displays the machine name <span class="keyword">for</span> processes assigned to VM or container, <span class="keyword">if</span> systemd support has been</span><br><span class="line">                             included.</span><br><span class="line"></span><br><span class="line">       maj_flt     MAJFLT    The number of major page faults that have occurred with this process.</span><br><span class="line"></span><br><span class="line">       min_flt     MINFLT    The number of minor page faults that have occurred with this process.</span><br><span class="line"></span><br><span class="line">       mntns       MNTNS     Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       netns       NETNS     Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       ni          NI        <span class="built_in">nice</span> value. This ranges from 19 (nicest) to -20 (not <span class="built_in">nice</span> to others), see <span class="built_in">nice</span>(1).  (<span class="built_in">alias</span> <span class="built_in">nice</span>).</span><br><span class="line"></span><br><span class="line">       <span class="built_in">nice</span>        NI        see ni.(<span class="built_in">alias</span> ni).</span><br><span class="line"></span><br><span class="line">       nlwp        NLWP      number of lwps (threads) <span class="keyword">in</span> the process.  (<span class="built_in">alias</span> thcount).</span><br><span class="line"></span><br><span class="line">       numa        NUMA      The node assocated with the most recently used processor.  A -1 means that NUMA information is</span><br><span class="line">                             unavailable.</span><br><span class="line"></span><br><span class="line">       nwchan      WCHAN     address of the kernel <span class="keyword">function</span> <span class="built_in">where</span> the process is sleeping (use wchan <span class="keyword">if</span> you want the kernel <span class="keyword">function</span></span><br><span class="line">                             name).  Running tasks will display a dash (<span class="string">&#x27;-&#x27;</span>) <span class="keyword">in</span> this column.</span><br><span class="line"></span><br><span class="line">       ouid        OWNER     displays the Unix user identifier of the owner of the session of a process, <span class="keyword">if</span> systemd support has been</span><br><span class="line">                             included.</span><br><span class="line"></span><br><span class="line">       pcpu        %CPU      see %cpu.  (<span class="built_in">alias</span> %cpu).</span><br><span class="line"></span><br><span class="line">       pending     PENDING   mask of the pending signals. See signal(7).  Signals pending on the process are distinct from signals</span><br><span class="line">                             pending on individual threads.  Use the m option or the -m option to see both.  According to the width of</span><br><span class="line">                             the field, a 32 or 64 bits mask <span class="keyword">in</span> hexadecimal format is displayed.  (<span class="built_in">alias</span> sig).</span><br><span class="line"></span><br><span class="line">       pgid        PGID      process group ID or, equivalently, the process ID of the process group leader.  (<span class="built_in">alias</span> pgrp).</span><br><span class="line"></span><br><span class="line">       pgrp        PGRP      see pgid.  (<span class="built_in">alias</span> pgid).</span><br><span class="line"></span><br><span class="line">       pid         PID       a number representing the process ID (<span class="built_in">alias</span> tgid).</span><br><span class="line"></span><br><span class="line">       pidns       PIDNS     Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       pmem        %MEM      see %mem.  (<span class="built_in">alias</span> %mem).</span><br><span class="line"></span><br><span class="line">       policy      POL       scheduling class of the process.  (<span class="built_in">alias</span> class, cls).  Possible values are:</span><br><span class="line"></span><br><span class="line">                                      -   not reported</span><br><span class="line">                                      TS  SCHED_OTHER</span><br><span class="line">                                      FF  SCHED_FIFO</span><br><span class="line">                                      RR  SCHED_RR</span><br><span class="line">                                      B   SCHED_BATCH</span><br><span class="line">                                      ISO SCHED_ISO</span><br><span class="line">                                      IDL SCHED_IDLE</span><br><span class="line">                                      DLN SCHED_DEADLINE</span><br><span class="line">                                      ?   unknown value</span><br><span class="line"></span><br><span class="line">       ppid        PPID      parent process ID.</span><br><span class="line"></span><br><span class="line">       pri         PRI       priority of the process.  Higher number means lower priority.</span><br><span class="line"></span><br><span class="line">       psr         PSR       processor that process is currently assigned to.</span><br><span class="line"></span><br><span class="line">       rgid        RGID      real group ID.</span><br><span class="line"></span><br><span class="line">       rgroup      RGROUP    real group name.  This will be the textual group ID, <span class="keyword">if</span> it can be obtained and the field width permits,</span><br><span class="line">                             or a decimal representation otherwise.</span><br><span class="line"></span><br><span class="line">       rss         RSS       resident <span class="built_in">set</span> size, the non-swapped physical memory that a task has used (<span class="keyword">in</span> kiloBytes).  (<span class="built_in">alias</span></span><br><span class="line">                             rssize, rsz).</span><br><span class="line"></span><br><span class="line">       rssize      RSS       see rss.  (<span class="built_in">alias</span> rss, rsz).</span><br><span class="line"></span><br><span class="line">       rsz         RSZ       see rss.  (<span class="built_in">alias</span> rss, rssize).</span><br><span class="line"></span><br><span class="line">       rtprio      RTPRIO    realtime priority.</span><br><span class="line"></span><br><span class="line">       ruid        RUID      real user ID.</span><br><span class="line"></span><br><span class="line">       ruser       RUSER     real user ID.  This will be the textual user ID, <span class="keyword">if</span> it can be obtained and the field width permits, or a</span><br><span class="line">                             decimal representation otherwise.</span><br><span class="line"></span><br><span class="line">       s           S         minimal state display (one character).  See section PROCESS STATE CODES <span class="keyword">for</span> the different values.  See</span><br><span class="line">                             also <span class="built_in">stat</span> <span class="keyword">if</span> you want additional information displayed.  (<span class="built_in">alias</span> state).</span><br><span class="line"></span><br><span class="line">       <span class="built_in">sched</span>       SCH       scheduling policy of the process.  The policies SCHED_OTHER (SCHED_NORMAL), SCHED_FIFO, SCHED_RR,</span><br><span class="line">                             SCHED_BATCH, SCHED_ISO, SCHED_IDLE and SCHED_DEADLINE are respectively displayed as 0, 1, 2, 3, 4, 5 and</span><br><span class="line">                             6.</span><br><span class="line"></span><br><span class="line">       seat        SEAT      displays the identifier associated with all hardware devices assigned to a specific workplace, <span class="keyword">if</span> systemd</span><br><span class="line">                             support has been included.</span><br><span class="line"></span><br><span class="line">       sess        SESS      session ID or, equivalently, the process ID of the session leader.  (<span class="built_in">alias</span> session, sid).</span><br><span class="line"></span><br><span class="line">       sgi_p       P         processor that the process is currently executing on.  Displays <span class="string">&quot;*&quot;</span> <span class="keyword">if</span> the process is not currently</span><br><span class="line">                             running or runnable.</span><br><span class="line"></span><br><span class="line">       sgid        SGID      saved group ID.  (<span class="built_in">alias</span> svgid).</span><br><span class="line"></span><br><span class="line">       sgroup      SGROUP    saved group name.  This will be the textual group ID, <span class="keyword">if</span> it can be obtained and the field width permits,</span><br><span class="line">                             or a decimal representation otherwise.</span><br><span class="line"></span><br><span class="line">       sid         SID       see sess.  (<span class="built_in">alias</span> sess, session).</span><br><span class="line"></span><br><span class="line">       sig         PENDING   see pending.  (<span class="built_in">alias</span> pending, sig_pend).</span><br><span class="line"></span><br><span class="line">       sigcatch    CAUGHT    see caught.  (<span class="built_in">alias</span> caught, sig_catch).</span><br><span class="line"></span><br><span class="line">       sigignore   IGNORED   see ignored.  (<span class="built_in">alias</span> ignored, sig_ignore).</span><br><span class="line"></span><br><span class="line">       sigmask     BLOCKED   see blocked.  (<span class="built_in">alias</span> blocked, sig_block).</span><br><span class="line"></span><br><span class="line">       size        SIZE      approximate amount of swap space that would be required <span class="keyword">if</span> the process were to dirty all writable pages</span><br><span class="line">                             and <span class="keyword">then</span> be swapped out.  This number is very rough!</span><br><span class="line"></span><br><span class="line">       slice       SLICE     displays the slice unit <span class="built_in">which</span> a process belongs to, <span class="keyword">if</span> systemd support has been included.</span><br><span class="line"></span><br><span class="line">       spid        SPID      see lwp.  (<span class="built_in">alias</span> lwp, tid).</span><br><span class="line"></span><br><span class="line">       stackp      STACKP    address of the bottom (start) of stack <span class="keyword">for</span> the process.</span><br><span class="line"></span><br><span class="line">       start       STARTED   time the <span class="built_in">command</span> started.  If the process was started less than 24 hours ago, the output format is</span><br><span class="line">                             <span class="string">&quot;HH:MM:SS&quot;</span>, <span class="keyword">else</span> it is <span class="string">&quot;  Mmm dd&quot;</span> (<span class="built_in">where</span> Mmm is a three-letter month name).  See also</span><br><span class="line">                             lstart, bsdstart, start_time, and stime.</span><br><span class="line"></span><br><span class="line">       start_time  START     starting time or <span class="built_in">date</span> of the process.  Only the year will be displayed <span class="keyword">if</span> the process was not started the</span><br><span class="line">                             same year ps was invoked, or <span class="string">&quot;MmmDD&quot;</span> <span class="keyword">if</span> it was not started the same day, or <span class="string">&quot;HH:MM&quot;</span> otherwise.  See also</span><br><span class="line">                             bsdstart, start, lstart, and stime.</span><br><span class="line"></span><br><span class="line">       <span class="built_in">stat</span>        STAT      multi-character process state.  See section PROCESS STATE CODES <span class="keyword">for</span> the different values meaning.  See</span><br><span class="line">                             also s and state <span class="keyword">if</span> you just want the first character displayed.</span><br><span class="line"></span><br><span class="line">       state       S         see s. (<span class="built_in">alias</span> s).</span><br><span class="line"></span><br><span class="line">       suid        SUID      saved user ID.  (<span class="built_in">alias</span> svuid).</span><br><span class="line"></span><br><span class="line">       supgid      SUPGID    group ids of supplementary <span class="built_in">groups</span>, <span class="keyword">if</span> any.  See getgroups(2).</span><br><span class="line"></span><br><span class="line">       supgrp      SUPGRP    group names of supplementary <span class="built_in">groups</span>, <span class="keyword">if</span> any.  See getgroups(2).</span><br><span class="line"></span><br><span class="line">       suser       SUSER     saved user name.  This will be the textual user ID, <span class="keyword">if</span> it can be obtained and the field width permits, or</span><br><span class="line">                             a decimal representation otherwise.  (<span class="built_in">alias</span> svuser).</span><br><span class="line"></span><br><span class="line">       svgid       SVGID     see sgid.  (<span class="built_in">alias</span> sgid).</span><br><span class="line"></span><br><span class="line">       svuid       SVUID     see suid.  (<span class="built_in">alias</span> suid).</span><br><span class="line"></span><br><span class="line">       sz          SZ        size <span class="keyword">in</span> physical pages of the core image of the process.  This includes text, data, and stack space.</span><br><span class="line">                             Device mappings are currently excluded; this is subject to change.  See vsz and rss.</span><br><span class="line"></span><br><span class="line">       tgid        TGID      a number representing the thread group to <span class="built_in">which</span> a task belongs (<span class="built_in">alias</span> pid).  It is the process ID of the</span><br><span class="line">                             thread group leader.</span><br><span class="line"></span><br><span class="line">       thcount     THCNT     see nlwp.  (<span class="built_in">alias</span> nlwp).  number of kernel threads owned by the process.</span><br><span class="line"></span><br><span class="line">       tid         TID       the unique number representing a dispatchable entity (<span class="built_in">alias</span> lwp, spid).  This value may also appear as: a</span><br><span class="line">                             process ID (pid); a process group ID (pgrp); a session ID <span class="keyword">for</span> the session leader (sid); a thread group ID</span><br><span class="line">                             <span class="keyword">for</span> the thread group leader (tgid); and a <span class="built_in">tty</span> process group ID <span class="keyword">for</span> the process group leader (tpgid).</span><br><span class="line"></span><br><span class="line">       time        TIME      cumulative CPU time, <span class="string">&quot;[DD-]HH:MM:SS&quot;</span> format.  (<span class="built_in">alias</span> cputime).</span><br><span class="line"></span><br><span class="line">       <span class="built_in">times</span>       TIME      cumulative CPU time <span class="keyword">in</span> seconds (<span class="built_in">alias</span> cputimes).</span><br><span class="line"></span><br><span class="line">       tname       TTY       controlling <span class="built_in">tty</span> (terminal).  (<span class="built_in">alias</span> tt, <span class="built_in">tty</span>).</span><br><span class="line"></span><br><span class="line">       tpgid       TPGID     ID of the foreground process group on the <span class="built_in">tty</span> (terminal) that the process is connected to, or -1 <span class="keyword">if</span> the</span><br><span class="line">                             process is not connected to a <span class="built_in">tty</span>.</span><br><span class="line"></span><br><span class="line">       trs         TRS       text resident <span class="built_in">set</span> size, the amount of physical memory devoted to executable code.</span><br><span class="line"></span><br><span class="line">       tt          TT        controlling <span class="built_in">tty</span> (terminal).  (<span class="built_in">alias</span> tname, <span class="built_in">tty</span>).</span><br><span class="line"></span><br><span class="line">       <span class="built_in">tty</span>         TT        controlling <span class="built_in">tty</span> (terminal).  (<span class="built_in">alias</span> tname, tt).</span><br><span class="line"></span><br><span class="line">       ucmd        CMD       see <span class="built_in">comm</span>.  (<span class="built_in">alias</span> <span class="built_in">comm</span>, ucomm).</span><br><span class="line"></span><br><span class="line">       ucomm       COMMAND   see <span class="built_in">comm</span>.  (<span class="built_in">alias</span> <span class="built_in">comm</span>, ucmd).</span><br><span class="line"></span><br><span class="line">       uid         UID       see euid.  (<span class="built_in">alias</span> euid).</span><br><span class="line"></span><br><span class="line">       <span class="built_in">uname</span>       USER      see euser.  (<span class="built_in">alias</span> euser, user).</span><br><span class="line"></span><br><span class="line">       unit        UNIT      displays unit <span class="built_in">which</span> a process belongs to, <span class="keyword">if</span> systemd support has been included.</span><br><span class="line"></span><br><span class="line">       user        USER      see euser.  (<span class="built_in">alias</span> euser, <span class="built_in">uname</span>).</span><br><span class="line"></span><br><span class="line">       userns      USERNS    Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       utsns       UTSNS     Unique inode number describing the namespace the process belongs to. See namespaces(7).</span><br><span class="line"></span><br><span class="line">       uunit       UUNIT     displays user unit <span class="built_in">which</span> a process belongs to, <span class="keyword">if</span> systemd support has been included.</span><br><span class="line"></span><br><span class="line">       vsize       VSZ       see vsz.  (<span class="built_in">alias</span> vsz).</span><br><span class="line"></span><br><span class="line">       vsz         VSZ       virtual memory size of the process <span class="keyword">in</span> KiB (1024-byte units).  Device mappings are currently excluded;</span><br><span class="line">                             this is subject to change.  (<span class="built_in">alias</span> vsize).</span><br><span class="line"></span><br><span class="line">       wchan       WCHAN     name of the kernel <span class="keyword">function</span> <span class="keyword">in</span> <span class="built_in">which</span> the process is sleeping, a <span class="string">&quot;-&quot;</span> <span class="keyword">if</span> the process is running, or a <span class="string">&quot;*&quot;</span></span><br><span class="line">                             <span class="keyword">if</span> the process is multi-threaded and ps is not displaying threads.</span><br></pre></td></tr></table></figure>



<p>其中，<code>lstart</code> 表示进程的启动时间。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/038289/2.png"
                       
                 ></p>
<p>通过使用 <code>ps</code> 命令的自定义输出格式，我们可以查看进程的启动时间和运行时长等详细信息。例如，使用命令 <code>ps -eo pid,cmd,lstart,etime</code> 可以查看进程的 PID、命令名称、启动时间和运行时长等信息。从输出结果可以看到 <code>/usr/bin/dde-dock</code> 进程的启动时间是 24 日 09:14:48，程序已经运行了 6 小时 25 分 29 秒。</p>
<p>由于 <code>ps</code> 命令的自定义输出格式比较复杂，刚开始可能需要多次使用才能熟练掌握。因此，建议多使用几遍，加深对命令的理解和记忆。</p>
<h1 id="查看cmdline创建时间"><a href="#查看cmdline创建时间" class="headerlink" title="查看cmdline创建时间"></a>查看cmdline创建时间</h1><p>我们可以通过查看 <code>/proc</code> 目录下进程文件的创建时间来获取精确到秒的进程启动时间，因此，即使 <code>ps</code> 命令输出的时间只能精确到分钟，我们依然可以通过这种方式来获取更加精确的时间信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> /proc/`pidof dde-dock`/cmdline</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/038289/3.png"
                       
                 ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>系统抑制锁</title>
    <url>/2023/0239366.html</url>
    <content><![CDATA[<p>Systemd的183或更新的版本包含了一个逻辑来阻止系统进入关闭和睡眠状态。由systemd-logind.daemon进行了实现。</p>
<span id="more"></span>

<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>1.CD 刻录应用程序希望确保系统在刻录过程中不会关闭或挂起</p>
<p>2.包管理员希望确保在包升级过程中系统不会关闭</p>
<p>3.办公套件希望在系统挂起之前得到通知，以便将所有数据保存到磁盘，并延迟挂起逻辑，直到所有数据写入</p>
<p>4.Web 浏览器希望在系统休眠之前得到通知，以便释放其缓存以最小化需要虚拟化的内存量</p>
<p>5.屏幕锁定工具想要在挂起之前立即调出屏幕锁定，并延迟挂起直到挂起完成。想要使用禁止逻辑的应用程序应通过<a class="link"   href="http://www.freedesktop.org/wiki/Software/systemd/logind" >登录 D-Bus API<i class="fas fa-external-link-alt"></i></a>获取抑制锁。</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>抑制锁共有7中类型，可以采用其一或者他们的组合：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>sleep</em></td>
<td>禁止（非特权）用户请求的系统挂起和休眠</td>
</tr>
<tr>
<td><em>shutdown</em></td>
<td>禁止（非特权）用户请求的高级系统关闭和重启</td>
</tr>
<tr>
<td><em>idle</em></td>
<td>禁止系统进入空闲模式，可能导致系统自动挂起或关闭，具体取决于配置</td>
</tr>
<tr>
<td><em>handle-power-key</em></td>
<td>禁止系统电源硬件密钥的低级（即登录内部）处理，允许（可能是非特权的）外部代码来处理事件。</td>
</tr>
<tr>
<td><em>handle-suspend-key</em></td>
<td>禁止对系统硬件挂起键进行低级处理。</td>
</tr>
<tr>
<td><em>handle-hibernate-key</em></td>
<td>禁止对系统硬件休眠键进行低级处理。</td>
</tr>
<tr>
<td><em>handle-lid-switch</em></td>
<td>禁止对 systemd 硬件盖(例如，笔记本合盖开盖)开关进行低级处理。</td>
</tr>
</tbody></table>
<p>支持两种不同的锁模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>block</em></td>
<td>完全禁止操作，直到锁被释放。如果使用这样的锁，操作将失败（但如果用户拥有必要的权限，则仍可能被覆盖）</td>
</tr>
<tr>
<td><em>delay</em></td>
<td>仅暂时禁止操作，直到释放锁或达到一定时间。 logind.conf(5) 中的 InhibitDelayMaxSec字段可以控制超时时长。 这旨在供需要在系统挂起之前同步执行操作但又不允许无限期地阻止挂起的应用程序使用。 此模式仅适用于睡眠和关机锁。</td>
</tr>
</tbody></table>
<h1 id="DBus"><a href="#DBus" class="headerlink" title="DBus"></a>DBus</h1><p>抑制器锁是通过调用logind Manager对象的 Inhibit() D-Bus方法获取的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdbus introspect --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1</span><br><span class="line">node /org/freedesktop/login1 &#123;</span><br><span class="line">  interface org.freedesktop.login1.Manager &#123;</span><br><span class="line">    methods:</span><br><span class="line">      Inhibit(<span class="keyword">in</span>  s what,</span><br><span class="line">              <span class="keyword">in</span>  s <span class="built_in">who</span>,</span><br><span class="line">              <span class="keyword">in</span>  s why,</span><br><span class="line">              <span class="keyword">in</span>  s mode,</span><br><span class="line">              out h fd);</span><br><span class="line">      ListInhibitors(out a(ssssuu) inhibitors);</span><br><span class="line">      ...</span><br><span class="line">    signals:</span><br><span class="line">      PrepareForShutdown(b active);</span><br><span class="line">      PrepareForSleep(b active);</span><br><span class="line">      ...</span><br><span class="line">    properties:</span><br><span class="line">      <span class="built_in">readonly</span> s BlockInhibited = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="built_in">readonly</span> s DelayInhibited = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="built_in">readonly</span> t InhibitDelayMaxUSec = 5000000;</span><br><span class="line">      <span class="built_in">readonly</span> b PreparingForShutdown = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">readonly</span> b PreparingForSleep = <span class="literal">false</span>;</span><br><span class="line">      ...</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Inhibit"><a href="#Inhibit" class="headerlink" title="Inhibit"></a>Inhibit</h2><p>Inhibit方法是获取锁所需的唯一 API。它需要四个参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>What</em></td>
<td>冒号分隔的锁类型列表，即shutdown, sleep, idle, handle-power-key, handle-suspend-key, handle-hibernate-key, handle-lid-switch. 例如: “shutdown:idle”</td>
</tr>
<tr>
<td><em>Who</em></td>
<td>是一个人类可读的描述性字符串，说明谁在拿锁。示例：“包更新程序”</td>
</tr>
<tr>
<td><em>Why</em></td>
<td>是一个人类可读的描述性字符串，说明为什么要锁定。示例：“包更新正在进行中”</td>
</tr>
<tr>
<td><em>Mode</em></td>
<td>模式是block或delay中的一个，见上文描述。示例：“block”</td>
</tr>
</tbody></table>
<p>调用Inhibit后会返回一个值，这是一个封装锁的文件描述符。 一旦文件描述符（及其所有副本）关闭，锁就会自动释放。 如果客户端在获取锁时死亡，内核会自动关闭文件描述符，以便自动释放锁。 采用这种方式的延迟锁应该在收到 PrepareForShutdown(true)（见下文）时尽快释放。<br>（当然只有在执行了应用程序首先想要延迟操作的操作之后)。</p>
<h2 id="ListInhibitors"><a href="#ListInhibitors" class="headerlink" title="ListInhibitors"></a>ListInhibitors</h2><p>ListInhibitors列出所有当前活动的抑制剂锁。它返回一个结构数组，每个结构由上面的 What、Who、Why、Mode 以及请求锁的进程的 PID 和 UID 组成。</p>
<p>PrepareForShutdown() 和 PrepareForSleep() 信号在请求系统挂起或关闭并即将执行时发出，以及在挂起&#x2F;关闭完成（或失败）之后发出。 这些信号带有一个布尔参数。 如果为 True，则已请求关闭&#x2F;睡眠，并开始准备阶段，如果为 False，则操作已完成（或失败）。 如果为 True，这应该用作应用程序在挂起&#x2F;关闭之前快速执行它们想要执行的操作的指示，然后释放所采取的任何延迟锁定。 如果为 False，则挂起&#x2F;关闭操作结束，无论是成功还是失败（当然，如果关闭请求成功，则永远不会发送此信号）。 带有 False 的信号通常只有在系统从挂起状态恢复后才会被传送，带有 True 的信号也可能是这样，例如当一开始没有延迟锁定时，系统挂起因此没有任何延迟地执行。 带有 False 的信号通常是应用程序请求新延迟锁定的信号，以便同步通知下一个挂起&#x2F;关闭周期。 </p>
<p>请注意，在不使用延迟锁的情况下观看 PrepareForShutdown(true)?&#x2F;PrepareForSleep(true) 是活泼的，不应该这样做，因为应用程序可能希望在此信号上执行的任何代码在挂起&#x2F;关闭周期之前实际上可能不会完成执行。 </p>
<p>再次重申：如果您观察 PrepareForSuspend(true)，那么您真的应该先进行延迟锁定。 PrepareForShutdown(false) 可以由希望收到系统恢复事件通知的应用程序订阅。 </p>
<p>请注意，这将仅针对通过登录完成的挂起&#x2F;恢复周期发送，即通常仅针对高级用户引发的挂起周期，而不是自动的、低级内核引发的暂停周期，这些暂停周期可能存在于某些具有更强大功能的设备上 管理。</p>
<h2 id="BlockInhibited-amp-DelayInhibited"><a href="#BlockInhibited-amp-DelayInhibited" class="headerlink" title="BlockInhibited &amp; DelayInhibited"></a>BlockInhibited &amp; DelayInhibited</h2><p>BlockInhibited 和 DelayInhibited 属性对当前使用的锁类型进行编码。</p>
<p>这些字段是以冒号分隔的shutdown, sleep, idle, handle-power-key, handle-suspend-key, handle-hibernate-key, handle-lid-switch 列表。</p>
<p>该列表基本上是特定模式的所有当前活动锁的 What 字段的联合。</p>
<h2 id="InhibitDelayMaxUSec"><a href="#InhibitDelayMaxUSec" class="headerlink" title="InhibitDelayMaxUSec"></a>InhibitDelayMaxUSec</h2><p>InhibitDelayMaxUSec 包含在 logind.conf（TODO） 中配置的延迟超时值。</p>
<h2 id="PreparingForShutdown-amp-PreparingForSleep"><a href="#PreparingForShutdown-amp-PreparingForSleep" class="headerlink" title="PreparingForShutdown &amp; PreparingForSleep"></a>PreparingForShutdown &amp; PreparingForSleep</h2><p>The <strong>PreparingForShutdown</strong> and <strong>PreparingForSleep</strong> boolean properties are true between the two PrepareForShutdown() resp PrepareForSleep() signals that are sent out.<br>需要注意的是，这两个属性的变化并不会触发PropertyChanged信号。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>以下是需要阻塞锁的应用程序的基本方案，例如包管理器或 CD 刻录应用程序：</p>
<p>1.获取锁</p>
<p>2.做你不想被系统睡眠或关机打断的工作</p>
<p>3.释放锁</p>
<p>示例伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = Inhibit(<span class="string">&quot;shutdown:idle&quot;</span>, <span class="string">&quot;Package Manager&quot;</span>, <span class="string">&quot;Upgrade in progress...&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line"><span class="comment">/* ...</span></span><br><span class="line"><span class="comment">do your work</span></span><br><span class="line"><span class="comment">... */</span></span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><p>以下是需要延迟锁的应用程序（例如 Web 浏览器或办公套件）的基本方案：</p>
<p>1.当你打开一个文件时，采取延迟锁定</p>
<p>2.一旦看到 PrepareForSleep(true)，保存数据，然后释放锁</p>
<p>3.一看到PrepareForSleep(false)，就重新拿delay lock，和之前一样继续。</p>
<p>示例伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">takeLock() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        fd = Inhibit(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;Word Processor&quot;</span>, <span class="string">&quot;Save any unsaved data in time...&quot;</span>, <span class="string">&quot;delay&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDocumentOpen(<span class="type">void</span>) &#123;</span><br><span class="line">        takeLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onPrepareForSleep(<span class="type">bool</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                saveData();</span><br><span class="line">                <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        close(fd);</span><br><span class="line">                        fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">                takeLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Key-Handling"><a href="#Key-Handling" class="headerlink" title="Key Handling"></a>Key Handling</h2><p>默认情况下，logind 将处理机器的电源和睡眠键，以及所有状态下的盖子开关。 这可确保此基本系统行为在所有情况下都能正常工作，包括文本控制台和所有图形环境。</p>
<p>然而，一些 DE 可能想要自己处理这些键，例如为了在执行相关操作之前显示一个漂亮的对话框，或者在某些条件下简单地禁用该操作。</p>
<p>对于这些情况，可以使用 handle-power-key、handle-suspend-key、handle-hibernate-key 和 handle-lid-switch 类型的抑制器锁。</p>
<p>获取时，这些锁只是禁用键的低级处理，它们对使用硬件键以外的其他机制执行的系统挂起&#x2F;休眠&#x2F;关机没有影响（例如用户在 shell 中键入“systemctl suspend”）。</p>
<p>打算自己处理这些密钥的 DE 应该简单地在登录时获取锁，并在注销时释放它们； 或者，在某些情况下仅暂时锁定此锁可能是有意义的（例如，仅在插入第二个显示器时才锁定盖子开关，以支持人们在连接大屏幕时关闭笔记本电脑的常见设置） .</p>
<p>这些锁需要以“block”模式获取，不支持“delay”。</p>
<p>如果 DE 想要确保在系统进入挂起状态之前屏幕上显示最终恢复的锁定屏幕，它应该通过挂起延迟抑制块（见上文）来实现。</p>
<h2 id="Miscellanea"><a href="#Miscellanea" class="headerlink" title="Miscellanea"></a>Miscellanea</h2><p>获取抑制锁是一项特权操作。取决于systemd安装的policy(org.freedesktop.login1.policy)策略中下列action的配置:</p>
<p><em>org.freedesktop.login1.inhibit-block-shutdown</em></p>
<p><em>org.freedesktop.login1.inhibit-delay-shutdown</em></p>
<p><em>org.freedesktop.login1.inhibit-block-sleep</em></p>
<p> <em>org.freedesktop.login1.inhibit-delay-sleep</em></p>
<p><em>org.freedesktop.login1.inhibit-block-idle</em></p>
<p><em>org.freedesktop.login1.inhibit-handle-power-key</em></p>
<p><em>org.freedesktop.login1.inhibit-handle-suspend-key</em></p>
<p><em>org.freedesktop.login1.inhibit-handle-hibernate-key</em></p>
<p><em>org.freedesktop.login1.inhibit-handle-lid-switch</em></p>
<p>一般来说，应该假设延迟锁比阻塞锁更容易获得，只是因为它们的影响要小得多。请注意，Inhibit() 的策略检查从不交互。<br>抑制器锁不应被滥用。例如，在没有充分理由的情况下使用空闲阻塞锁可能会导致移动设备永远不会自动挂起。这可能对电池非常不利。</p>
<p>如果应用程序发现锁被拒绝，它不应该认为这是一个错误，没有保护锁的情况下继续其操作即可<br>。<br>systemd-inhibit工具可用于从命令行获取锁或列出活动锁。</p>
<p>请注意，gnome-session 还提供了一个 inhibitor API，它与 systemd 的非常相似。 在内部，对 gnome-session 接口的锁定将转发给 logind，因此这两个 API 都受支持。 虽然两者都提供相似的功能，但它们在某些方面确实有所不同。 出于显而易见的原因，gnome-session 可以提供登录所缺少的注销锁定和屏幕保护程序避免锁定。 logind 的 API OTOH 除了像 GNOME 一样支持块锁外，还支持延迟锁。 此外，logind 可用于系统组件，并集中所有用户的锁，而不仅仅是特定用户的锁。</p>
<p>一般来说：如果有疑问，最好坚持使用 GNOME 锁，除非有充分的理由直接使用 logind API。 但是，当要枚举锁时，最好使用 logind API，因为它们还包括系统服务和其他用户获取的锁。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a class="link"   href="https://www.freedesktop.org/wiki/Software/systemd/inhibit/" >https://www.freedesktop.org/wiki/Software/systemd/inhibit/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.freedesktop.org/wiki/Software/systemd/logind/" >https://www.freedesktop.org/wiki/Software/systemd/logind/<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>systemd</tag>
        <tag>Freedesktop</tag>
      </tags>
  </entry>
  <entry>
    <title>系统鉴权-polkit</title>
    <url>/2022/1253439.html</url>
    <content><![CDATA[<p>如果您只是想了解如何让自己的应用的某些接口被调用时，需要用户验证身份后才能进行，请移步《应用如何发起鉴权》。<br>如果您想了解操作系统中的身份验证弹窗程序是如何工作的，请移步《鉴权验证程序》。</p>
<span id="more"></span>

<h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><p><code>action</code>:动作，本文中主要指应用在<code>policy</code>指定的某一操作。</p>
<h1 id="鉴权时序图"><a href="#鉴权时序图" class="headerlink" title="鉴权时序图"></a>鉴权时序图</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/1253439/sxt.png"
                       
                 ></p>
<p>在实际使用中，我们一般会设计两个进程，分别是普通的客户端进程Client和具有root权限的服务端进程Server。</p>
<p>1、当Client需要执行某些操作时，可以调用Server进程的接口实现，从而完成普通进程实现root权限才有的操作。</p>
<p>2、Server进程在设计接口时，为了安全考虑，首先会向polkitd进程查询此当前操作action(action在Server程序安装时被提供给polkitd)是否允许，并根据结果来决定调用者是否能完成此项操作</p>
<p>3、polkit再从policy文件根据action id找到其授权策略，如果存在rules&#x2F;pkla规则文件，将以规则文件中的授权策略为准，如果需要验证用户身份，agent进程此时会收到通知</p>
<p>4、agent进程在收到通知后，一般以弹窗的时候形式和用户产生交互，用户需要向agent证明自己的身份(polkit会通过PAM机制鉴别用户身份)</p>
<p>5、agent将验证用户身份的结果返回给polkitd，polkitd再返回给Server进程</p>
<p>6、Server根据结果决定此接口是否继续执行，从而完成一次完整的鉴权交互请求。</p>
<h1 id="应用如何发起鉴权"><a href="#应用如何发起鉴权" class="headerlink" title="应用如何发起鉴权"></a>应用如何发起鉴权</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在uos操作系统中，用户打开gparted程序，打算对磁盘的分区情况进行修改，但先出现的是如下界面，只有在输出密码正确的情况下，才允许用户使用gparted进行操作。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/1253439/uos.png"
                       
                 ></p>
<p>图1 UOS的鉴权管理验证程序</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>如果我们在设计gparted的时候，并不要求用户输入密码，打开就能使用，极有可能导致我们的电脑被别人借用时，误删了磁盘分区，导致系统无法启动。</p>
<p>鉴权机制就可以很好的避免的这一点，在运行前，gparted软件会通过polkit机制验证使用者的身份，确保使用者身份是”可信”的，才会对本次动作放行。</p>
<h2 id="策略文件安装"><a href="#策略文件安装" class="headerlink" title="策略文件安装"></a>策略文件安装</h2><p><code>polkit</code>是一个很简单的机制，但经过了很多年的发展，寥寥几句无法说得很清楚，这里只介绍如何利用这种机制，避免高权限操作被低权限进程随意调用导致的安全问题。</p>
<p>在polkit中，每一个操作称为一个<code>action</code>，可以使用<code>pkaction</code>查看系统中已经安装的policy策略，action被定义在policy策略文件中。这是一个xml格式的文件，以<code>.policy</code>结尾。下面的策略文件，我们在策略文件中定义了两个操作，分别是<code>com.deepin.polkit.demo.fun1</code>和<code>com.deepin.polkit.demo.fun2</code>，其中<code>com.deepin.polkit.demo.fun1</code>默认允许，<code>com.deepin.polkit.demo.fun2</code>需要进行管理员身份验证。(policy文件的字段描述见<a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html" >polkit<i class="fas fa-external-link-alt"></i></a>的<code>DECLARING ACTIONS</code>一章)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">policyconfig</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//freedesktop//DTD PolicyKit Policy Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://www.freedesktop.org/standards/PolicyKit/1.0/policyconfig.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">policyconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">&quot;com.deepin.polkit.demo.fun1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>echo hello<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span>Operation1<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">xml:lang</span>=<span class="string">&quot;zh_CN&quot;</span>&gt;</span>操作1<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaults</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">allow_inactive</span>&gt;</span>no<span class="tag">&lt;/<span class="name">allow_inactive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">allow_active</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">allow_active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaults</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">&quot;com.deepin.polkit.demo.fun2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>write file to /etc<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span>Operation2<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">xml:lang</span>=<span class="string">&quot;zh_CN&quot;</span>&gt;</span>操作2<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaults</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">allow_inactive</span>&gt;</span>no<span class="tag">&lt;/<span class="name">allow_inactive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">allow_active</span>&gt;</span>auth_admin<span class="tag">&lt;/<span class="name">allow_active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaults</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">policyconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以将<code>allow_active</code>设置为<code>auth_self</code>，将只允许当前用户进行验证。<code>auth_admin</code>意味这电脑上所有的管理员账户都可以验证。如果设置为<code>yes</code>则表示此动作默认允许。</p>
<p>定义好应用将来要提权的<code>action</code>后，需要将此<code>xml</code>文件放置到<code>/usr/share/polkit-1/actions</code>目录中，这也是polkit要求的固定路径。</p>
<h2 id="配置字段"><a href="#配置字段" class="headerlink" title="配置字段"></a>配置字段</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>allow_inactive</td>
<td>表示在用户未登录的情况下，是否允许执行该操作。如果该字段被设置为true，则即使用户未登录，也允许执行该操作</td>
</tr>
<tr>
<td>allow_active</td>
<td>表示在活动会话中进行授权的操作</td>
</tr>
<tr>
<td>allow_any</td>
<td>表示在用户未经过身份验证的情况下，是否允许执行该操作。如果该字段被设置为true，则即使用户未经过身份验证，也允许执行该操作</td>
</tr>
</tbody></table>
<p>区别在于，allow_inactive只涉及用户是否登录，而allow_any涉及用户是否经过身份验证。如果allow_inactive为true，但allow_any为false，则可以在用户未经过身份验证的情况下执行该操作，但是必须是已经登录的用户。如果allow_any为true，但allow_inactive为false，则可以在未登录的情况下执行该操作，但必须是经过身份验证的用户。</p>
<p>如果 allow_active 被设置为 false，则不管 allow_any 和 allow_inactive 设置为什么值，PolicyKit 都会禁止在活动会话中进行授权的操作。因此，allow_active 的优先级高于其他选项</p>
<h2 id="应用鉴权"><a href="#应用鉴权" class="headerlink" title="应用鉴权"></a>应用鉴权</h2><p>(以C++举例)</p>
<p>应用运行后，当执行到某个动作时，打算验证使用者的身份再继续，否则可能因身份问题拒绝此动作，我们的代码可以这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;polkit-qt5-1/PolkitQt1/Authority&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PolkitQt1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="type">void</span>)(argc);</span><br><span class="line">    (<span class="type">void</span>)(argv);</span><br><span class="line">    </span><br><span class="line">    Authority::Result result;</span><br><span class="line">    result = Authority::<span class="built_in">instance</span>()-&gt;<span class="built_in">checkAuthorizationSync</span>(<span class="string">&quot;com.deepin.polkit.demo.fun1&quot;</span></span><br><span class="line">                                                           , <span class="built_in">UnixProcessSubject</span>(<span class="built_in">getpid</span>())</span><br><span class="line">                                                           , Authority::AllowUserInteraction);</span><br><span class="line">    <span class="keyword">if</span> (result == Authority::Yes) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;We are free, continue&quot;</span>;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Done, good job!&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;So sad, permission denied!&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>checkAuthorizationSync</code>方法有三个参数：</p>
<p>第一个参数声明要鉴权的动作id，它在<code>policy</code>策略中被定义，是<code>action</code>的身份识别码</p>
<p>第二个参数一般传递需要授鉴权进程的id，用于<code>polkit</code>识别待鉴权进程</p>
<p>第三个参数默认指定<code>Authority::AllowUserInteraction</code>即可(或者为<code>None</code>，此时直接检查此动作是否被允许，如果<code>policy</code>或者<code>rules</code>文件中未表明此动作为允许，则直接返回失败，不再弹出鉴权管理的弹窗)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Synchronous version of the checkAuthorization method.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* \param actionId the Id of the action in question</span></span><br><span class="line"><span class="comment">* \param subject subject that the action is authorized for (e.g. unix process)</span></span><br><span class="line"><span class="comment">* \param flags flags that influences the authorization checking</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* \see checkAuthorization Asynchronous version of this method.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Result <span class="title">checkAuthorizationSync</span><span class="params">(<span class="type">const</span> QString &amp;actionId, <span class="type">const</span> Subject &amp;subject,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AuthorizationFlags flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>您也可以参照示例上的用法，在UOS操作系统中，大多数鉴权都是采用完整示例的demo2的方式，我们建议您也采用此种方案。</p>
<p><strong>示例程序</strong></p>
<p><a class="link"   href="https://github.com/ssk-wh/ssk-wh.github.io/raw/master/files/polkit-demo-master-1.1.zip" >示例demo<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、如何通过polkit提权，让普通的用户进程执行一些root权限才能做的事情。</p>
<p>A: 设计两个进程，分别为A、B，其中A为root进程，B为普通进程。A通过进程间通信的方式(例如DBus)提供接口Method1供进程B调用。</p>
<p>2、设计的root进程提供了接口，但应用调用后所有的鉴权都是通过，拦截不住。</p>
<p>A：检查checkAuthorizationSync方法的第二个参数，传递的pid是否是需要鉴权的进程，而不是提供接口的进程。如果pid对应的进程本身是root权限，polkit会直接允许。</p>
<h1 id="鉴权验证程序"><a href="#鉴权验证程序" class="headerlink" title="鉴权验证程序"></a>鉴权验证程序</h1><p>在不同的发行版上，鉴权管理的验证程序并不总是一样，polkit 允许不同的发行版开发符合其视觉特色的界面程序。在某些没有界面的Linux发行版上，polkit 提供了<a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/PolkitAgentTextListener.html#PolkitAgentTextListener-struct" >PolkitAgentTextListener<i class="fas fa-external-link-alt"></i></a>类型，用于开发基于文本交互的鉴权管理验证程序。</p>
<p>当普通进程通过 polkit 机制进行某些操作时，验证程序总是能够’拦截’,并根据策略文件选择是否和使用者交互的方式(例如弹窗)要求使用者鉴权。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>polkit  提供了一个鉴权 API，供特权程序（“ MECHANISMS ” ）使用，通常通过某种形式的进程间通信机制为非特权程序（ “ SUBJECTS ”）提供服务。在这种情况下，该机制通常将主体视为不受信任。对于来自主体的每个请求，该机制需要确定该请求是否被鉴权，或者它是否应该拒绝为主体提供服务。使用  polkit  API，可以将此决定转交给受信任的一方： polkit 认证。</p>
<p>polkit 认证被作为系统守护进程来实现，这就是<a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/polkitd.8.html" >polkitd<i class="fas fa-external-link-alt"></i></a>，它本身没有什么特权，因为它以  polkitd 系统用户身份运行。特权进程、待鉴权进程和认证验证程序使用系统消息总线与认证机制进行通信。</p>
<p>除了作为鉴权之外，polkit  还允许用户通过验证管理用户或客户端所属会话的所有者来获得临时鉴权。这对于需要验证当前系统的操作员是用户还是管理员用户的场景很有用。</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><code>polkit</code> 的系统架构由 <code>polkitd</code>（作为系统消息总线上的服务实现）和每个用户会话的身份验证代理（由用户的图形环境提供和启动）组成。动作由应用程序定义(以<code>policy</code>策略文件的形式)。供应商、站点和系统管理员可以通过鉴权规则(见附录)控制鉴权策略。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/1253439/structure.png"
                       
                 ></p>
<p>为方便起见，该<code>libpolkit-gobject-1 </code>库封装了 <code>polkit</code> D-Bus API，可用于任何 C&#x2F;C++ 程序以及支持<code>[GObjectIntrospection](https://live.gnome.org/GObjectIntrospection)</code>的高级语言 ，例如 <code>Javascript</code> 和 <code>Python</code>。也可以使用 D-Bus API 或<code>[pkcheck](https://www.freedesktop.org/software/polkit/docs/latest/pkcheck.1.html)</code> 命令来检查鉴权。该 <code>libpolkit-agent-1</code>库提供了本地身份验证系统的抽象，例如 <code>pam</code> ，还提供了与 <code>polkit</code> D-Bus 服务的注册和通信。<br>有关编写 <code>polkit</code> 身份验证代理程序的更多信息，请参阅<a class="link"   href="http://www.freedesktop.org/software/polkit/docs/latest/" >开发人员文档<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="认证代理"><a href="#认证代理" class="headerlink" title="认证代理"></a>认证代理</h2><p>身份验证代理用于使会话的使用者证明确实自己是当前用户（对使用者进行身份验证）或管理员用户（通过以管理员身份进行身份验证）。为了能更好和系统的其他组件一起集成发布（例如界面设计和体验与系统其他部分保持统一），身份验证代理一般由系统的发行商提供。例如，身份验证代理程序可能如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/1253439/other.png"
                       
                 ></p>
<p>不在桌面环境下运行的应用程序（例如，如果从 <code>ssh</code> 登录启动)可能没有与之关联的身份验证代理。此类应用程序可以使用<a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/PolkitAgentTextListener.html#Polkit" >PolkitAgentTextListener<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/pkttyagent.1.html" >AgentTextListener-struct<i class="fas fa-external-link-alt"></i></a>类型或 <code>[pkttyagent]</code>帮助程序，以便用户可以使用文本界面进行身份验证。</p>
<h2 id="声明操作"><a href="#声明操作" class="headerlink" title="声明操作"></a>声明操作</h2><p>为了使用<code>polkit</code>，您需要声明一系列<code>action</code>。这些<code>action</code>对应不同的操作，客户端可以通过<code>polkit</code>机制去请求执行对应<code>action</code>的操作，这些<code>action</code>以<code>XML</code>文件的方式被安装到<code>/usr/share/polkit-1/actions</code>目录中。<br>关乎这些XML文件的书写规范详见附录</p>
<h2 id="认证规则文件"><a href="#认证规则文件" class="headerlink" title="认证规则文件"></a>认证规则文件</h2><p>在policy文件中，我们可以设置<code>allow_active</code>的值为<code>yes</code>或<code>no</code>来控制结果，但我们并不建议您这样做，而应该通过认证规则文件，规则文件可以在不修改策略文件的情况更改鉴权的默认行为。</p>
<p>(例如在policy文件中定义了某个action的allow_active为no，鉴权时将默认不通过，此时可以通过增加rules文件，修改此action的默认鉴权结果)</p>
<p><code>polkit</code>有版本之分,可以使用<code>pkexec --version</code>查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[uos@uos-PC 13:41:53 ~]<span class="variable">$pkexec</span> --version</span><br><span class="line">pkexec version 0.105</span><br></pre></td></tr></table></figure>
<p>106之前版本的规则文件是<code>pkla</code>格式，之后的版本是<code>rules</code>.</p>
<h3 id="pkla"><a href="#pkla" class="headerlink" title="pkla"></a>pkla</h3><p>105版本的规则文件以pkla结尾，polkitd 以字典顺序读取 &#x2F;etc&#x2F;polkit-1&#x2F;rules.d 和 &#x2F;usr&#x2F;share&#x2F;polkit-1&#x2F;rules.d 目录中的 .rules 文件。如果两个文件采用同样的名称，&#x2F;etc 中的文件在 &#x2F;usr 中的文件前面。处理旧的 .pkla 文件时，最先采用的是最后的规则。使用新的 .rules 文件时，首先采用的是第一个匹配的规则。</p>
<p>在pkla规则文件中，我们只需要在Action字段中指明规则对应的action id,所有的配置均以Key&#x3D;value的形式，其中Key为固定字段，value视情况而定，附上一个示例的pkla规则文件，表示action id &#x3D; org.kubuntu.qaptworker3.commitchanges的操作默认允许，[]内您可以自定义内容用于提示此规则文件的作用。</p>
<p>您可以按照这种格式修改成自己想要的规则文件，并重命名后放于对应的目录中，从而让其生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[commitchanges without auth]</span><br><span class="line">Identity=unix-group:sudo</span><br><span class="line">Action=org.kubuntu.qaptworker3.commitchanges</span><br><span class="line">ResultAny=no</span><br><span class="line">ResultInactive=no</span><br><span class="line">ResultActive=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>在polkit.pkla文件中，如果存在多个规则匹配到同一个操作，那么规则的优先级是按照其在文件中出现的顺序来确定的。较早出现的规则将具有更高的优先级，而后面出现的规则将具有较低的优先级。这意味着，如果多个规则都匹配到了同一个操作，那么较早出现的规则将起作用，而较晚出现的规则将被忽略。</p>
<p>所以，如果你在.polkit.pkla文件中定义了多个规则，并且这些规则可能会匹配到相同的操作，确保将最特殊的规则（具体的操作或用户）放在文件的前面，以确保它们的优先级更高。通常，通用规则应该放在后面，以便捕获不匹配更特定规则的操作或用户。</p>
<p>例如规则文件如果配置如下， 将允许所有以org.freedesktop.NetworkManager开头的action，其他action在匹配不到的情况，统一拒绝。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Allow NetworkManager Actions]</span><br><span class="line">Identity=unix-user:*</span><br><span class="line">Action=org.freedesktop.NetworkManager.*</span><br><span class="line">ResultAny=<span class="built_in">yes</span></span><br><span class="line">ResultInactive=<span class="built_in">yes</span></span><br><span class="line">ResultActive=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">[Deny Other Actions]</span><br><span class="line">Identity=unix-user:*</span><br><span class="line">Action=*</span><br><span class="line">ResultAny=no</span><br><span class="line">ResultInactive=no</span><br><span class="line">ResultActive=no</span><br></pre></td></tr></table></figure>

<p>另外要注意的一点是，pkla的规则要放置的路径为&#x2F;etc&#x2F;polkit-1&#x2F;localauthority&#x2F;10-vendor.d&#x2F;或同级别其他目录下，这里和rules文件是不一样的。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><p><code>rules</code>规则文件是用 <code>JavaScript</code>编程语言编写的，并通过全局对象（类型为<code>Polkit</code>）与<code>polkitd</code> 交互。需要放置到系统的<code>/etc/polkit-1/rules.d </code>和 <code>/usr/share/polkit-1/rules.d</code>目录中才会生效。</p>
<p>列举一些常用的规则文件：</p>
<p>允许admin组中的所有用户在不更改其他用户策略的情况下执行用户管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">polkit.addRule(<span class="keyword">function</span>(action, subject) &#123; </span><br><span class="line">    <span class="keyword">if</span> (action.id == <span class="string">&quot;org.freedesktop.accounts.user-administration&quot;</span> &amp;&amp; </span><br><span class="line">        subject.isInGroup(<span class="string">&quot;admin&quot;</span>)) &#123; </span><br><span class="line">        <span class="built_in">return</span> polkit.Result.YES; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure>

<p>将管理用户定义为wheel组中的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">polkit.addAdminRule(<span class="keyword">function</span>(action, subject) &#123; </span><br><span class="line">    <span class="built_in">return</span> [<span class="string">&quot;unix-group:wheel&quot;</span>]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>禁止组<code>children</code>中的用户更改主机名配置（即，任何以<code>org.freedesktop.hostname1.</code>标识符开头的操作）并允许其他任何人在验证身份后执行此操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">polkit.addRule(<span class="keyword">function</span>(action, subject) &#123; </span><br><span class="line">    <span class="keyword">if</span> (action.id.indexOf(<span class="string">&quot;org.freedesktop.hostname1.&quot;</span>) == 0) &#123; </span><br><span class="line">        <span class="keyword">if</span> (subject.isInGroup(<span class="string">&quot;children&quot;</span>)) &#123; </span><br><span class="line">            <span class="built_in">return</span> polkit.Result. NO; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="built_in">return</span> polkit.Result.AUTH_SELF_KEEP; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html" >polkit介绍<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/" >polkit身份验证代理程序开发<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://wiki.archlinux.org/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" >Polkit_(简体中文)<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html" >freedesktop-polkit<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>polkit</tag>
        <tag>鉴权</tag>
        <tag>认证</tag>
        <tag>授权</tag>
      </tags>
  </entry>
  <entry>
    <title>调试Qt源码</title>
    <url>/2023/06c308e936.html</url>
    <content><![CDATA[<p>如何调试qt源码</p>
<p>环境：Linux</p>
<h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/1.png"
                        alt="1"
                 ></p>
<h2 id="进入源码目录，安装编译依赖"><a href="#进入源码目录，安装编译依赖" class="headerlink" title="进入源码目录，安装编译依赖"></a>进入源码目录，安装编译依赖</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/2.png"
                        alt="2"
                 ></p>
<h2 id="提前修改源码，方便后面验证效果"><a href="#提前修改源码，方便后面验证效果" class="headerlink" title="提前修改源码，方便后面验证效果"></a>提前修改源码，方便后面验证效果</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/2.1.png"
                        alt="2.1"
                 ></p>
<h2 id="556行增加一行输出，然后保存退出"><a href="#556行增加一行输出，然后保存退出" class="headerlink" title="556行增加一行输出，然后保存退出"></a>556行增加一行输出，然后保存退出</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/2.2.png"
                        alt="2.2"
                 ></p>
<h2 id="configure检查"><a href="#configure检查" class="headerlink" title="configure检查"></a>configure检查</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/3.png"
                        alt="3"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/4.png"
                        alt="4"
                 ></p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/5.png"
                        alt="5"
                 ></p>
<h2 id="make报错"><a href="#make报错" class="headerlink" title="make报错"></a>make报错</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/6.png"
                        alt="6"
                 ></p>
<h2 id="定位异常点"><a href="#定位异常点" class="headerlink" title="定位异常点"></a>定位异常点</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/7.png"
                        alt="7"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/8.png"
                        alt="8"
                 ></p>
<h2 id="注释掉异常模块-如果你要调试的正好是这个模块，请自行解决"><a href="#注释掉异常模块-如果你要调试的正好是这个模块，请自行解决" class="headerlink" title="注释掉异常模块(如果你要调试的正好是这个模块，请自行解决)"></a>注释掉异常模块(如果你要调试的正好是这个模块，请自行解决)</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/9.png"
                        alt="9"
                 ></p>
<h2 id="重新make并make-install"><a href="#重新make并make-install" class="headerlink" title="重新make并make install"></a>重新make并make install</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/10.png"
                        alt="10"
                 ></p>
<h1 id="调试qt"><a href="#调试qt" class="headerlink" title="调试qt"></a>调试qt</h1><h2 id="工具-gt-选项-gt-Kits-gt-Qt-Versions-gt-添加"><a href="#工具-gt-选项-gt-Kits-gt-Qt-Versions-gt-添加" class="headerlink" title="工具-&gt;选项-&gt;Kits-&gt;Qt Versions-&gt;添加"></a>工具-&gt;选项-&gt;Kits-&gt;Qt Versions-&gt;添加</h2><p>添加刚刚编译安装的qt，点击Apply，点击OK</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/11.png"
                        alt="11"
                 ></p>
<h2 id="重新打开Kits-gt-构建套件-Kit"><a href="#重新打开Kits-gt-构建套件-Kit" class="headerlink" title="重新打开Kits-&gt;构建套件(Kit)"></a>重新打开Kits-&gt;构建套件(Kit)</h2><p>手动添加新的设置，Qt版本选择新安装的版本</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/12.png"
                        alt="12"
                 ></p>
<h2 id="添加源码，Apply-gt-OK-方便对qt源码直接打断点调试"><a href="#添加源码，Apply-gt-OK-方便对qt源码直接打断点调试" class="headerlink" title="添加源码，Apply-&gt;OK(方便对qt源码直接打断点调试)"></a>添加源码，Apply-&gt;OK(方便对qt源码直接打断点调试)</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/13.png"
                        alt="13"
                 ></p>
<h2 id="新建Project，构建套件选择5-11-3-新添加的这个"><a href="#新建Project，构建套件选择5-11-3-新添加的这个" class="headerlink" title="新建Project，构建套件选择5.11.3(新添加的这个)"></a>新建Project，构建套件选择5.11.3(新添加的这个)</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/14.png"
                        alt="14"
                 ></p>
<h2 id="运行即可"><a href="#运行即可" class="headerlink" title="运行即可"></a>运行即可</h2><p>(应用运行时加载的库均为新编译安装的qt库，不会对系统中的qt版本产生影响)</p>
<p>可以看到输出内容有QApplication的字样，表示我们运行时加载的库确实是我们修改后的qt源码所编译的<img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/15.png"
                        alt="15"
                 ></p>
<h2 id="安装调试符号包"><a href="#安装调试符号包" class="headerlink" title="安装调试符号包"></a>安装调试符号包</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/17.png"
                        alt="17"
                 ></p>
<h2 id="对qt源码打上断点，直接F5运行新建的project"><a href="#对qt源码打上断点，直接F5运行新建的project" class="headerlink" title="对qt源码打上断点，直接F5运行新建的project"></a>对qt源码打上断点，直接F5运行新建的project</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/06c308e936/18.png"
                        alt="18"
                 ></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>软件包依赖关系分析工具</title>
    <url>/2024/01685f950a.html</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过 apt 命令分析系统中安装的软件包的依赖关系，生成符合 mermaid 语法的配置文件，再通过 dot 命令生成 svg 图。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>确保电脑上安装了 dot 命令<br><code>sudo apt install graphviz</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: ssk-wh</span></span><br><span class="line"><span class="comment"># Date: 2024.01.29</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @para: null</span></span><br><span class="line"><span class="comment"># 输出帮助信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">print_usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage:</span></span><br><span class="line"><span class="string">    用于分析软件包依赖的工具,最终在当前目录生成一张依赖关系图</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    -h 输出帮助手册</span></span><br><span class="line"><span class="string">    -a 输出所有已安装软件包的依赖关系 (不要用 -a 参数，生成的 svg 图恐怕没有电脑能流畅地查看)</span></span><br><span class="line"><span class="string">    -m : 对指定软件包进行mark,生成的svg图中会进行特殊标记</span></span><br><span class="line"><span class="string">    -d : 指定查找深度，默认不限制，仅当指定分析特定应用时生效，配合 -p 参数生效</span></span><br><span class="line"><span class="string">    -p : 分析指定软件包的被依赖关系图</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    用例:</span></span><br><span class="line"><span class="string">    分析dde-dock的被依赖关系图,递归查找深度为2,如果存在startdde,就加个颜色标记</span></span><br><span class="line"><span class="string">    generate_rdepends.sh -p dde-dock -d 2 -m startdde</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    分析所有已安装软件包的依赖关系</span></span><br><span class="line"><span class="string">    generate_rdepends.sh -a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rdepends_file=<span class="string">&quot;/tmp/rdepends.tmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @para：file 目标文件</span></span><br><span class="line"><span class="comment"># @para: text 传入的内容</span></span><br><span class="line"><span class="comment"># 将内容以追加的方式写入文件中</span></span><br><span class="line"><span class="comment"># @example: write_to_file &quot;/tmp/tmp.file&quot; &quot;write strings&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">write_to_file</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _dest_file=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> _write_string=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$_write_string</span> &gt;&gt; <span class="variable">$_dest_file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># @para：null</span></span><br><span class="line"><span class="comment"># 获取已安装软件包列表,返回一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">get_installed_packages</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _packages=()  <span class="comment"># 定义空数组存储软件包名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 dpkg -l 命令获取已安装软件包列表，提取软件包名称并添加到数组中（排除带dbgsym或者dev的包）</span></span><br><span class="line">    <span class="built_in">mapfile</span> -t _packages &lt; &lt;(dpkg -l | grep -vi <span class="string">&quot;dbgsym&quot;</span>| awk <span class="string">&#x27;/^ii/ &#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回软件包名称数组</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> <span class="string">&quot;<span class="variable">$&#123;_packages[@]&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @para: package 软件包名</span></span><br><span class="line"><span class="comment"># 分析此软件包被哪些软件包所依赖，返回一组包名列表(仅统计系统中安装的应用)</span></span><br><span class="line"><span class="comment"># @example: get_package_rdepends &quot;dde-dock&quot; </span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">get_package_rdepends</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _package=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> _limit_packages=($(get_installed_packages))</span><br><span class="line">    <span class="comment"># echo &quot;系统中安装的应用列表:&quot;</span></span><br><span class="line">    <span class="comment"># printf &#x27;%s\n&#x27; &quot;$&#123;_limit_packages[@]&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    command_output=$(apt rdepends <span class="variable">$_package</span>)</span><br><span class="line"></span><br><span class="line">    output_list=()</span><br><span class="line">    <span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># echo &quot;line:&quot; $line</span></span><br><span class="line">        <span class="comment"># 分析包含&quot;依赖&quot;的行</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$line</span>&quot;</span> == *<span class="string">&quot;依赖: &quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">            output_string=<span class="string">&quot;<span class="variable">$&#123;line/依赖: /&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 去掉竖线</span></span><br><span class="line">            output_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$output_string</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">            <span class="comment"># 去掉版本信息</span></span><br><span class="line">            <span class="keyword">while</span> [[ <span class="variable">$output_string</span> == *<span class="string">&#x27;(&#x27;</span>* &amp;&amp; <span class="variable">$output_string</span> == *<span class="string">&#x27;)&#x27;</span>* ]]; <span class="keyword">do</span></span><br><span class="line">                output_string=<span class="string">&quot;<span class="variable">$&#123;output_string%%(*&#125;</span><span class="variable">$&#123;output_string#*)&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除空格</span></span><br><span class="line">        output_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$output_string</span>&quot;</span> | sed <span class="string">&#x27;s/ //g&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> ! [[ <span class="string">&quot; <span class="variable">$&#123;_limit_packages[*]&#125;</span> &quot;</span> == *<span class="string">&quot;<span class="variable">$output_string</span>&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment"># &quot;未安装的软件包，忽略&quot;</span></span><br><span class="line">            <span class="comment"># echo &quot;@@@&quot;</span></span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将结果添加到列表中（如果列表中不存在相同的内容）</span></span><br><span class="line">        <span class="keyword">if</span> ! [[ <span class="string">&quot; <span class="variable">$&#123;output_list[@]&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$output_string</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            output_list+=(<span class="string">&quot;<span class="variable">$output_string</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># echo &quot;###&quot; $output_string</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">done</span> &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$command_output</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;output_list[@]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查过的软件包都记录下，避免重复查询</span></span><br><span class="line">used_package_list=()</span><br><span class="line"><span class="comment"># 记录当前查询深度</span></span><br><span class="line">depth=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># @para: package 软件包名</span></span><br><span class="line"><span class="comment"># @para: package_rdepends_list 包名列表</span></span><br><span class="line"><span class="comment"># 递归函数：分析此软件包和package_rdepends_list中的包名间的被依赖关系，层层查找，将内容输出到配置文件中</span></span><br><span class="line"><span class="comment"># @example: generate_package_digraph &quot;dde-dock&quot; $package_list</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">generate_package_digraph</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _package=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> _depth=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> _package_mark=<span class="variable">$3</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">shift</span>                               <span class="comment"># 将参数向左移动一个位置以获得数组</span></span><br><span class="line">    <span class="built_in">local</span> _package_rdepends_list=(<span class="string">&quot;<span class="variable">$@</span>&quot;</span>)       <span class="comment"># 获取移动后的参数列表</span></span><br><span class="line">  </span><br><span class="line">    depth=$((depth + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$_depth</span>&quot;</span> -ne -1 ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$depth</span>&quot;</span> -gt <span class="variable">$_depth</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;^^^ 超出最大查询深度: <span class="variable">$_depth</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 已经进行过rdenpeds操作的包记录一下,避免重复统计</span></span><br><span class="line">        <span class="keyword">if</span> ! [[ <span class="string">&quot; <span class="variable">$&#123;used_package_list[@]&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$_package</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            used_package_list+=(<span class="string">&quot;<span class="variable">$_package</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取数组的大小</span></span><br><span class="line">            array_size=<span class="string">&quot;<span class="variable">$&#123;#_package_rdepends_list[@]&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 判断数组是否为空并进行相应操作</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$array_size</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;== 正在生成软件包的依赖数据:&quot;</span> <span class="variable">$_package</span> <span class="string">&quot;被依赖软件包列表数量:&quot;</span> <span class="variable">$array_size</span></span><br><span class="line">                <span class="comment"># echo &quot;    depth:&quot; $depth</span></span><br><span class="line">                <span class="comment"># 遍历列表并输出每个字符串</span></span><br><span class="line">                <span class="keyword">for</span> rdepends_package <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;_package_rdepends_list[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">&quot;    handle package:&quot;</span> <span class="variable">$rdepends_package</span></span><br><span class="line">                    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$rdepends_package</span>&quot;</span> == <span class="string">&quot;<span class="variable">$_package_mark</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                        write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;  node [shape=box,style=filled,color=\&quot;.7 .3 1.0\&quot;];&quot;</span></span><br><span class="line">                    <span class="keyword">fi</span></span><br><span class="line">                    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;  \&quot;<span class="variable">$_package</span>\&quot;-&gt;\&quot;<span class="variable">$rdepends_package</span>\&quot;;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$rdepends_package</span>&quot;</span> == <span class="string">&quot;<span class="variable">$_package_mark</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                        write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;  node [shape=\&quot;\&quot;, style=\&quot;\&quot;, color=\&quot;\&quot;];&quot;</span></span><br><span class="line">                    <span class="keyword">fi</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归一遍</span></span><br><span class="line">                <span class="keyword">for</span> rdepends_package <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;_package_rdepends_list[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">                    new_package_rdepends_list=($(get_package_rdepends <span class="string">&quot;<span class="variable">$rdepends_package</span>&quot;</span>))</span><br><span class="line">                    generate_package_digraph <span class="string">&quot;<span class="variable">$rdepends_package</span>&quot;</span> <span class="string">&quot;<span class="variable">$_depth</span>&quot;</span> <span class="string">&quot;<span class="variable">$_package_mark</span>&quot;</span> <span class="variable">$&#123;new_package_rdepends_list[@]&#125;</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;已查询过，忽略本次查询&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    depth=$((depth - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成所有安装应用的的依赖关系图</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">generate_all</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _package_mark=<span class="variable">$1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1\清除旧的配置文件</span></span><br><span class="line">    <span class="built_in">rm</span> -f <span class="variable">$rdepends_file</span></span><br><span class="line">    <span class="built_in">touch</span> <span class="variable">$rdepends_file</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2\生成head部分内容</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;digraph basicGraph &#123;&quot;</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;rankdir = LR  &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3\逐个遍历已安装的应用</span></span><br><span class="line">    _installed_packages=($(get_installed_packages))</span><br><span class="line">    <span class="keyword">for</span> package <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;_installed_packages[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;handle package:&quot;</span> <span class="variable">$package</span></span><br><span class="line">        _rdepends_list=($(get_package_rdepends <span class="variable">$package</span>))</span><br><span class="line">        <span class="keyword">for</span> rdepends_package <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;_rdepends_list[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">            write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;  \&quot;<span class="variable">$package</span>\&quot;-&gt;\&quot;<span class="variable">$rdepends_package</span>\&quot;;&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4\生成foot部分内容</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5\将配置文件转换为svg图片</span></span><br><span class="line">    dot -Tsvg <span class="variable">$rdepends_file</span> -o rdepends.svg</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定包的关系图</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">generate_by_package</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> _package=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> _depth=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> _package_mark=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1\清除旧的配置文件</span></span><br><span class="line">    <span class="built_in">rm</span> -f <span class="variable">$rdepends_file</span></span><br><span class="line">    <span class="built_in">touch</span> <span class="variable">$rdepends_file</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2\生成head部分内容</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;digraph basicGraph &#123;&quot;</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;rankdir = LR  &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;开始查找软件包的被依赖关系:&quot;</span> <span class="variable">$_package</span></span><br><span class="line">    <span class="comment"># package_rdepends_list=($(get_package_rdepends &quot;$_package&quot; &quot;$_installed_packages&quot;))</span></span><br><span class="line">    <span class="comment"># printf &#x27;%s\n&#x27; &quot;$&#123;package_rdepends_list[@]&#125;&quot;</span></span><br><span class="line">    <span class="comment"># exit 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3\开始查询</span></span><br><span class="line">    <span class="comment"># 查找被哪些包依赖，在递归这些被依赖的包又被哪些包依赖，递归一次层深加1，可以通过 -d 参数指定查询深度</span></span><br><span class="line">    <span class="comment"># bash的第一个小坑,取list要加括号 </span></span><br><span class="line">    package_rdepends_list=($(get_package_rdepends <span class="string">&quot;<span class="variable">$_package</span>&quot;</span>))</span><br><span class="line">    <span class="comment"># bash的第二个小坑,不要传入一个空的参数，会其他后面的参数受到影响</span></span><br><span class="line">    generate_package_digraph <span class="string">&quot;<span class="variable">$_package</span>&quot;</span> <span class="string">&quot;<span class="variable">$_depth</span>&quot;</span> <span class="string">&quot;<span class="variable">$_package_mark</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;package_rdepends_list[@]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4\生成foot部分内容</span></span><br><span class="line">    write_to_file <span class="variable">$rdepends_file</span> <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5\将配置文件转换为svg图片</span></span><br><span class="line">    dot -Tsvg <span class="variable">$rdepends_file</span> -o <span class="variable">$_package</span><span class="string">&quot;.svg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################ start ################################################</span></span><br><span class="line"></span><br><span class="line">option_mark=<span class="string">&quot;dde&quot;</span></span><br><span class="line">option_depth=-1</span><br><span class="line">option_package=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">option_mark_set=<span class="literal">false</span></span><br><span class="line">option_all_set=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析命令行参数</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;:am:d:p:h&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    a)</span><br><span class="line">        option_all_set=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line">    m)</span><br><span class="line">        option_mark=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        option_mark_set=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line">    d)</span><br><span class="line">        option_depth=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    p)</span><br><span class="line">        option_package=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    h)</span><br><span class="line">        print_usage</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">        ;;</span><br><span class="line">    \?)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Invalid option: -<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    :)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Option -<span class="variable">$OPTARG</span> requires an argument.&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -a 则分析所有已安装软件包的依赖关系</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$option_all_set</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 默认mark dde项目</span></span><br><span class="line">    generate_all <span class="variable">$option_mark</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定的软件包名不为空，分析此软件包的被依赖关系</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$option_package</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="variable">$option_mark_set</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 指定 -p 但未指定 -m,直接标记 -p 指向的软件包</span></span><br><span class="line">        option_mark=<span class="variable">$option_package</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;package:&quot;</span> <span class="variable">$option_package</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;depth:&quot;</span> <span class="variable">$option_depth</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;mark:&quot;</span> <span class="variable">$option_mark</span></span><br><span class="line">    generate_by_package <span class="variable">$option_package</span> <span class="variable">$option_depth</span> <span class="variable">$option_mark</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    print_usage</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>可以给上述脚本添加可执行权限，运行时添加 -h 参数可输出帮助信息。<br><code>chmod +x generate_rdepends.sh</code><br><code>generate_rdepends.sh -h</code></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>在 UOS 系统中运行以下命令<br><code>generate_rdepends.sh -p libdtkwidget5 -m dde-dock</code><br>得到的依赖图内容如下</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2024/01685f950a/1.svg"
                       
                 ></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>通过上面的脚本可以分析某个软件包的被依赖项，如果是分析其依赖项，可以通过 <code>debtree -b [package_name]</code> 实现。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式-创建型</title>
    <url>/2023/035c8e0065.html</url>
    <content><![CDATA[<p>创建型模式涉及到对象的创建和实例化。</p>
<p>以下是几种常见的创建型模式：</p>
<p>工厂方法模式：定义一个工厂接口，由子类来决定具体实例化哪个对象。</p>
<p>抽象工厂模式：提供一个创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类。</p>
<p>单例模式：保证一个类仅有一个实例，并提供一个全局访问点来访问这个唯一实例。</p>
<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>原型模式：通过复制现有的实例来创建新的实例。</p>
<p>这些模式都关注于如何创建对象，并提供了不同的解决方案来满足不同的需求。</p>
<span id="more"></span>


<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是一种创建型设计模式，它提供了一种封装对象创建过程的方式，使得客户端无需关心具体对象是如何创建的，只需要调用工厂方法就可以得到所需的对象。在工厂模式中，有一个工厂类负责创建对象，并向客户端提供接口。</p>
<p>工厂模式可以分为两种：简单工厂模式和工厂方法模式。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式又称为静态工厂方法模式，它通过一个工厂类来创建对象。客户端只需要向工厂类传递一个指定的参数（例如一个字符串），工厂类就会根据这个参数来决定创建哪种具体对象。简单工厂模式违反了开放-封闭原则，因为如果需要添加新类型的产品，需要修改工厂类的代码。</p>
<p>(开放-封闭原则：开放-封闭原则（Open-Closed Principle, OCP）是指一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，当需求变化时，应该尽量通过扩展原有代码来实现新的功能，而不是通过修改已有代码来实现。开放-封闭原则是面向对象设计的重要原则之一，它可以提高软件系统的可维护性、可扩展性和复用性，降低软件开发和维护的成本。)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ConcreteProductA operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ConcreteProductB operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Product* <span class="title">createProduct</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;B&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Product* productA = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  Product* productB = SimpleFactory::<span class="built_in">createProduct</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">  productA-&gt;<span class="built_in">operation</span>(); <span class="comment">// Output: ConcreteProductA operation</span></span><br><span class="line">  productB-&gt;<span class="built_in">operation</span>(); <span class="comment">// Output: ConcreteProductB operation</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> productA;</span><br><span class="line">  <span class="keyword">delete</span> productB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式又称为多态性工厂模式，它定义了一个创建对象的接口，但是由子类来决定要实例化哪个类。工厂方法让类的实例化推迟到子类中进行。这样，客户端代码就不需要依赖于具体的产品类。工厂方法模式满足了开放-封闭原则，因为如果需要添加新类型的产品，只需要添加新的工厂子类即可，不需要修改已有的代码。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m product A.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m product B.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建工厂对象</span></span><br><span class="line">    Factory* factoryA = <span class="keyword">new</span> <span class="built_in">FactoryA</span>();</span><br><span class="line">    Factory* factoryB = <span class="keyword">new</span> <span class="built_in">FactoryB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产产品A</span></span><br><span class="line">    Product* productA = factoryA-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productA-&gt;<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产产品B</span></span><br><span class="line">    Product* productB = factoryB-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">    productB-&gt;<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> productA;</span><br><span class="line">    <span class="keyword">delete</span> productB;</span><br><span class="line">    <span class="keyword">delete</span> factoryA;</span><br><span class="line">    <span class="keyword">delete</span> factoryB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了抽象产品类<code>Product</code>，并实现了两个具体产品类<code>ProductA</code>和<code>ProductB</code>，这些产品类都实现了抽象产品类中定义的接口<code>use</code>。接下来，我们定义了抽象工厂类<code>Factory</code>，并实现了两个具体工厂类<code>FactoryA</code>和<code>FactoryB</code>，这些工厂类都实现了抽象工厂类中定义的接口<code>createProduct</code>，用于创建具体产品类的对象。最后，我们在<code>main</code>函数中创建了具体工厂对象，并使用这些工厂对象创建了具体产品对象，并通过调用<code>use</code>方法来使用这些产品对象。在程序结束时，我们需要释放这些对象所占用的资源。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂模式是一种创建型设计模式，它可以提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>抽象工厂模式通常用于以下场景：</p>
<ol>
<li>当需要创建一系列相互依赖或相互关联的对象时，可以使用抽象工厂模式。这些对象之间有一定的约束关系，因此必须一起创建，否则可能会导致系统出现错误。</li>
<li>当需要在不同操作系统或不同外观风格下创建一系列相关的对象时，可以使用抽象工厂模式。这些对象之间的差异比较大，因此需要使用不同的工厂来创建它们。</li>
<li>当希望提供一个产品族的接口，而不是单一产品的接口时，可以使用抽象工厂模式。产品族指的是一组相关的产品，这些产品具有共同的特点，例如相同的界面风格、相同的操作方式等等。</li>
</ol>
<p>在抽象工厂模式中，抽象工厂类定义了一组用于创建产品对象的工厂方法，这些工厂方法分别负责创建不同类型的产品。具体工厂类实现了这些工厂方法，并创建了具体的产品对象。抽象产品类定义了产品的接口，具体产品类实现了产品的具体功能。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用抽象工厂模式可以将客户端代码与具体产品类的实现分离，从而提高系统的灵活性和可维护性。同时，抽象工厂模式也可以保证客户端代码始终引用抽象工厂和抽象产品类，而不用关心具体工厂和具体产品类的实现细节。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类 - 手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 - 华为手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> : <span class="keyword">public</span> Phone &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a Huawei phone.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 - 小米手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> : <span class="keyword">public</span> Phone &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a Xiaomi phone.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类 - 电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 - 华为电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiComputer</span> : <span class="keyword">public</span> Computer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a Huawei computer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 - 小米电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaomiComputer</span> : <span class="keyword">public</span> Computer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a Xiaomi computer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Phone* <span class="title">createPhone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Computer* <span class="title">createComputer</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 - 华为工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Computer* <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HuaweiComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 - 小米工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">XiaomiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Computer* <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">XiaomiComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* huaweiFactory = <span class="keyword">new</span> <span class="built_in">HuaweiFactory</span>();</span><br><span class="line">    Phone* huaweiPhone = huaweiFactory-&gt;<span class="built_in">createPhone</span>();</span><br><span class="line">    Computer* huaweiComputer = huaweiFactory-&gt;<span class="built_in">createComputer</span>();</span><br><span class="line">    huaweiPhone-&gt;<span class="built_in">display</span>();</span><br><span class="line">    huaweiComputer-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    AbstractFactory* xiaomiFactory = <span class="keyword">new</span> <span class="built_in">XiaomiFactory</span>();</span><br><span class="line">    Phone* xiaomiPhone = xiaomiFactory-&gt;<span class="built_in">createPhone</span>();</span><br><span class="line">    Computer* xiaomiComputer = xiaomiFactory-&gt;<span class="built_in">createComputer</span>();</span><br><span class="line">    xiaomiPhone-&gt;<span class="built_in">display</span>();</span><br><span class="line">    xiaomiComputer-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>AbstractFactory</code> 是抽象工厂类，定义了创建手机和电脑的接口。<code>HuaweiFactory</code> 和 <code>XiaomiFactory</code> 是具体工厂类，分别创建华为品牌和小米品牌的手机和电脑。<code>Phone</code> 和 <code>Computer</code> 是抽象产品类，定义了手机和电脑的接口。<code>HuaweiPhone</code>、<code>XiaomiPhone</code>、<code>HuaweiComputer</code> 和 <code>XiaomiComputer</code> 是具体产品类，实现了 <code>Phone</code> 和 <code>Computer</code> 的接口。</p>
<p>客户端代码只需要使用抽象工厂类和抽象产品类，不需要了解具体工厂类和具体产品类的实现细节。这样可以大大提高系统的</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>简单工厂、工厂方法、抽象工厂都属于工厂模式，它们的主要区别如下：</p>
<ol>
<li>简单工厂模式：由一个工厂类根据传入的参数决定创建哪一种产品类的实例。即通过一个简单的工厂类来创建产品，用户只需要传入所需的产品类型即可，不需要关心产品的具体实现细节。</li>
<li>工厂方法模式：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。即每个产品类都有一个对应的工厂类，用户需要使用哪种产品，就选择对应的工厂类。工厂方法模式符合开放封闭原则，可以新增产品类而不需要修改原有的工厂类代码。</li>
<li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。即每个具体工厂类负责创建一整套产品，这些产品之间存在着相关性，需要一起使用。抽象工厂模式适用于产品族概念的场景，也符合开放封闭原则。</li>
</ol>
<p>简单来说，三者的区别在于职责不同：简单工厂模式是由一个工厂类来负责创建产品；工厂方法模式是由每个产品类对应一个工厂类来创建产品；而抽象工厂模式则是由每个具体工厂类来创建一整套产品。</p>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式是一种创建型设计模式，它的主要思想是将一个复杂对象的构建过程与其表示分离开来，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式通常包含以下几个角色：</p>
<p>产品类（Product）：要创建的复杂对象。</p>
<p>抽象建造者类（Builder）：抽象出来的用于创建产品各个部分的方法，以及返回最终产品的方法。</p>
<p>具体建造者类（ConcreteBuilder）：实现抽象建造者类中定义的方法，用于构建产品的各个部分。</p>
<p>指挥者类（Director）：调用建造者类中定义的方法来构建产品，并返回最终的产品。</p>
<p>建造者模式的核心思想是将产品的构造过程分解为若干个部分，每个部分的构造细节由具体的建造者类来实现。指挥者类则按照一定的顺序来调用建造者类的方法，最终构建出完整的产品。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCPU</span><span class="params">(string cpu)</span> </span>&#123; m_cpu = cpu; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMemory</span><span class="params">(string memory)</span> </span>&#123; m_memory = memory; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHardDisk</span><span class="params">(string hardDisk)</span> </span>&#123; m_hardDisk = hardDisk; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOS</span><span class="params">(string os)</span> </span>&#123; m_os = os; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CPU: &quot;</span> &lt;&lt; m_cpu &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Memory: &quot;</span> &lt;&lt; m_memory &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;HardDisk: &quot;</span> &lt;&lt; m_hardDisk &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;OS: &quot;</span> &lt;&lt; m_os &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_cpu;</span><br><span class="line">    string m_memory;</span><br><span class="line">    string m_hardDisk;</span><br><span class="line">    string m_os;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Computer* <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        m_computer = <span class="keyword">new</span> <span class="built_in">Computer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_computer;</span><br><span class="line">        m_computer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123; m_computer-&gt;<span class="built_in">setCPU</span>(<span class="string">&quot;Intel Core i5&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>&#123; m_computer-&gt;<span class="built_in">setMemory</span>(<span class="string">&quot;8GB DDR4&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> </span>&#123; m_computer-&gt;<span class="built_in">setHardDisk</span>(<span class="string">&quot;512GB SSD&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123; m_computer-&gt;<span class="built_in">setOS</span>(<span class="string">&quot;Windows 10&quot;</span>); &#125;</span><br><span class="line">    <span class="function">Computer* <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_computer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Computer* m_computer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">(Builder* builder)</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildCPU</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildMemory</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildHardDisk</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildOS</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>建造者模式通常适用于以下场景：</p>
<p>当一个对象有很多参数需要设置，或者对象的构造方法参数很多，而每个参数又有默认值或者可选值时，可以使用建造者模式。通过建造者模式，我们可以将对象的构造方法分解为多个部分，这样可以更加灵活地组合各个部分，来构造出不同的对象。</p>
<p>当需要创建的对象具有复杂的层次结构时，可以使用建造者模式。例如，一个电脑对象可能包含了多个部件，每个部件又有不同的子部件，这时候可以使用建造者模式，将构造复杂对象的过程分解成多个步骤，使得每个步骤都比较简单，易于维护。</p>
<p>当需要创建的对象的内部结构比较复杂，但是创建过程相对固定时，可以使用建造者模式。例如，一个包含了多个子节点的 XML 文档，创建过程比较固定，但是文档结构比较复杂，可以使用建造者模式将文档结构分解成多个部分，使得创建过程更加清晰、易于理解。</p>
<p>总之，建造者模式适用于需要创建复杂对象，且创建过程相对固定，但是需要通过不同的方式组合构造出不同的对象。</p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式（Prototype Pattern）是一种创建型设计模式，它通过复制现有对象来创建新对象。通俗地说，原型模式就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。</p>
<p>在原型模式中，我们需要创建一个实现了 Cloneable 接口的原型类，它具有一个 clone() 方法，该方法可以创建并返回当前对象的一个副本。在使用原型对象的时候，我们可以通过克隆的方式来创建新的对象，而不是重新创建一个新的对象。</p>
<p>使用原型模式可以避免创建大量的重复对象，提高对象的创建效率，同时也可以简化对象的创建过程。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>原型模式的优点包括：</p>
<p>可以在运行时动态生成新的对象，而不需要编写额外的代码。</p>
<p>可以避免创建大量的重复对象，提高对象的创建效率。</p>
<p>可以简化对象的创建过程，使得创建对象更加方便、灵活。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>原型模式的缺点包括：</p>
<p>如果需要克隆的对象比较复杂，可能需要深度克隆，这样会增加程序的复杂度。</p>
<p>如果需要克隆的对象包含循环引用，克隆过程会陷入死循环，导致程序崩溃。</p>
<p>如果需要克隆的对象不支持序列化，克隆过程需要手动实现，增加程序的复杂度。</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cloneable* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> Cloneable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cloneable* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Person</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cloneable* p1 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    Cloneable* p2 = p1-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1&#x27;s name: &quot;</span> &lt;&lt; <span class="built_in">dynamic_cast</span>&lt;Person*&gt;(p1)-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; <span class="built_in">dynamic_cast</span>&lt;Person*&gt;(p1)-&gt;<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2&#x27;s name: &quot;</span> &lt;&lt; <span class="built_in">dynamic_cast</span>&lt;Person*&gt;(p2)-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; <span class="built_in">dynamic_cast</span>&lt;Person*&gt;(p2)-&gt;<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本示例中，我们先定义了一个 Cloneable 接口，它包含了 clone() 方法，用于创建对象的克隆。然后我们定义了一个 Person 类，它继承了 Cloneable 接口，并实现了 clone() 方法。在 main() 函数中，我们先创建了一个 Person 对象 p1，然后通过调用 clone() 方法来创建一个新的对象 p2，并输出了两个对象的信息。最后，我们释放了两个对象的内存。注意，在输出对象信息时，我们使用了 dynamic_cast 来将基类指针转换为派生类指针，以便能够调用派生类的方法。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供全局访问点。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>在单例模式中，一个类只有一个实例，这个实例通常由该类自身创建，并且在整个程序运行期间都存在。单例模式的核心思想是通过限制该类的实例化过程，确保程序中只有一个该类的实例，从而避免了多个实例之间可能出现的数据竞争和冲突问题。</p>
<p>常见的实现方式是将该类的构造函数声明为私有的，这样外部就无法直接实例化该类，然后通过一个静态方法来控制该类的实例化过程，确保只有一个实例被创建并返回该实例的引用。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>单例模式在很多场景中都有应用，比如在日志记录器、数据库连接池、线程池、配置文件管理器等场景中，都需要确保该类只有一个实例，以保证数据的一致性和安全性。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 获取单例实例的方法</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Singleton instance; <span class="comment">// 静态局部变量，保证只初始化一次</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个操作</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 构造函数私有化，禁止外部创建实例</span></span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造函数和赋值运算符重载函数私有化，禁止复制实例</span></span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Singleton</code> 类使用了私有化构造函数，以及私有化拷贝构造函数和赋值运算符重载函数，以防止在外部创建多个实例。同时，<code>getInstance()</code> 方法返回一个静态局部变量 <code>instance</code>，保证只初始化一次，并返回其引用。</p>
<h2 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Singleton&amp; s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">s1.<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">Singleton&amp; s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">s2.<span class="built_in">doSomething</span>();</span><br></pre></td></tr></table></figure>

<p>以上两次获取实例的调用都返回同一个实例，因此可以看作是单例模式的实现。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在C++11标准中，静态局部变量的初始化是线程安全的，编译器会保证只有一个线程会执行初始化，其他线程会等待初始化完成后再使用该变量。</p>
<p>如果你使用的是较早的C++标准或者其他编程语言，需要手动添加线程安全措施，例如加锁（mutex）等。</p>
<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>懒汉式单例模式是线程不安全的，如果存在多线程的场景，需要注意</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>懒汉式单例模式在第一次调用 <code>getInstance()</code> 方法时才会初始化实例，如果有多个线程同时调用 <code>getInstance()</code>，会导致多个线程同时检测到 <code>instance</code> 为 <code>nullptr</code>，从而创建多个实例。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式-结构型</title>
    <url>/2023/03d5946f52.html</url>
    <content><![CDATA[<p>结构型设计模式关注如何将对象和类组合成更大的结构，以实现更高级别的功能。</p>
<span id="more"></span>

<p>以下是几种常见的结构型设计模式：</p>
<p>适配器模式(Adapter Pattern)：将一个类的接口转换为另一个客户端所期望的接口格式。<br>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们能够独立地变化。<br>组合模式(Composite Pattern)：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端可以统一对待单个对象和组合对象。<br>装饰器模式(Decorator Pattern)：动态地给一个对象添加额外的职责，同时不改变其原有的结构。<br>外观模式(Facade Pattern)：为子系统中的一组接口提供一个一致的界面，以简化子系统的使用。<br>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度的对象。<br>代理模式(Proxy Pattern)：为其他对象提供一种代理以控制这个对象的访问。</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它的作用是将一个类的接口转换为另一个类的接口，以满足客户端对接口的需求。适配器模式通常用于系统接口的升级和改造，或者将一个现有的类用于另一个新的系统中。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>适配器模式可以分为两种类型：类适配器和对象适配器。类适配器通过多重继承实现，将适配器类继承自需要适配的类和目标接口，从而实现对目标接口的适配。对象适配器则通过组合实现，将适配器类组合一个需要适配的类的实例和目标接口的实例，从而实现对目标接口的适配。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>适配器模式的主要优点包括：</p>
<p>适配器模式可以让原本不兼容的接口进行合作，从而提高系统的灵活性和可扩展性。<br>适配器模式可以降低系统的耦合度，使得代码更易于维护和重构。<br>适配器模式可以重用现有的类，从而减少开发时间和成本。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>适配器模式的主要缺点包括：</p>
<p>适配器模式增加了系统的复杂度，可能会影响系统的性能和可读性。<br>适配器模式可能需要开发新的适配器类，从而增加开发成本。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在实际应用中，适配器模式可以应用于很多场景，比如：</p>
<p>将一个旧的类库适配为一个新的应用程序接口。<br>将一个第三方组件的接口适配为自己的系统接口。<br>将一个对象的接口适配为另一个对象的接口，以便它们可以一起工作。<br>将一个不同版本的接口适配为当前版本的接口，以便它们可以向后兼容。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设我们有一个 PrintInterface 接口，里面定义了一个 print 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们有两个不同的类 PrintA 和 PrintB，它们分别实现了 PrintInterface 接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintA</span> : <span class="keyword">public</span> PrintInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PrintA is printing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintB</span> : <span class="keyword">public</span> PrintInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;PrintB is printing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们有一个 PrintAdapter 类，它实现了 PrintInterface 接口，并包含了一个 PrintA 对象的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintAdapter</span> : <span class="keyword">public</span> PrintInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintAdapter</span>(PrintA* printA) : <span class="built_in">printA_</span>(printA) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        printA_-&gt;<span class="built_in">printA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PrintA* printA_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到 PrintAdapter 类的 print 方法实际上调用了 PrintA 类的 printA 方法。这里 PrintAdapter 类就扮演了适配器的角色，将 PrintA 类的接口适配成了 PrintInterface 接口。</p>
<p>下面我们可以看到如何使用适配器模式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 PrintA 类的对象进行打印</span></span><br><span class="line">    PrintA* printA = <span class="keyword">new</span> <span class="built_in">PrintA</span>();</span><br><span class="line">    printA-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用适配器，将 PrintA 类的对象适配成 PrintInterface 接口进行打印</span></span><br><span class="line">    PrintInterface* adapter = <span class="keyword">new</span> <span class="built_in">PrintAdapter</span>(printA);</span><br><span class="line">    adapter-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 PrintB 类的对象进行打印</span></span><br><span class="line">    PrintB* printB = <span class="keyword">new</span> <span class="built_in">PrintB</span>();</span><br><span class="line">    printB-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 PrintInterface 接口进行打印</span></span><br><span class="line">    PrintInterface* printInterface = <span class="keyword">new</span> <span class="built_in">PrintB</span>();</span><br><span class="line">    printInterface-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PrintA is printing</span><br><span class="line">PrintA is printing</span><br><span class="line">PrintB is printing</span><br><span class="line">PrintB is printing</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在适配器模式中使用了适配器 PrintAdapter 将 PrintA 类的接口适配成了 PrintInterface 接口，并通过 PrintInterface 接口实现了 PrintA 类的功能。同时，我们还可以直接使用 PrintB 类的对象或者 PrintInterface 接口进行打印。</p>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式是一种结构型设计模式，旨在将一个大类或一组紧密相关的类分解为抽象和实现两个独立的层次结构，并使用一个桥接接口将它们连接起来。桥接模式允许这些层次结构独立变化，从而可以更加灵活地设计代码。</p>
<p>在桥接模式中，有两个独立变化的维度：抽象和实现。抽象可以是一个类，也可以是一个接口，定义了具体实现需要的方法，而实现则是指具体实现的类或接口。桥接模式通过一个桥接接口来将抽象和实现连接起来。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>桥接模式的主要优点包括：</p>
<p>提高了代码的可扩展性和可维护性。<br>允许抽象和实现可以独立扩展，从而避免了类的爆炸式增长。<br>使得代码更加灵活，可以根据不同的需求进行组合。</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>桥接模式的主要缺点包括：</p>
<p>增加了代码的复杂性，需要额外的抽象层次和桥接接口。<br>对于简单的情况，使用桥接模式可能会增加不必要的复杂性。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>假设我们正在设计一个手机品牌和手机软件之间的关系。假设我们有两个手机品牌：华为和小米，并且有两个手机软件：微信和支付宝。我们希望能够让任何一种手机品牌都可以运行这两个软件，而且软件也可以在不同品牌的手机上运行。</p>
<p>使用桥接模式，我们可以将手机品牌和软件分别抽象为两个类。首先，定义一个手机品牌抽象类，它有一个纯虚函数RunSoftware：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneBrand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PhoneBrand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunSoftware</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建两个具体的手机品牌类，HuaweiPhone和XiaomiPhone，它们都实现了PhoneBrand类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> : <span class="keyword">public</span> PhoneBrand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RunSoftware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Run software on Huawei phone&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> : <span class="keyword">public</span> PhoneBrand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RunSoftware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Run software on Xiaomi phone&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来，我们定义一个手机软件抽象类，它也有一个纯虚函数Run：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneSoftware</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PhoneSoftware</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建两个具体的手机软件类，WeChatSoftware和AlipaySoftware，它们也都实现了PhoneSoftware类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeChatSoftware</span> : <span class="keyword">public</span> PhoneSoftware &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Run WeChat on phone&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipaySoftware</span> : <span class="keyword">public</span> PhoneSoftware &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Run Alipay on phone&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，我们创建一个桥接类Phone，它将手机品牌和手机软件连接在一起。它有两个成员变量：一个是指向PhoneBrand对象的指针，一个是指向PhoneSoftware对象的指针。Phone类有一个RunSoftware函数，它通过调用PhoneBrand对象的RunSoftware函数和PhoneSoftware对象的Run函数来运行软件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(PhoneBrand* brand, PhoneSoftware* software)</span><br><span class="line">        : <span class="built_in">brand_</span>(brand), <span class="built_in">software_</span>(software) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RunSoftware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        brand_-&gt;<span class="built_in">RunSoftware</span>();</span><br><span class="line">        software_-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PhoneBrand* brand_;</span><br><span class="line">    PhoneSoftware* software_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以创建各种不同品牌和不同软件的手机了。例如，要创建一个运行在华为手机上的微信，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PhoneBrand* huawei = <span class="keyword">new</span> <span class="built_in">HuaweiPhone</span>();</span><br><span class="line">PhoneSoftware* wechat = <span class="keyword">new</span> <span class="built_in">WeChatSoftware</span>();</span><br><span class="line">Phone* phone = <span class="keyword">new</span> <span class="built_in">Phone</span>(huawei, wechat);</span><br></pre></td></tr></table></figure>


<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式是一种结构型设计模式，它允许你将对象组合成树形结构来表现“整体&#x2F;部分”的层次结构，使得客户端能够使用统一的方式处理单个对象和对象组合。</p>
<p>组合模式是一种结构型设计模式，它允许你将对象组合成树形结构来表现“整体&#x2F;部分”的层次结构，使得客户端能够使用统一的方式处理单个对象和对象组合。</p>
<p>在组合模式中，每个组件（component）都是一个对象，可以是叶子节点（leaf）或者组合节点（composite）。叶子节点表示最终的对象，没有子节点；而组合节点可以包含一组子节点，这些子节点可以是叶子节点，也可以是组合节点，这样就形成了一棵树形结构。</p>
<p>组合模式中的两个关键角色是Component和Composite。Component是一个抽象类，定义了组合对象和叶子对象的公共接口；而Composite是组合节点的具体实现，包含一个子对象的列表，并实现了Component中定义的接口。</p>
<h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>组合模式通常在以下情况下使用：</p>
<p>当你需要表示对象的部分-整体层次结构，并且希望用户能够以统一的方式处理单个对象和对象集合时。</p>
<p>当你想要忽略对象集合和单个对象之间的差异时，统一使用它们。</p>
<p>当你希望在不修改现有代码的情况下添加新类型的组件时，使用组合模式特别有用。</p>
<p>例如，你正在开发一个绘图应用程序，该应用程序需要支持添加不同类型的图形元素（如线条、矩形、圆形、文本等）。这些元素可以分为两个类别：基本元素和复合元素。基本元素表示单个元素，如一条线或一个圆形，而复合元素表示包含其他元素的组合元素，如一个包含多个元素的矩形。</p>
<p>在这种情况下，你可以使用组合模式来表示这些图形元素，并统一地处理单个元素和组合元素。这样，用户可以以相同的方式绘制单个元素或组合元素。另外，如果你想要添加新类型的图形元素，你只需要添加一个新的子类来实现它即可，不需要修改现有的代码。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>下面是一个简单的示例，使用组合模式实现了一个文件系统的树形结</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(FileSystemComponent *component)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(FileSystemComponent *component)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(string name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;FileSystemComponent*&gt; components;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>(string name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; (directory)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> component : components) &#123;</span><br><span class="line">            component-&gt;<span class="built_in">display</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(FileSystemComponent *component)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(FileSystemComponent *component)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        components.<span class="built_in">remove</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create some files and directories</span></span><br><span class="line">    File *file1 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">    File *file2 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">    Directory *dir1 = <span class="keyword">new</span> <span class="built_in">Directory</span>(<span class="string">&quot;dir1&quot;</span>);</span><br><span class="line">    Directory *dir2 = <span class="keyword">new</span> <span class="built_in">Directory</span>(<span class="string">&quot;dir2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the tree structure</span></span><br><span class="line">    dir1-&gt;<span class="built_in">add</span>(file1);</span><br><span class="line">    dir2-&gt;<span class="built_in">add</span>(file2);</span><br><span class="line">    dir2-&gt;<span class="built_in">add</span>(dir1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the tree</span></span><br><span class="line">    dir2-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    <span class="keyword">delete</span> dir2;</span><br><span class="line">    <span class="keyword">delete</span> file1;</span><br><span class="line">    <span class="keyword">delete</span> file2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，FileSystemComponent是组合模式中的Component接口，File和Directory是具体实现的组件。File表示叶子节点，只有一个文件名属性和一个display方法；Directory表示组合节点，包含一个子对象的列表，以及add、remove和display方法。在main函数中，我们创建了一些文件和目录，将它们组合成树形结构，并通过调用根节点的display方法来打印整个文件系统的层次结构。</p>
<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰模式是一种结构型设计模式，它允许你在不改变对象接口的前提下，动态地向对象添加行为。这种模式通过创建一个装饰对象来包装原始对象，然后在装饰对象上添加功能来扩展原始对象的行为。</p>
<p>在装饰模式中，有四个主要角色：</p>
<p>抽象组件（Component）：定义了被装饰对象的接口，并声明了装饰方法。</p>
<p>具体组件（ConcreteComponent）：实现了抽象组件的接口，并提供了默认的实现。</p>
<p>抽象装饰器（Decorator）：继承了抽象组件，并包含了一个抽象组件的引用，以便对其进行装饰。</p>
<p>具体装饰器（ConcreteDecorator）：继承了抽象装饰器，并实现了其装饰方法，以扩展原始对象的功能。</p>
<p>使用装饰模式，你可以动态地向对象添加功能，而不需要修改原始对象的代码。这种方式比继承更灵活，因为你可以在运行时动态地添加或删除装饰器，从而影响对象的行为。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>假设有一个基础类 Shape，它定义了一个抽象方法 draw，用于绘制一个形状。现在我们想要在基础类的基础上，动态地添加一个边框的功能，可以使用装饰模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后定义一个装饰者类 ShapeDecorator，它也继承自 Shape，但包含一个指向基础组件的指针 component_。装饰者类也实现了 draw 方法，但是在调用 component_-&gt;draw() 之前或之后添加了额外的功能。在这个例子中，我们添加了一个边框。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeDecorator</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShapeDecorator</span>(Shape* component) : <span class="built_in">component_</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        component_-&gt;<span class="built_in">draw</span>();</span><br><span class="line">        <span class="built_in">drawBorder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drawBorder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Shape* component_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BorderDecorator</span> : <span class="keyword">public</span> ShapeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BorderDecorator</span>(Shape* component) : <span class="built_in">ShapeDecorator</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawBorder</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a border.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用 Rectangle 类创建一个矩形，并使用 BorderDecorator 类将其装饰，从而添加边框的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* rect = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    rect-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    Shape* rectWithBorder = <span class="keyword">new</span> <span class="built_in">BorderDecorator</span>(<span class="keyword">new</span> <span class="built_in">Rectangle</span>());</span><br><span class="line">    rectWithBorder-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Drawing a rectangle.</span><br><span class="line">Drawing a rectangle.</span><br><span class="line">Drawing a border.</span><br></pre></td></tr></table></figure>


<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式（Facade Pattern）是一种结构型设计模式，它为复杂系统提供一个简单的接口，隐藏了系统的复杂性，使得客户端可以更加方便地使用系统。</p>
<p>外观模式可以将一个复杂系统分成多个子系统，然后为每个子系统提供一个简单的接口，使得客户端可以通过这个接口来访问子系统，而无需了解子系统的具体实现。</p>
<p>外观模式的核心思想是封装，即将复杂的系统封装成一个简单的接口。这种封装可以使得系统更加易于维护和扩展。</p>
<p>举个例子，假设我们要开发一个游戏，游戏中包含多个子系统，比如音频系统、视频系统、输入系统、游戏逻辑系统等。如果客户端要使用这些子系统，就需要了解这些子系统的接口和实现方式，这样会增加客户端的复杂度。但是如果我们使用外观模式，将所有子系统封装成一个简单的接口，客户端只需要调用这个接口，就可以实现游戏的各种功能，而无需了解子系统的具体实现。</p>
<p>在实际开发中，外观模式经常用于封装底层库或框架的复杂性，提供简单的接口给客户端使用。</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>下面是一个用 C++ 实现的外观模式的示例，该示例模拟了一个音乐播放器，使用外观模式将不同的子系统（音乐库、播放列表、音量控制器）组合在一起，对外提供简单的接口，方便用户使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子系统1：音乐库 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicLibrary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadMusic</span><span class="params">(std::string musicName)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading music: &quot;</span> &lt;&lt; musicName &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟加载音乐的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子系统2：播放列表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMusicToPlayList</span><span class="params">(std::string musicName)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding music to playlist: &quot;</span> &lt;&lt; musicName &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟将音乐添加到播放列表的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子系统3：音量控制器 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VolumeController</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVolume</span><span class="params">(<span class="type">int</span> volume)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Setting volume to: &quot;</span> &lt;&lt; volume &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟设置音量的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外观类：音乐播放器 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playMusic</span><span class="params">(std::string musicName)</span> </span>&#123;</span><br><span class="line">        musicLibrary.<span class="built_in">loadMusic</span>(musicName);</span><br><span class="line">        playList.<span class="built_in">addMusicToPlayList</span>(musicName);</span><br><span class="line">        volumeController.<span class="built_in">setVolume</span>(<span class="number">50</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Now playing: &quot;</span> &lt;&lt; musicName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MusicLibrary musicLibrary;</span><br><span class="line">    PlayList playList;</span><br><span class="line">    VolumeController volumeController;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 客户端 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MusicPlayer musicPlayer;</span><br><span class="line">    musicPlayer.<span class="built_in">playMusic</span>(<span class="string">&quot;Yesterday&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，MusicLibrary、PlayList、VolumeController 三个类分别代表了音乐库、播放列表、音量控制器三个子系统。MusicPlayer 类是外观类，将三个子系统组合在一起，并对外提供简单的 playMusic 接口，方便用户使用。客户端只需要调用 MusicPlayer 的 playMusic 方法，即可完成一系列操作。</p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式是一种结构型设计模式，它通过将对象的状态分为内部状态和外部状态，从而减少应用程序中的对象数量。内部状态是与对象的特定实例无关的状态，而外部状态则取决于对象的特定实例和上下文。</p>
<p>在享元模式中，共享对象的内部状态，而外部状态则由客户端来维护和传递。这使得应用程序可以减少内存使用和对象创建的数量，从而提高性能和降低内存占用。</p>
<p>例如，一个文本编辑器可以使用享元模式来共享相同的字体对象。字体的内部状态是字体的名称、字形和大小等，而外部状态则是应用程序中每个字符的位置和颜色。</p>
<p>在实现享元模式时，可以使用工厂类来维护和管理共享对象池，确保对象的共享和创建的正确性。</p>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>享元模式的优点包括：</p>
<p>减少对象的数量，从而减少内存使用和提高性能。<br>可以在运行时动态添加和删除享元对象，从而提高灵活性。<br>通过共享对象的内部状态，可以减少应用程序的复杂性。</p>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>其缺点包括：</p>
<p>由于共享对象的内部状态是不可变的，因此无法为不同的应用程序场景创建不同的状态组合。<br>由于共享对象的内部状态是不可变的，因此必须确保对象在创建后不会被修改。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>下面是一个简单的 C++ 示例代码，演示如何使用享元模式来实现对网站用户信息的管理。在该示例中，User 是一个用户类，代表网站上的用户。UserFactory 类是一个享元工厂类，它维护了一个内部状态的池子，每个状态都与一个 User 对象相对应。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> age, <span class="type">const</span> string&amp; address) : </span><br><span class="line">        <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age), <span class="built_in">address_</span>(address) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">GetAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> address_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    string address_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取一个用户对象，如果该状态的用户对象不存在，则创建一个新的对象</span></span><br><span class="line">    <span class="function">User* <span class="title">GetUser</span><span class="params">(<span class="type">const</span> string&amp; name, <span class="type">int</span> age, <span class="type">const</span> string&amp; address)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先在内部状态的池子中查找是否已有对应的状态</span></span><br><span class="line">        <span class="keyword">auto</span> iter = user_pool_.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (iter != user_pool_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果已有，则返回对应的用户对象</span></span><br><span class="line">            <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有，则创建一个新的用户对象，并将其加入池子中</span></span><br><span class="line">            <span class="keyword">auto</span> user = <span class="keyword">new</span> <span class="built_in">User</span>(name, age, address);</span><br><span class="line">            user_pool_[name] = user;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string, User*&gt; user_pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个名为 &quot;Alice&quot; 的用户对象</span></span><br><span class="line">    <span class="keyword">auto</span> user1 = factory.<span class="built_in">GetUser</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">    cout &lt;&lt; user1-&gt;<span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; user1-&gt;<span class="built_in">GetAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; user1-&gt;<span class="built_in">GetAddress</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取另一个名为 &quot;Alice&quot; 的用户对象，这时会直接从内部状态池中获取</span></span><br><span class="line">    <span class="keyword">auto</span> user2 = factory.<span class="built_in">GetUser</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">    cout &lt;&lt; user2-&gt;<span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; user2-&gt;<span class="built_in">GetAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; user2-&gt;<span class="built_in">GetAddress</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在该示例中，UserFactory 类维护了一个内部状态的池子，每个状态都与一个 User 对象相对应。当调用 UserFactory::GetUser() 方法获取一个用户对象时，会先在内部状态的池子中查找是否已有对应的状态，如果已有，则返回对应的用户对象；否则，会创建一个新的用户对象，并将其加入池子中，然后返回这个新创建的用户对象。</p>
<p>在客户端代码中，每次需要获取一个用户对象时，都可以通过 UserFactory 类来获取，而无需直接创建新的 User 对象。这样，就可以有效地减少创建对象的开销，提高程序的性能和效率。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是一种结构型设计模式，它允许通过创建代理对象来控制对原始对象的访问。代理对象在客户端和目标对象之间起到中介作用，隐藏了目标对象的复杂性和提供了额外的控制和安全性。</p>
<p>代理模式通常涉及三个角色：目标对象、代理对象和客户端。目标对象是需要被代理的对象，代理对象控制着对目标对象的访问，并且可以在适当的时候创建、销毁或修改目标对象。客户端通过代理对象来访问目标对象，而不是直接访问目标对象。</p>
<p>代理模式可以分为静态代理和动态代理。静态代理需要手动编写代理类，而动态代理使用反射技术来在运行时动态地创建代理对象。</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>下面是一个简单的C++示例代码，展示了静态代理模式的实现，其中目标对象是一个简单的计算器类，代理对象通过计算器类提供的接口对其进行封装。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Calculator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCalculator</span> : <span class="keyword">public</span> Calculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorProxy</span> : <span class="keyword">public</span> Calculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CalculatorProxy</span>(Calculator* calc) : <span class="built_in">m_calc</span>(calc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在调用目标对象的方法之前或之后执行其他操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Before add operation...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = m_calc-&gt;<span class="built_in">add</span>(a, b);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;After add operation...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Calculator* m_calc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建目标对象</span></span><br><span class="line">    Calculator* calc = <span class="keyword">new</span> <span class="built_in">ConcreteCalculator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象并将目标对象传递给它</span></span><br><span class="line">    Calculator* proxy = <span class="keyword">new</span> <span class="built_in">CalculatorProxy</span>(calc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过代理对象调用目标对象的方法</span></span><br><span class="line">    <span class="type">int</span> result = proxy-&gt;<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> proxy;</span><br><span class="line">    <span class="keyword">delete</span> calc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式-行为型</title>
    <url>/2023/03657d957a.html</url>
    <content><![CDATA[<p>行为型设计模式关注对象之间的通信方式，以及如何在对象之间有效地传递信息。</p>
<span id="more"></span>

<p>以下是几种常见的行为型设计模式：</p>
<p>责任链模式(Chain of Responsibility Pattern)：将请求的发送者和接收者解耦，从而使得多个对象都有机会处理这个请求。<br>命令模式(Command Pattern)：将一个请求封装成一个对象，从而使不同的请求可以对客户进行参数化，并支持请求排队、记录日志、撤销操作等功能。<br>解释器模式(Interpreter Pattern)：给定一个语言，定义它的文法表示，并定义一个解释器，用来解释语言中的句子。<br>迭代器模式(Iterator Pattern)：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<br>中介者模式(Mediator Pattern)：用一个中介对象来封装一系列的对象交互，从而使各个对象之间的耦合松散，并且可以独立地改变它们之间的交互。<br>备忘录模式(Memento Pattern)：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象的状态。<br>观察者模式(Observer Pattern)：定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知并自动更新。<br>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为。<br>策略模式(Strategy Pattern)：定义算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用它的客户端（Context）而独立变化。<br>模板方法模式(Template Method Pattern)：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>访问者模式(Visitor pattern)：在访问者模式中，算法被分离出来并在一个称为“访问者”的对象中实现，它可以遍历复杂的数据结构并对其进行操作。</p>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式（Chain of Responsibility Pattern）是一种行为型模式，它可以使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<p>在责任链模式中，每个处理者都有一个后继处理者，如果当前处理者不能处理该请求，则将请求转发给下一个处理者，直到找到能够处理请求的处理者为止。因此，责任链模式实现了请求的发送者和接收者之间的解耦，让请求可以在不影响客户端的情况下被多个对象处理。</p>
<p>在责任链模式中，通常会定义一个抽象的处理者类，其中包含处理请求的方法和后继处理者的引用。具体的处理者类继承自抽象处理者类，实现自己的处理逻辑，同时将未处理的请求转发给后继处理者。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>责任链模式的优点是将请求的发送者和接收者解耦，提高系统的灵活性和可扩展性。缺点是由于请求需要在链中传递，因此可能会影响系统的性能。此外，如果链太长或者构造不合理，可能会导致请求无法被处理。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个基于责任链模式的简单示例，实现了一个电商系统的商品优惠活动审批流程。在这个示例中，有三种不同类型的审批人，分别是初审人员、中审人员和高审人员，每个审批人员都可以审批商品优惠活动，但是不同类型的审批人员有不同的审批权限和审批级别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象审批人员类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Approver</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Approver</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">approve</span><span class="params">(<span class="type">int</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(Approver* next)</span> </span>&#123; next_ = next; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Approver* next_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初审人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstApprover</span> : <span class="keyword">public</span> Approver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FirstApprover</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">FirstApprover</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">approve</span><span class="params">(<span class="type">int</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;初审通过！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next_) &#123;</span><br><span class="line">            next_-&gt;<span class="built_in">approve</span>(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中审人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondApprover</span> : <span class="keyword">public</span> Approver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SecondApprover</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">SecondApprover</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">approve</span><span class="params">(<span class="type">int</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">500</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;中审通过！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next_) &#123;</span><br><span class="line">            next_-&gt;<span class="built_in">approve</span>(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高审人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdApprover</span> : <span class="keyword">public</span> Approver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThirdApprover</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ThirdApprover</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">approve</span><span class="params">(<span class="type">int</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;高审通过！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;审批拒绝！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FirstApprover first_approver;</span><br><span class="line">    SecondApprover second_approver;</span><br><span class="line">    ThirdApprover third_approver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置责任链</span></span><br><span class="line">    first_approver.<span class="built_in">setNext</span>(&amp;second_approver);</span><br><span class="line">    second_approver.<span class="built_in">setNext</span>(&amp;third_approver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请活动</span></span><br><span class="line">    first_approver.<span class="built_in">approve</span>(<span class="number">80</span>); <span class="comment">// 初审通过</span></span><br><span class="line">    first_approver.<span class="built_in">approve</span>(<span class="number">200</span>); <span class="comment">// 中审通过</span></span><br><span class="line">    first_approver.<span class="built_in">approve</span>(<span class="number">800</span>); <span class="comment">// 高审通过</span></span><br><span class="line">    first_approver.<span class="built_in">approve</span>(<span class="number">1500</span>); <span class="comment">// 审批拒绝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，抽象审批人员类定义了一个纯虚函数approve()，表示审批操作。具体的审批人员类（初审人员、中审人员、高审人员）都继承自抽象审批人员类，实现了自己的审批逻辑，并通过setNext()函数设置了自己的下一个审批人员，形成了一个责任链。最后，在main()函数中，创建了三个审批人员对象，然后通过setNext()函数设置它们之间的关系，模拟了一次申请审批的流程。</p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式是一种行为设计模式，它将请求或操作封装为一个对象，从而使可以将不同的请求参数化和队列化。命令模式中，发送请求的对象称为发送者，执行请求的对象称为接收者，而将请求对象称为命令。</p>
<p>命令模式常常用于实现<strong>撤销操作，重做操作，日志记录</strong>等功能。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>假设我们有一个简单的文本编辑器，支持撤销和恢复操作。我们可以使用命令模式来实现这个功能。</p>
<p>首先，定义一个命令接口 Command，其中包含两个方法 execute() 和 undo()，分别用于执行命令和撤销命令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，定义具体的命令类。这里我们假设有两种命令：插入文本和删除文本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InsertCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InsertCommand</span>(string&amp; text, <span class="type">int</span> pos, <span class="type">char</span> ch)</span><br><span class="line">        : <span class="built_in">text_</span>(text), <span class="built_in">pos_</span>(pos), <span class="built_in">ch_</span>(ch), <span class="built_in">deleted_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        text_.<span class="built_in">insert</span>(pos_, <span class="number">1</span>, ch_);</span><br><span class="line">        deleted_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted_) &#123;</span><br><span class="line">            text_.<span class="built_in">erase</span>(pos_, <span class="number">1</span>);</span><br><span class="line">            deleted_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string&amp; text_;</span><br><span class="line">    <span class="type">int</span> pos_;</span><br><span class="line">    <span class="type">char</span> ch_;</span><br><span class="line">    <span class="type">bool</span> deleted_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeleteCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeleteCommand</span>(string&amp; text, <span class="type">int</span> pos)</span><br><span class="line">        : <span class="built_in">text_</span>(text), <span class="built_in">pos_</span>(pos), <span class="built_in">deleted_char_</span>(text_[pos]), <span class="built_in">deleted_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted_) &#123;</span><br><span class="line">            text_.<span class="built_in">erase</span>(pos_, <span class="number">1</span>);</span><br><span class="line">            deleted_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        text_.<span class="built_in">insert</span>(pos_, <span class="number">1</span>, deleted_char_);</span><br><span class="line">        deleted_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string&amp; text_;</span><br><span class="line">    <span class="type">int</span> pos_;</span><br><span class="line">    <span class="type">char</span> deleted_char_;</span><br><span class="line">    <span class="type">bool</span> deleted_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在文本编辑器中，我们需要有一个命令管理器，用于保存当前的命令和历史命令。每当用户执行一个命令时，该命令将被添加到命令管理器中，当需要撤销命令时，我们可以调用命令管理器中的 undo() 方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(Command* cmd)</span> </span>&#123;</span><br><span class="line">        cmd-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        commands_.<span class="built_in">push_back</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!commands_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cmd = commands_.<span class="built_in">back</span>();</span><br><span class="line">            cmd-&gt;<span class="built_in">undo</span>();</span><br><span class="line">            commands_.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Command*&gt; commands_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，在主函数中，我们可以使用命令模式来实现文本编辑器的撤销和恢复操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    CommandManager cmd_mgr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些命令</span></span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">InsertCommand</span>(text, <span class="number">6</span>, <span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">InsertCommand</span>(text, <span class="number">7</span>, <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">InsertCommand</span>(text, <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">InsertCommand</span>(text, <span class="number">9</span>, <span class="string">&#x27;+&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After insert: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销最后一个命令</span></span><br><span class="line">    cmd_mgr.<span class="built_in">undo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After undo: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次撤销</span></span><br><span class="line">    cmd_mgr.<span class="built_in">undo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After undo: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些命令</span></span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">DeleteCommand</span> (text, <span class="number">6</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">DeleteCommand</span> (text, <span class="number">7</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">DeleteCommand</span> (text, <span class="number">8</span>));</span><br><span class="line">    cmd_mgr.<span class="built_in">execute</span>(<span class="keyword">new</span> <span class="built_in">DeleteCommand</span> (text, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After delete: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销最后一个命令</span></span><br><span class="line">    cmd_mgr.<span class="built_in">undo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After undo: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次撤销</span></span><br><span class="line">    cmd_mgr.<span class="built_in">undo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After undo: &quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一种语言文法，以及一种解释器来解释该语言中的语句，使用户能够定义自己的语言，并能够解释执行。该模式常常用于编译器的实现中，也常常用于实现基于规则的系统，如正则表达式处理等。</p>
<p>在解释器模式中，通常有两个角色：抽象表达式（Abstract Expression）和具体表达式（Concrete Expression）。抽象表达式定义了解释器的接口，具体表达式则根据具体的语法规则实现该接口。此外，解释器还可以定义一些上下文相关的信息，这些信息对于理解并解释语言中的语句非常重要。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>假设有一个字符串类 String，需要实现一个解释器来解析字符串中的数字并求和。例如，字符串 “1+2+3” 应该解析为数字 1、2、3 并求和得到 6。</p>
<p>首先定义一个抽象解释器类 Interpreter，其中有一个纯虚函数 interpret() 用于解释字符串。然后定义一个具体解释器类 NumberInterpreter，用于解释数字；以及一个具体解释器类 AddInterpreter，用于解释加号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象解释器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Interpreter</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字解释器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberInterpreter</span> : <span class="keyword">public</span> Interpreter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberInterpreter</span>(<span class="type">int</span> number) : <span class="built_in">number_</span>(number) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> number_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加号解释器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddInterpreter</span> : <span class="keyword">public</span> Interpreter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddInterpreter</span>(Interpreter* left, Interpreter* right) : <span class="built_in">left_</span>(left), <span class="built_in">right_</span>(right) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AddInterpreter</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> left_;</span><br><span class="line">        <span class="keyword">delete</span> right_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left_-&gt;<span class="built_in">interpret</span>() + right_-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Interpreter* left_;</span><br><span class="line">    Interpreter* right_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterpreterContext</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InterpreterContext</span>(<span class="type">const</span> string&amp; input) : <span class="built_in">input_</span>(input) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">InterpreterContext</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> interpreter : interpreters_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> interpreter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转为解释器对象</span></span><br><span class="line">        <span class="type">int</span> len = input_.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(input_[i])) &#123; <span class="comment">// 如果是数字，则转为 NumberInterpreter 对象</span></span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">isdigit</span>(input_[j])) ++j;</span><br><span class="line">                string num = input_.<span class="built_in">substr</span>(i, j - i);</span><br><span class="line">                Interpreter* interpreter = <span class="keyword">new</span> <span class="built_in">NumberInterpreter</span>(<span class="built_in">stoi</span>(num));</span><br><span class="line">                interpreters_.<span class="built_in">push_back</span>(interpreter);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input_[i] == <span class="string">&#x27;+&#x27;</span>) &#123; <span class="comment">// 如果是加号，则转为 AddInterpreter 对象</span></span><br><span class="line">                Interpreter* left = interpreters_.<span class="built_in">back</span>();</span><br><span class="line">                Interpreter* right = <span class="keyword">new</span> <span class="built_in">NumberInterpreter</span>(<span class="built_in">stoi</span>(input_.<span class="built_in">substr</span>(i + <span class="number">1</span>)));</span><br><span class="line">                interpreters_.<span class="built_in">pop_back</span>();</span><br><span class="line">                Interpreter* interpreter = <span class="keyword">new</span> <span class="built_in">AddInterpreter</span>(left, right);</span><br><span class="line">                interpreters_.<span class="built_in">push_back</span>(interpreter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interpreters_.<span class="built_in">back</span>()-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string input_;</span><br><span class="line">    vector&lt;Interpreter*&gt; interpreters_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">InterpreterContext <span class="title">context</span><span class="params">(<span class="string">&quot;1+2+3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> result = context.<span class="built_in">evaluate</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个示例中，解释器模式将字符串解释为一个语法树，然后再通过遍历语法树求得最终结果。由于这里只有加法和数字，所以语法树很简单，只有两个节点。但如果要支持更多的运算符和操作数，语法树会变得更加复杂。</p>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它允许客户端遍历容器（如列表、数组等）中的元素，而不需要暴露该容器的内部实现。它通过提供一种统一的接口来遍历不同类型的容器，使得遍历算法可以与特定容器的实现解耦。</p>
<p>迭代器模式主要包含以下角色：</p>
<p>迭代器（Iterator）：定义遍历元素所需要的方法，一般来说会有 hasNext() 方法用于判断是否还有元素，next() 方法用于返回当前元素并将指针移动到下一个元素。<br>具体迭代器（ConcreteIterator）：实现迭代器接口，负责遍历具体的容器。<br>容器（Container）：定义返回一个迭代器的方法，例如 iterator() 方法，用于返回一个迭代器对象。<br>具体容器（ConcreteContainer）：实现容器接口，负责存储数据和返回迭代器对象。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VectorIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VectorIterator</span>(std::vector&lt;<span class="type">int</span>&gt;&amp; v) : <span class="built_in">v_</span>(v), <span class="built_in">index_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index_ &lt; v_.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v_[index_++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;&amp; v_;</span><br><span class="line">    <span class="type">int</span> index_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Container</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">iterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体容器实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VectorContainer</span> : <span class="keyword">public</span> Container &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VectorContainer</span>(std::vector&lt;<span class="type">int</span>&gt;&amp; v) : <span class="built_in">v_</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">Iterator* <span class="title">iterator</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VectorIterator</span>(v_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;&amp; v_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">VectorContainer <span class="title">container</span><span class="params">(v)</span></span>;</span><br><span class="line">    Iterator* iterator = container.<span class="built_in">iterator</span>();</span><br><span class="line">    <span class="keyword">while</span> (iterator-&gt;<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; iterator-&gt;<span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> iterator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例中，我们首先定义了一个迭代器接口 Iterator，其中 hasNext() 方法用于判断是否还有元素，next() 方法用于返回当前元素并将指针移动到下一个元素。接着，我们实现了一个具体的迭代器 VectorIterator，它基于一个 std::vector<int> 容器实现了 hasNext() 和 next() 方法。</p>
<p>在实际开发中，迭代器模式被广泛应用于STL中，比如vector、list、map等STL容器都提供了迭代器，通过迭代器可以方便地对容器中的元素进行遍历和操作。此外，迭代器模式也常用于数据库操作中，尤其是在对大型数据集进行查询和遍历时，通过迭代器可以减少内存占用和提高查询效率。</p>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它可以使对象间的通信通过中介者进行，而不是直接相互引用。这种模式中，中介者对象将负责协调多个对象之间的交互，从而使它们能够相互独立地改变和复用。</p>
<p>在中介者模式中，存在一个中介者对象，它封装了一系列的对象之间的交互逻辑。当一个对象发生变化时，它会通知中介者对象，然后由中介者对象进行相应的处理和通知其它相关对象。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>中介者模式的优点是将多个对象间的复杂关系和交互逻辑集中到了中介者对象中，从而使得对象间的通信更加简单，同时也提高了代码的可维护性和可扩展性。同时，中介者模式也可以减少对象间的耦合度，使得系统更加灵活和易于扩展。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>但是，中介者模式也有一些缺点。首先，由于中介者对象需要了解并处理多个对象间的逻辑关系，因此它往往会变得比较复杂，难以维护。此外，中介者模式也可能导致系统中出现大量的中介者对象，从而使得系统变得更加复杂。</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(Colleague* colleague, std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Colleague</span>(Mediator* mediator) : <span class="built_in">mediator_</span>(mediator) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator* mediator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendMessage</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator_-&gt;<span class="built_in">SendMessage</span>(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteColleagueA received message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueB</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendMessage</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator_-&gt;<span class="built_in">SendMessage</span>(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReceiveMessage</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteColleagueB received message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddColleague</span><span class="params">(Colleague* colleague)</span> </span>&#123;</span><br><span class="line">        colleagues_.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendMessage</span><span class="params">(Colleague* colleague, std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : colleagues_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != colleague) &#123;</span><br><span class="line">                c-&gt;<span class="built_in">ReceiveMessage</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Colleague*&gt; colleagues_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteMediator mediator;</span><br><span class="line">    <span class="function">ConcreteColleagueA <span class="title">colleagueA</span><span class="params">(&amp;mediator)</span></span>;</span><br><span class="line">    <span class="function">ConcreteColleagueB <span class="title">colleagueB</span><span class="params">(&amp;mediator)</span></span>;</span><br><span class="line"></span><br><span class="line">    mediator.<span class="built_in">AddColleague</span>(&amp;colleagueA);</span><br><span class="line">    mediator.<span class="built_in">AddColleague</span>(&amp;colleagueB);</span><br><span class="line"></span><br><span class="line">    colleagueA.<span class="built_in">SendMessage</span>(<span class="string">&quot;Hello, I&#x27;m Colleague A.&quot;</span>);</span><br><span class="line">    colleagueB.<span class="built_in">SendMessage</span>(<span class="string">&quot;Hi, I&#x27;m Colleague B.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例定义了中介者（Mediator）和同事（Colleague）两个基本抽象类。中介者定义了同事之间的通信接口，同事通过中介者进行通信。具体的同事类（ConcreteColleagueA和ConcreteColleagueB）实现了同事抽象类的接口，通过中介者与其他同事进行通信。具体中介者类（ConcreteMediator）实现了中介者抽象类的接口，负责管理同事对象，协调同事之间的通信。</p>
<p>在主函数中，我们创建了一个具体中介者对象和两个具体同事对象，将同事对象添加到中介者对象中，并通过同事对象的发送消息接口进行通信。</p>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>备忘录模式是一种行为型设计模式，它允许在不暴露对象实现细节的情况下捕获并存储对象的内部状态，并在以后将对象恢复到该状态。备忘录模式通常用于需要记录对象状态的情况，例如在撤销操作时，或者在处理事务性操作时需要回滚。</p>
<p>备忘录模式由三个主要角色组成：原始对象（Originator）、备忘录（Memento）和负责人（Caretaker）。原始对象负责创建备忘录，并从备忘录中恢复其状态。备忘录是原始对象状态的快照。负责人负责管理备忘录，并在必要时将其传递给原始对象。</p>
<p>备忘录模式的核心思想是将状态的存储和恢复与原始对象分离开来，以保持其封装性。这样可以将对象状态的实现细节隐藏起来，同时还可以更方便地在对象之间共享状态。备忘录模式的一个重要优点是它提供了一种简单且可扩展的方式来支持撤销操作。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>备忘录模式的使用场景通常是在需要记录一个对象的内部状态的变化历史，并且希望能够随时回到之前的某个状态时。比如：</p>
<p>编辑器软件中的“撤销”和“重做”功能，用户对文本进行修改时，软件可以将每次修改前的状态记录下来，当用户需要撤销或者重做某个操作时，可以将状态恢复到对应的历史状态。</p>
<p>游戏中的存档和读档功能，游戏可以将当前游戏状态保存到备忘录对象中，当玩家需要恢复到之前的某个状态时，可以通过读取备忘录对象来实现。</p>
<p>购物网站中的“购物车”功能，用户在选购商品时，可以将每个商品的状态记录下来，当用户需要修改购物车内容时，可以随时回到之前的某个状态。</p>
<p>总之，备忘录模式适用于需要记录对象状态变化历史、并且需要能够随时回溯到历史状态的场景。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类，用于存储某个状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">const</span> std::string&amp; state) : <span class="built_in">state_</span>(state) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Memento</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始对象类，需要进行备份的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Originator</span>(<span class="type">const</span> std::string&amp; state) : <span class="built_in">state_</span>(state) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Originator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> std::string&amp; state)</span> </span>&#123; state_ = state; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录对象，并保存当前状态</span></span><br><span class="line">    <span class="function">Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Memento</span>(state_); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据备忘录对象恢复状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restoreMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123; state_ = memento.<span class="built_in">getState</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理备忘录的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Caretaker</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Caretaker</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> m : mementos_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        mementos_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加备忘录对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMemento</span><span class="params">(Memento* memento)</span> </span>&#123; mementos_.<span class="built_in">push_back</span>(memento); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定位置的备忘录对象</span></span><br><span class="line">    <span class="function">Memento* <span class="title">getMemento</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= mementos_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mementos_[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento*&gt; mementos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Originator <span class="title">originator</span><span class="params">(<span class="string">&quot;Initial state&quot;</span>)</span></span>; <span class="comment">// 创建原始对象</span></span><br><span class="line">    Caretaker caretaker; <span class="comment">// 创建备忘录管理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加备忘录对象</span></span><br><span class="line">    caretaker.<span class="built_in">addMemento</span>(originator.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变原始对象状态</span></span><br><span class="line">    originator.<span class="built_in">setState</span>(<span class="string">&quot;New state&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加备忘录对象</span></span><br><span class="line">    caretaker.<span class="built_in">addMemento</span>(originator.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始对象状态</span></span><br><span class="line">    originator.<span class="built_in">restoreMemento</span>(*caretaker.<span class="built_in">getMemento</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; originator.<span class="built_in">getState</span>() &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Initial state&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。在观察者模式中，被观察的对象通常被称为主题（Subject），而观察者被称为订阅者（Observer）。</p>
<p>观察者模式的主要优点是实现了松耦合（Loose Coupling）的设计，因为主题和订阅者之间没有直接的依赖关系。这样一来，主题的变化不会影响到订阅者，也不会影响到其他的主题。观察者模式还可以实现动态的发布和订阅机制，因为主题和订阅者可以在运行时动态地注册和取消。</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; received the update.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers_.<span class="built_in">begin</span>(), observers_.<span class="built_in">end</span>(), observer), observers_.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> observer : observers_) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer1</span><span class="params">(<span class="string">&quot;Observer 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer2</span><span class="params">(<span class="string">&quot;Observer 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ConcreteSubject subject;</span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">detach</span>(&amp;observer1);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的示例中，Subject 定义了一个抽象主题的接口，包括注册、注销和通知观察者的方法；ConcreteSubject 是一个具体的主题，它维护了一个观察者列表，并在状态变化时通知观察者；Observer 定义了一个抽象观察者的接口，包括更新方法；ConcreteObserver 是一个具体的观察者，它在收到主题的通知后会执行自己的更新方法。在 main 函数中，我们创建了两个具体观察者</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式（State Pattern）是一种行为型设计模式，它允许对象在其内部状态改变时改变它的行为。这种模式把对象的行为包装在不同的状态对象里，每个状态对象都可以根据其内部状态改变而改变它的行为。</p>
<p>状态模式包含以下角色：</p>
<p>Context（上下文）：是具有状态的对象，维护一个当前状态对象，并在状态改变时通知状态对象进行相应的处理。<br>State（状态）：定义状态的接口，对于每个状态的具体实现，它有两个职责：处理自身相关的行为，同时处理状态转移。<br>ConcreteState（具体状态）：具体实现State接口的状态类，实现与上下文相关的行为。</p>
<h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(Context* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(Context* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(Context* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(State* state) : <span class="built_in">state_</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(State* state)</span> </span>&#123; state_ = state; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123; state_-&gt;<span class="built_in">handle</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State* state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteStateA::handle</span><span class="params">(Context* context)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ConcreteStateA handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    context-&gt;<span class="built_in">setState</span>(<span class="keyword">new</span> ConcreteStateB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteStateB::handle</span><span class="params">(Context* context)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ConcreteStateB handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    context-&gt;<span class="built_in">setState</span>(<span class="keyword">new</span> ConcreteStateA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    State* stateA = <span class="keyword">new</span> ConcreteStateA;</span><br><span class="line">    State* stateB = <span class="keyword">new</span> ConcreteStateB;</span><br><span class="line">    Context* context = <span class="keyword">new</span> <span class="built_in">Context</span>(stateA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态A处理请求</span></span><br><span class="line">    context-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态B处理请求</span></span><br><span class="line">    context-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context;</span><br><span class="line">    <span class="keyword">delete</span> stateA;</span><br><span class="line">    <span class="keyword">delete</span> stateB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中，有两个具体状态类ConcreteStateA和ConcreteStateB，它们实现了State接口，同时定义了它们各自的处理行为和状态转移。Context类作为具有状态的对象，维护了一个State对象，当请求发生时，会将请求交给当前状态对象进行处理，并根据处理结果决定是否需要转移状态。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时动态地选择算法的行为，将算法的实现与使用者分离开来。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在策略模式中，算法被封装成一系列的策略（Strategy），这些策略可以被外部使用者调用，使用者可以根据具体的场景需要动态地选择不同的策略来完成某种任务，而不需要关心具体的算法实现。</p>
<p>策略模式的优点在于它将不同的算法封装到不同的策略类中，使得算法的具体实现与客户端代码相互独立，从而更加容易维护和扩展。另外，策略模式还可以使得客户端代码更加灵活地选择不同的算法实现，从而可以根据不同的情况和需求选择最优的算法。</p>
<h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>举个例子，假设我们有一个排序器类（Sorter），该类有一个 sort() 函数用于排序。由于排序算法有很多种，我们可以考虑使用策略模式来将排序算法的实现与使用者分离开来。我们可以定义一个 SortStrategy 抽象类作为排序策略的接口，然后派生出不同的子类来实现具体的排序算法，如 QuickSortStrategy、MergeSortStrategy 等等。在 Sorter 类中，我们可以定义一个成员变量 sort_strategy_，用于保存当前的排序策略，然后在 sort() 函数中调用 sort_strategy_ 的 sort() 函数来完成排序操作。在使用该排序器类的时候，用户可以根据自己的需要选择不同的排序策略来完成排序操作。</p>
<h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序策略基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SortStrategy</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现快速排序算法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Using quick sort strategy...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现归并排序算法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Using merge sort strategy...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(SortStrategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        strategy_-&gt;<span class="built_in">sort</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortStrategy* strategy_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Sorter sorter;</span><br><span class="line">    QuickSortStrategy quick_sort;</span><br><span class="line">    MergeSortStrategy merge_sort;</span><br><span class="line"></span><br><span class="line">    sorter.<span class="built_in">setStrategy</span>(&amp;quick_sort);</span><br><span class="line">    sorter.<span class="built_in">sort</span>(nums); <span class="comment">// 使用快速排序策略</span></span><br><span class="line"></span><br><span class="line">    sorter.<span class="built_in">setStrategy</span>(&amp;merge_sort);</span><br><span class="line">    sorter.<span class="built_in">sort</span>(nums); <span class="comment">// 使用归并排序策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们首先定义了一个 SortStrategy 抽象类作为排序策略的接口，然后派生出 QuickSortStrategy 和 MergeSortStrategy 等子类来实现排序的功能。在具体场景中，根据不同的情况可以切换不同的策略。</p>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>模板方法模式也叫模板模式，模板模式（Template Pattern）是一种行为型设计模式，它定义了一个操作中的算法框架，将某些步骤延迟到子类中实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>该模式通常包含一个抽象模板类，它定义了算法的基本结构，以及一些抽象方法，由子类实现；还有具体子类，实现这些抽象方法，以完成算法的特定步骤。</p>
<p>该模式的优点在于，它使得算法的具体实现与其基本结构分离，使得算法更易于重用和扩展，同时还遵循了开闭原则和单一职责原则。</p>
<h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;T&gt;&amp; data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实现类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSortA</span> : <span class="keyword">public</span> AbstractSort&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;T&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using sort A.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 具体排序算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实现类B</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSortB</span> : <span class="keyword">public</span> AbstractSort&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;T&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using sort B.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 具体排序算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用模板实现类A进行排序</span></span><br><span class="line">    AbstractSort&lt;<span class="type">int</span>&gt;* sortA = <span class="keyword">new</span> <span class="built_in">ConcreteSortA</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    sortA-&gt;<span class="built_in">sort</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用模板实现类B进行排序</span></span><br><span class="line">    AbstractSort&lt;<span class="type">int</span>&gt;* sortB = <span class="keyword">new</span> <span class="built_in">ConcreteSortB</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    sortB-&gt;<span class="built_in">sort</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sortA;</span><br><span class="line">    <span class="keyword">delete</span> sortB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个模板类 AbstractSort，并规定了一个模板方法 sort，该方法接受一个 std::vector 类型的参数，并规定了排序算法的大致流程，但不涉及具体实现。</p>
<p>之后通过继承 AbstractSort 的方式实现了两个不同的排序算法类，即 ConcreteSortA 和 ConcreteSortB，并分别重写了 sort 方法，实现了不同的排序算法。</p>
<p>在 main 函数中，分别创建了 ConcreteSortA 和 ConcreteSortB 对象，并通过指向 AbstractSort 的指针调用 sort 方法实现了不同的排序算法。</p>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式是一种行为型设计模式，它可以在不修改被访问元素的类的前提下，通过将访问算法从元素中分离出来，使其能够独立地变化。这种模式将数据结构和数据操作分离开来，使得新的操作易于添加到现有系统中。</p>
<p>在访问者模式中，有两种基本元素：被访问的元素和访问者。被访问的元素通常是一个复杂的数据结构，例如一个对象树或一个列表。访问者是一个可以在各种元素上执行各种操作的对象。被访问的元素需要提供一种接受访问者的方法，以便访问者可以遍历它的子元素，并对它们执行特定的操作。</p>
<h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ElementA&amp; a)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ElementB&amp; b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ElementA&amp; a)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitor: visit ElementA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ElementB&amp; b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitor: visit ElementB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Element*&gt; elements&#123;<span class="keyword">new</span> ElementA, <span class="keyword">new</span> ElementB&#125;;</span><br><span class="line">    ConcreteVisitor visitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : elements) &#123;</span><br><span class="line">        element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : elements) &#123;</span><br><span class="line">        <span class="keyword">delete</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，有两个被访问的元素类：ElementA和ElementB，它们都实现了Element接口，并提供了accept()方法，以便访问者可以访问它们。</p>
<p>还有一个访问者类ConcreteVisitor，它实现了Visitor接口，并提供了visit()方法来访问元素。</p>
<p>在main()函数中，我们创建了一个包含ElementA和ElementB对象的向量。我们创建了一个ConcreteVisitor对象，并在for循环中依次遍历向量中的元素，对每个元素调用accept()方法，将访问者传递给它们。这样，元素就可以访问访问者，并让访问者对它们进行操作。</p>
<p>输出为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ConcreteVisitor: visit ElementA</span><br><span class="line">ConcreteVisitor: visit ElementB</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式</title>
    <url>/2023/0351539.html</url>
    <content><![CDATA[<blockquote>
<p>软件设计模式是在软件设计中广泛使用的经验总结，它们是针对一些常见的问题或情景的通用解决方案。这些设计模式可以被看作是一些被普遍认可的最佳实践，它们可以帮助我们构建高质量、可维护、可扩展和可重用的软件系统。</p>
</blockquote>
<span id="more"></span>

<p>常见的软件设计模式包括：</p>
<ol>
<li>创建型模式：用于处理对象的创建过程，包括工厂方法、抽象工厂、建造者、原型和单例模式。</li>
<li>结构型模式：用于处理对象之间的关系，包括适配器、桥接、组合、装饰、外观、享元和代理模式。</li>
<li>行为型模式：用于处理对象之间的交互，包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法和访问者模式。</li>
</ol>
<p>除了上述模式外，还有一些其他的模式，如并发模式、企业模式等。每种模式都有自己的优缺点和适用场景，在实际应用中需要根据具体的问题和需求进行选择。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>远程挂载目录</title>
    <url>/2023/043638.html</url>
    <content><![CDATA[<p>从远程主机上拷贝资料时，常用scp或rsync等命令完成。但是每次拷贝都要输入很长一串命令未免太过复杂。</p>
<p>介绍一个配置起来更简单的远程挂载方法：sshfs。</p>
<p>让操作远程目录就像操作本地目录一样。</p>
<span id="more"></span>

<h1 id="什么是sshfs"><a href="#什么是sshfs" class="headerlink" title="什么是sshfs"></a>什么是sshfs</h1><p>SSHFS（安全 SHell 文件系统）是 Linux（以及其他具有 FUSE 实现的操作系统，例如 Mac OS X 或 FreeBSD）的文件系统，只需使用远程计算机上的安全 shell 登录即可对远程计算机上的文件进行操作。 在安装 SSHFS 的本地计算机上,使用 FUSE（用户空间中的文件系统）内核模块进行实现。 </p>
<p>这样做的实际效果是，最终用户可以与通过 SSH 安全提供的远程文件无缝交互，就好像这些文件是他&#x2F;她计算机上的本地文件一样。 在远程计算机上，会用到 SSH 的 SFTP 子系统。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>默认情况下, sshfs 并未安装到Linux发行版中，需要运行如下命令进行安装：</p>
<p><code>sudo apt-get install -y sshfs</code></p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><p>安装 sshfs 软件包后，需要创建一个挂载目录，最终会将远程目录挂载到此目录。例如，在桌面创建shared文件夹用做挂载目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br><span class="line"><span class="built_in">mkdir</span> remote_desktop</span><br></pre></td></tr></table></figure>

<p>使用 sshfs 命令挂载远程目录,下面的命令会将ip地址为10.20.53.100的机器上的&#x2F;home&#x2F;uos&#x2F;Desktop&#x2F;shared目录挂载当前机器的~&#x2F;Desktop&#x2F;shared目录(注意远端目录需要用绝对路径)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sshfs -o allow_other,transform_symlinks uos@10.20.6.67:/home/uos/Desktop remote_desktop</span><br></pre></td></tr></table></figure>

<p>输入远端主机的密码后，即可挂载成功。(transform_symlinks并不是必须的，当挂载的目录中存在ln链接之类的文件时才需要，否则无法获取链接指向的文件)</p>
<p>如果你的远程主机配置了SSH秘钥授权登录，您可以使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sshfs -o allow_other,transform_symlinks,IdentityFile=~/.ssh/id_rsa uos@10.20.8.67:/home/uos/Desktop remote_desktop</span><br></pre></td></tr></table></figure>
<p>使用ls命令可以直接查看挂载目录中的内容</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/043638/1.png"
                       
                 ></p>
<p>也可以使用df -h查看目录挂载信息</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/043638/2.png"
                       
                 ></p>
<h1 id="永久挂载"><a href="#永久挂载" class="headerlink" title="永久挂载"></a>永久挂载</h1><p>可以通过修改&#x2F;etc&#x2F;fstab或者在开机自启动的脚本中添加上述的命令</p>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>卸载挂载目录统一用umount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount remote_desktop</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/043638/3.png"
                       
                 ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title>通过live系统重置密码</title>
    <url>/2023/04196.html</url>
    <content><![CDATA[<p>电脑密码忘记无法登录系统？<br>新借的测试机器密码没人知道？<br>电脑系统损坏重要资料不知如何导出？</p>
<span id="more"></span>
<p>…</p>
<p>如果您曾有过以上问题请继续往下看</p>
<h1 id="live系统"><a href="#live系统" class="headerlink" title="live系统"></a>live系统</h1><p>这是一种轻量的，可以存储到临时存储介质中的操作系统。当你的电脑系统无法正常启动时，可以通过切换到 live 系统进行修复。</p>
<h1 id="重置密码或拷贝资料"><a href="#重置密码或拷贝资料" class="headerlink" title="重置密码或拷贝资料"></a>重置密码或拷贝资料</h1><p>在uos上，可以通过启动盘制作工具制作u盘启动盘，此时启动盘本身就有一个 live 系统了，插入电脑后重启，立即不停的按 F12、 Delete 或 F8 这些按键(不同机型的按键不同，一般是F12和Delete居多)，</p>
<p>成功会进入选择引导界面,选中我们的 live 系统所在的存储设置(例如：u盘)，回车进入</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/1.jpg"
                       
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/2.jpg"
                       
                 ></p>
<p>点击安装，进入到安装器界面，此时不需要再继续操作，直接 Ctrl+Alt+F2 切换到另外一个 tty</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/3.jpg"
                       
                 ></p>
<p>切换到 root ,这里是不需要输入密码的<br><code>sudo -i</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/4.jpg"
                       
                 ></p>
<p>查看分区情况<br><code>lsblk</code></p>
<p>挂载对应分区到 &#x2F;mnt 目录(系统盘对应分区会有 bin boot data 等文件夹)</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/5.jpg"
                       
                 ></p>
<p>chroot到&#x2F;mnt目录(如果上一步挂载的分区不是系统磁盘，这里会报错，这时候可以先卸载挂载的分区，再逐个尝试挂载其他的分区，直到chroot正常为止)</p>
<p>重置uos账户密码<br><code>passwd uos</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2023/04196/6.jpg"
                       
                 ></p>
<p>如果您是要拷贝资料，此时也可以选择挂载您的移动硬盘或者u盘，将文件拷贝到移动硬盘或u盘中。</p>
<p>操作完成后退出当前终端，使用 umount 命令卸载刚刚挂载的分区</p>
<p>重启电脑，用新密码登录即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>live系统</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
</search>
